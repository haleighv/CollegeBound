
Lab 5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000068  00800200  00003f10  00003fa4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003f10  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000018c9  00800268  00800268  0000400c  2**0
                  ALLOC
  3 .stab         00002dcc  00000000  00000000  0000400c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000ba1  00000000  00000000  00006dd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000258  00000000  00000000  00007980  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000361f  00000000  00000000  00007bd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000ec8  00000000  00000000  0000b1f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001715  00000000  00000000  0000c0bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000d38  00000000  00000000  0000d7d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001393  00000000  00000000  0000e50c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003b22  00000000  00000000  0000f89f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000d0  00000000  00000000  000133c1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 81 00 	jmp	0x102	; 0x102 <__ctors_end>
       4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
       8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
       c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      10:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      14:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      18:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      1c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      20:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      24:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      28:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      2c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      30:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      34:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      38:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      3c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      40:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      44:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      48:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      4c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      50:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      54:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      58:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      5c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      60:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      64:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      68:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      6c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      70:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      74:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      78:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      7c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      80:	0c 94 e8 11 	jmp	0x23d0	; 0x23d0 <__vector_32>
      84:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      88:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      8c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      90:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      94:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      98:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      9c:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      a0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      a4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      a8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      ac:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      b0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      b4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      b8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      bc:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      c0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      c4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      c8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      cc:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      d0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      d4:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      d8:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      dc:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      e0:	0c 94 a3 00 	jmp	0x146	; 0x146 <__bad_interrupt>
      e4:	05 a8       	sts	0x85, r16
      e6:	4c cd       	rjmp	.-1384   	; 0xfffffb80 <__eeprom_end+0xff7efb80>
      e8:	b2 d4       	rcall	.+2404   	; 0xa4e <createAsteroid+0x3e>
      ea:	4e b9       	out	0x0e, r20	; 14
      ec:	38 36       	cpi	r19, 0x68	; 104
      ee:	a9 02       	muls	r26, r25
      f0:	0c 50       	subi	r16, 0x0C	; 12
      f2:	b9 91       	ld	r27, Y+
      f4:	86 88       	ldd	r8, Z+22	; 0x16
      f6:	08 3c       	cpi	r16, 0xC8	; 200
      f8:	a6 aa       	sts	0x96, r26
      fa:	aa 2a       	or	r10, r26
      fc:	be 00       	.word	0x00be	; ????
      fe:	00 00       	nop
     100:	80 3f       	cpi	r24, 0xF0	; 240

00000102 <__ctors_end>:
     102:	11 24       	eor	r1, r1
     104:	1f be       	out	0x3f, r1	; 63
     106:	cf ef       	ldi	r28, 0xFF	; 255
     108:	d1 e2       	ldi	r29, 0x21	; 33
     10a:	de bf       	out	0x3e, r29	; 62
     10c:	cd bf       	out	0x3d, r28	; 61
     10e:	00 e0       	ldi	r16, 0x00	; 0
     110:	0c bf       	out	0x3c, r16	; 60

00000112 <__do_copy_data>:
     112:	12 e0       	ldi	r17, 0x02	; 2
     114:	a0 e0       	ldi	r26, 0x00	; 0
     116:	b2 e0       	ldi	r27, 0x02	; 2
     118:	e0 e1       	ldi	r30, 0x10	; 16
     11a:	ff e3       	ldi	r31, 0x3F	; 63
     11c:	00 e0       	ldi	r16, 0x00	; 0
     11e:	0b bf       	out	0x3b, r16	; 59
     120:	02 c0       	rjmp	.+4      	; 0x126 <__do_copy_data+0x14>
     122:	07 90       	elpm	r0, Z+
     124:	0d 92       	st	X+, r0
     126:	a8 36       	cpi	r26, 0x68	; 104
     128:	b1 07       	cpc	r27, r17
     12a:	d9 f7       	brne	.-10     	; 0x122 <__do_copy_data+0x10>
     12c:	1b be       	out	0x3b, r1	; 59

0000012e <__do_clear_bss>:
     12e:	1b e1       	ldi	r17, 0x1B	; 27
     130:	a8 e6       	ldi	r26, 0x68	; 104
     132:	b2 e0       	ldi	r27, 0x02	; 2
     134:	01 c0       	rjmp	.+2      	; 0x138 <.do_clear_bss_start>

00000136 <.do_clear_bss_loop>:
     136:	1d 92       	st	X+, r1

00000138 <.do_clear_bss_start>:
     138:	a1 33       	cpi	r26, 0x31	; 49
     13a:	b1 07       	cpc	r27, r17
     13c:	e1 f7       	brne	.-8      	; 0x136 <.do_clear_bss_loop>
     13e:	0e 94 2c 04 	call	0x858	; 0x858 <main>
     142:	0c 94 86 1f 	jmp	0x3f0c	; 0x3f0c <_exit>

00000146 <__bad_interrupt>:
     146:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000014a <inputTask>:
     * ship.accel stores if the ship is moving
     * ship.a_vel stores which direction the ship is moving in
     */
    while (1) {
		if(LEFT_BUTTON)
			ship.a_vel = +SHIP_AVEL;
     14a:	af e7       	ldi	r26, 0x7F	; 127
     14c:	b2 e0       	ldi	r27, 0x02	; 2
     14e:	86 e0       	ldi	r24, 0x06	; 6
		else if(RIGHT_BUTTON)
			ship.a_vel = -SHIP_AVEL;
     150:	9a ef       	ldi	r25, 0xFA	; 250
			ship.a_vel = 0;
			
		if(ACCEL_BUTTON)
			ship.accel = SHIP_ACCEL;
		else
			 ship.accel =0;
     152:	e9 e7       	ldi	r30, 0x79	; 121
     154:	f2 e0       	ldi	r31, 0x02	; 2
     156:	40 e0       	ldi	r20, 0x00	; 0
     158:	50 e0       	ldi	r21, 0x00	; 0
     15a:	ba 01       	movw	r22, r20
			ship.a_vel = -SHIP_AVEL;
		else
			ship.a_vel = 0;
			
		if(ACCEL_BUTTON)
			ship.accel = SHIP_ACCEL;
     15c:	0d ec       	ldi	r16, 0xCD	; 205
     15e:	1c ec       	ldi	r17, 0xCC	; 204
     160:	2c ec       	ldi	r18, 0xCC	; 204
     162:	3d e3       	ldi	r19, 0x3D	; 61
    /* Note:
     * ship.accel stores if the ship is moving
     * ship.a_vel stores which direction the ship is moving in
     */
    while (1) {
		if(LEFT_BUTTON)
     164:	1f 99       	sbic	0x03, 7	; 3
     166:	02 c0       	rjmp	.+4      	; 0x16c <inputTask+0x22>
			ship.a_vel = +SHIP_AVEL;
     168:	8c 93       	st	X, r24
     16a:	05 c0       	rjmp	.+10     	; 0x176 <inputTask+0x2c>
		else if(RIGHT_BUTTON)
     16c:	1e 99       	sbic	0x03, 6	; 3
     16e:	02 c0       	rjmp	.+4      	; 0x174 <inputTask+0x2a>
			ship.a_vel = -SHIP_AVEL;
     170:	9c 93       	st	X, r25
     172:	01 c0       	rjmp	.+2      	; 0x176 <inputTask+0x2c>
		else
			ship.a_vel = 0;
     174:	1c 92       	st	X, r1
			
		if(ACCEL_BUTTON)
     176:	19 99       	sbic	0x03, 1	; 3
     178:	05 c0       	rjmp	.+10     	; 0x184 <inputTask+0x3a>
			ship.accel = SHIP_ACCEL;
     17a:	00 83       	st	Z, r16
     17c:	11 83       	std	Z+1, r17	; 0x01
     17e:	22 83       	std	Z+2, r18	; 0x02
     180:	33 83       	std	Z+3, r19	; 0x03
     182:	f0 cf       	rjmp	.-32     	; 0x164 <inputTask+0x1a>
		else
			 ship.accel =0;
     184:	40 83       	st	Z, r20
     186:	51 83       	std	Z+1, r21	; 0x01
     188:	62 83       	std	Z+2, r22	; 0x02
     18a:	73 83       	std	Z+3, r23	; 0x03
     18c:	eb cf       	rjmp	.-42     	; 0x164 <inputTask+0x1a>

0000018e <updateTask>:
 *  If a bullet has been in flight for too long, this task will delete it. This
 *  task runs every 10 milliseconds.
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void updateTask(void *vParam) {
     18e:	cf 93       	push	r28
     190:	df 93       	push	r29
     192:	0f 92       	push	r0
     194:	0f 92       	push	r0
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
		ship.vel.x += ship.accel * -sin(ship.angle * DEG_TO_RAD);
		ship.vel.y += ship.accel * -cos(ship.angle * DEG_TO_RAD);
		vel = ship.vel.x * ship.vel.x + ship.vel.y * ship.vel.y;
		if (vel > SHIP_MAX_VEL) {
			ship.vel.x *= SHIP_MAX_VEL / vel;
			ship.vel.y *= SHIP_MAX_VEL / vel;
     19a:	81 e7       	ldi	r24, 0x71	; 113
     19c:	92 e0       	ldi	r25, 0x02	; 2
     19e:	04 96       	adiw	r24, 0x04	; 4
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
void updateTask(void *vParam) {
	float vel;
	object *objIter, *objPrev;
	for (;;) {
		// spin ship
		ship.angle += ship.a_vel;
     1a4:	ef e7       	ldi	r30, 0x7F	; 127
     1a6:	f2 e0       	ldi	r31, 0x02	; 2
     1a8:	80 81       	ld	r24, Z
     1aa:	99 27       	eor	r25, r25
     1ac:	87 fd       	sbrc	r24, 7
     1ae:	90 95       	com	r25
     1b0:	32 97       	sbiw	r30, 0x02	; 2
     1b2:	20 81       	ld	r18, Z
     1b4:	31 81       	ldd	r19, Z+1	; 0x01
     1b6:	82 0f       	add	r24, r18
     1b8:	93 1f       	adc	r25, r19
     1ba:	91 83       	std	Z+1, r25	; 0x01
     1bc:	80 83       	st	Z, r24
		if (ship.angle >= 360)
     1be:	f1 e0       	ldi	r31, 0x01	; 1
     1c0:	88 36       	cpi	r24, 0x68	; 104
     1c2:	9f 07       	cpc	r25, r31
     1c4:	2c f0       	brlt	.+10     	; 0x1d0 <updateTask+0x42>
         ship.angle -= 360;
     1c6:	88 56       	subi	r24, 0x68	; 104
     1c8:	91 40       	sbci	r25, 0x01	; 1
     1ca:	91 83       	std	Z+1, r25	; 0x01
     1cc:	80 83       	st	Z, r24
     1ce:	08 c0       	rjmp	.+16     	; 0x1e0 <updateTask+0x52>
		else if (ship.angle < 0)
     1d0:	99 23       	and	r25, r25
     1d2:	34 f4       	brge	.+12     	; 0x1e0 <updateTask+0x52>
		   ship.angle += 360;
     1d4:	88 59       	subi	r24, 0x98	; 152
     1d6:	9e 4f       	sbci	r25, 0xFE	; 254
     1d8:	ed e7       	ldi	r30, 0x7D	; 125
     1da:	f2 e0       	ldi	r31, 0x02	; 2
     1dc:	91 83       	std	Z+1, r25	; 0x01
     1de:	80 83       	st	Z, r24
		// move ship
		ship.vel.x += ship.accel * -sin(ship.angle * DEG_TO_RAD);
     1e0:	e9 e7       	ldi	r30, 0x79	; 121
     1e2:	f2 e0       	ldi	r31, 0x02	; 2
     1e4:	c0 80       	ld	r12, Z
     1e6:	d1 80       	ldd	r13, Z+1	; 0x01
     1e8:	e2 80       	ldd	r14, Z+2	; 0x02
     1ea:	f3 80       	ldd	r15, Z+3	; 0x03
     1ec:	34 96       	adiw	r30, 0x04	; 4
     1ee:	60 81       	ld	r22, Z
     1f0:	71 81       	ldd	r23, Z+1	; 0x01
     1f2:	88 27       	eor	r24, r24
     1f4:	77 fd       	sbrc	r23, 7
     1f6:	80 95       	com	r24
     1f8:	98 2f       	mov	r25, r24
     1fa:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
     1fe:	2b ed       	ldi	r18, 0xDB	; 219
     200:	3f e0       	ldi	r19, 0x0F	; 15
     202:	49 e4       	ldi	r20, 0x49	; 73
     204:	50 e4       	ldi	r21, 0x40	; 64
     206:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
     20a:	20 e0       	ldi	r18, 0x00	; 0
     20c:	30 e0       	ldi	r19, 0x00	; 0
     20e:	44 e3       	ldi	r20, 0x34	; 52
     210:	53 e4       	ldi	r21, 0x43	; 67
     212:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__divsf3>
     216:	b6 2e       	mov	r11, r22
     218:	87 2e       	mov	r8, r23
     21a:	18 2f       	mov	r17, r24
     21c:	09 2f       	mov	r16, r25
     21e:	86 2f       	mov	r24, r22
     220:	98 2d       	mov	r25, r8
     222:	a1 2f       	mov	r26, r17
     224:	b0 2f       	mov	r27, r16
     226:	bc 01       	movw	r22, r24
     228:	cd 01       	movw	r24, r26
     22a:	0e 94 35 1e 	call	0x3c6a	; 0x3c6a <sin>
     22e:	dc 01       	movw	r26, r24
     230:	cb 01       	movw	r24, r22
     232:	9c 01       	movw	r18, r24
     234:	ad 01       	movw	r20, r26
     236:	50 58       	subi	r21, 0x80	; 128
     238:	c7 01       	movw	r24, r14
     23a:	b6 01       	movw	r22, r12
     23c:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
     240:	e1 e7       	ldi	r30, 0x71	; 113
     242:	f2 e0       	ldi	r31, 0x02	; 2
     244:	20 81       	ld	r18, Z
     246:	31 81       	ldd	r19, Z+1	; 0x01
     248:	42 81       	ldd	r20, Z+2	; 0x02
     24a:	53 81       	ldd	r21, Z+3	; 0x03
     24c:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     250:	46 2e       	mov	r4, r22
     252:	37 2e       	mov	r3, r23
     254:	28 2e       	mov	r2, r24
     256:	79 2e       	mov	r7, r25
     258:	86 2f       	mov	r24, r22
     25a:	93 2d       	mov	r25, r3
     25c:	a2 2d       	mov	r26, r2
     25e:	b7 2d       	mov	r27, r7
     260:	e1 e7       	ldi	r30, 0x71	; 113
     262:	f2 e0       	ldi	r31, 0x02	; 2
     264:	80 83       	st	Z, r24
     266:	91 83       	std	Z+1, r25	; 0x01
     268:	a2 83       	std	Z+2, r26	; 0x02
     26a:	b3 83       	std	Z+3, r27	; 0x03
		ship.vel.y += ship.accel * -cos(ship.angle * DEG_TO_RAD);
     26c:	8b 2d       	mov	r24, r11
     26e:	98 2d       	mov	r25, r8
     270:	a1 2f       	mov	r26, r17
     272:	b0 2f       	mov	r27, r16
     274:	bc 01       	movw	r22, r24
     276:	cd 01       	movw	r24, r26
     278:	0e 94 47 1c 	call	0x388e	; 0x388e <cos>
     27c:	dc 01       	movw	r26, r24
     27e:	cb 01       	movw	r24, r22
     280:	9c 01       	movw	r18, r24
     282:	ad 01       	movw	r20, r26
     284:	50 58       	subi	r21, 0x80	; 128
     286:	c7 01       	movw	r24, r14
     288:	b6 01       	movw	r22, r12
     28a:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
     28e:	e5 e7       	ldi	r30, 0x75	; 117
     290:	f2 e0       	ldi	r31, 0x02	; 2
     292:	20 81       	ld	r18, Z
     294:	31 81       	ldd	r19, Z+1	; 0x01
     296:	42 81       	ldd	r20, Z+2	; 0x02
     298:	53 81       	ldd	r21, Z+3	; 0x03
     29a:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     29e:	66 2e       	mov	r6, r22
     2a0:	57 2e       	mov	r5, r23
     2a2:	f8 2e       	mov	r15, r24
     2a4:	e9 2e       	mov	r14, r25
     2a6:	86 2f       	mov	r24, r22
     2a8:	95 2d       	mov	r25, r5
     2aa:	af 2d       	mov	r26, r15
     2ac:	be 2d       	mov	r27, r14
     2ae:	e5 e7       	ldi	r30, 0x75	; 117
     2b0:	f2 e0       	ldi	r31, 0x02	; 2
     2b2:	80 83       	st	Z, r24
     2b4:	91 83       	std	Z+1, r25	; 0x01
     2b6:	a2 83       	std	Z+2, r26	; 0x02
     2b8:	b3 83       	std	Z+3, r27	; 0x03
		vel = ship.vel.x * ship.vel.x + ship.vel.y * ship.vel.y;
     2ba:	32 2d       	mov	r19, r2
     2bc:	84 2d       	mov	r24, r4
     2be:	93 2d       	mov	r25, r3
     2c0:	a2 2d       	mov	r26, r2
     2c2:	b7 2d       	mov	r27, r7
     2c4:	bc 01       	movw	r22, r24
     2c6:	cd 01       	movw	r24, r26
     2c8:	04 2d       	mov	r16, r4
     2ca:	13 2d       	mov	r17, r3
     2cc:	23 2f       	mov	r18, r19
     2ce:	3b 2f       	mov	r19, r27
     2d0:	a9 01       	movw	r20, r18
     2d2:	98 01       	movw	r18, r16
     2d4:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
     2d8:	4b 01       	movw	r8, r22
     2da:	5c 01       	movw	r10, r24
     2dc:	3f 2d       	mov	r19, r15
     2de:	86 2d       	mov	r24, r6
     2e0:	95 2d       	mov	r25, r5
     2e2:	af 2d       	mov	r26, r15
     2e4:	be 2d       	mov	r27, r14
     2e6:	bc 01       	movw	r22, r24
     2e8:	cd 01       	movw	r24, r26
     2ea:	06 2d       	mov	r16, r6
     2ec:	15 2d       	mov	r17, r5
     2ee:	23 2f       	mov	r18, r19
     2f0:	3b 2f       	mov	r19, r27
     2f2:	a9 01       	movw	r20, r18
     2f4:	98 01       	movw	r18, r16
     2f6:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
     2fa:	9b 01       	movw	r18, r22
     2fc:	ac 01       	movw	r20, r24
     2fe:	c5 01       	movw	r24, r10
     300:	b4 01       	movw	r22, r8
     302:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     306:	16 2f       	mov	r17, r22
     308:	07 2f       	mov	r16, r23
     30a:	c8 2e       	mov	r12, r24
     30c:	89 2e       	mov	r8, r25
		if (vel > SHIP_MAX_VEL) {
     30e:	86 2f       	mov	r24, r22
     310:	90 2f       	mov	r25, r16
     312:	ac 2d       	mov	r26, r12
     314:	b8 2d       	mov	r27, r8
     316:	bc 01       	movw	r22, r24
     318:	cd 01       	movw	r24, r26
     31a:	20 e0       	ldi	r18, 0x00	; 0
     31c:	30 e0       	ldi	r19, 0x00	; 0
     31e:	40 e0       	ldi	r20, 0x00	; 0
     320:	51 e4       	ldi	r21, 0x41	; 65
     322:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <__gesf2>
     326:	18 16       	cp	r1, r24
     328:	dc f5       	brge	.+118    	; 0x3a0 <updateTask+0x212>
			ship.vel.x *= SHIP_MAX_VEL / vel;
     32a:	60 e0       	ldi	r22, 0x00	; 0
     32c:	70 e0       	ldi	r23, 0x00	; 0
     32e:	80 e0       	ldi	r24, 0x00	; 0
     330:	91 e4       	ldi	r25, 0x41	; 65
     332:	e0 2f       	mov	r30, r16
     334:	01 2f       	mov	r16, r17
     336:	1e 2f       	mov	r17, r30
     338:	2c 2d       	mov	r18, r12
     33a:	38 2d       	mov	r19, r8
     33c:	a9 01       	movw	r20, r18
     33e:	98 01       	movw	r18, r16
     340:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__divsf3>
     344:	c6 2e       	mov	r12, r22
     346:	87 2e       	mov	r8, r23
     348:	d8 2e       	mov	r13, r24
     34a:	b9 2e       	mov	r11, r25
     34c:	84 2d       	mov	r24, r4
     34e:	93 2d       	mov	r25, r3
     350:	a2 2d       	mov	r26, r2
     352:	b7 2d       	mov	r27, r7
     354:	bc 01       	movw	r22, r24
     356:	cd 01       	movw	r24, r26
     358:	0c 2d       	mov	r16, r12
     35a:	18 2d       	mov	r17, r8
     35c:	2d 2d       	mov	r18, r13
     35e:	3b 2d       	mov	r19, r11
     360:	a9 01       	movw	r20, r18
     362:	98 01       	movw	r18, r16
     364:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
     368:	dc 01       	movw	r26, r24
     36a:	cb 01       	movw	r24, r22
     36c:	e1 e7       	ldi	r30, 0x71	; 113
     36e:	f2 e0       	ldi	r31, 0x02	; 2
     370:	80 83       	st	Z, r24
     372:	91 83       	std	Z+1, r25	; 0x01
     374:	a2 83       	std	Z+2, r26	; 0x02
     376:	b3 83       	std	Z+3, r27	; 0x03
			ship.vel.y *= SHIP_MAX_VEL / vel;
     378:	86 2d       	mov	r24, r6
     37a:	95 2d       	mov	r25, r5
     37c:	af 2d       	mov	r26, r15
     37e:	be 2d       	mov	r27, r14
     380:	bc 01       	movw	r22, r24
     382:	cd 01       	movw	r24, r26
     384:	2d 2d       	mov	r18, r13
     386:	3b 2d       	mov	r19, r11
     388:	a9 01       	movw	r20, r18
     38a:	98 01       	movw	r18, r16
     38c:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
     390:	dc 01       	movw	r26, r24
     392:	cb 01       	movw	r24, r22
     394:	e9 81       	ldd	r30, Y+1	; 0x01
     396:	fa 81       	ldd	r31, Y+2	; 0x02
     398:	80 83       	st	Z, r24
     39a:	91 83       	std	Z+1, r25	; 0x01
     39c:	a2 83       	std	Z+2, r26	; 0x02
     39e:	b3 83       	std	Z+3, r27	; 0x03
		}
		ship.pos.x += ship.vel.x;
     3a0:	e9 e6       	ldi	r30, 0x69	; 105
     3a2:	f2 e0       	ldi	r31, 0x02	; 2
     3a4:	60 81       	ld	r22, Z
     3a6:	71 81       	ldd	r23, Z+1	; 0x01
     3a8:	82 81       	ldd	r24, Z+2	; 0x02
     3aa:	93 81       	ldd	r25, Z+3	; 0x03
     3ac:	38 96       	adiw	r30, 0x08	; 8
     3ae:	20 81       	ld	r18, Z
     3b0:	31 81       	ldd	r19, Z+1	; 0x01
     3b2:	42 81       	ldd	r20, Z+2	; 0x02
     3b4:	53 81       	ldd	r21, Z+3	; 0x03
     3b6:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     3ba:	06 2f       	mov	r16, r22
     3bc:	17 2f       	mov	r17, r23
     3be:	e8 2e       	mov	r14, r24
     3c0:	f9 2e       	mov	r15, r25
     3c2:	86 2f       	mov	r24, r22
     3c4:	91 2f       	mov	r25, r17
     3c6:	ae 2d       	mov	r26, r14
     3c8:	bf 2d       	mov	r27, r15
     3ca:	e9 e6       	ldi	r30, 0x69	; 105
     3cc:	f2 e0       	ldi	r31, 0x02	; 2
     3ce:	80 83       	st	Z, r24
     3d0:	91 83       	std	Z+1, r25	; 0x01
     3d2:	a2 83       	std	Z+2, r26	; 0x02
     3d4:	b3 83       	std	Z+3, r27	; 0x03
		ship.pos.y += ship.vel.y;
     3d6:	34 96       	adiw	r30, 0x04	; 4
     3d8:	60 81       	ld	r22, Z
     3da:	71 81       	ldd	r23, Z+1	; 0x01
     3dc:	82 81       	ldd	r24, Z+2	; 0x02
     3de:	93 81       	ldd	r25, Z+3	; 0x03
     3e0:	38 96       	adiw	r30, 0x08	; 8
     3e2:	20 81       	ld	r18, Z
     3e4:	31 81       	ldd	r19, Z+1	; 0x01
     3e6:	42 81       	ldd	r20, Z+2	; 0x02
     3e8:	53 81       	ldd	r21, Z+3	; 0x03
     3ea:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     3ee:	dc 01       	movw	r26, r24
     3f0:	cb 01       	movw	r24, r22
     3f2:	ed e6       	ldi	r30, 0x6D	; 109
     3f4:	f2 e0       	ldi	r31, 0x02	; 2
     3f6:	80 83       	st	Z, r24
     3f8:	91 83       	std	Z+1, r25	; 0x01
     3fa:	a2 83       	std	Z+2, r26	; 0x02
     3fc:	b3 83       	std	Z+3, r27	; 0x03
		
		if (ship.pos.x < 0.0) {
     3fe:	80 2f       	mov	r24, r16
     400:	91 2f       	mov	r25, r17
     402:	ae 2d       	mov	r26, r14
     404:	bf 2d       	mov	r27, r15
     406:	bc 01       	movw	r22, r24
     408:	cd 01       	movw	r24, r26
     40a:	20 e0       	ldi	r18, 0x00	; 0
     40c:	30 e0       	ldi	r19, 0x00	; 0
     40e:	a9 01       	movw	r20, r18
     410:	0e 94 43 1c 	call	0x3886	; 0x3886 <__cmpsf2>
     414:	88 23       	and	r24, r24
     416:	ac f4       	brge	.+42     	; 0x442 <updateTask+0x2b4>
			ship.pos.x += SCREEN_W;
     418:	80 2f       	mov	r24, r16
     41a:	91 2f       	mov	r25, r17
     41c:	ae 2d       	mov	r26, r14
     41e:	bf 2d       	mov	r27, r15
     420:	bc 01       	movw	r22, r24
     422:	cd 01       	movw	r24, r26
     424:	20 e0       	ldi	r18, 0x00	; 0
     426:	30 e0       	ldi	r19, 0x00	; 0
     428:	48 e4       	ldi	r20, 0x48	; 72
     42a:	54 e4       	ldi	r21, 0x44	; 68
     42c:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     430:	dc 01       	movw	r26, r24
     432:	cb 01       	movw	r24, r22
     434:	e9 e6       	ldi	r30, 0x69	; 105
     436:	f2 e0       	ldi	r31, 0x02	; 2
     438:	80 83       	st	Z, r24
     43a:	91 83       	std	Z+1, r25	; 0x01
     43c:	a2 83       	std	Z+2, r26	; 0x02
     43e:	b3 83       	std	Z+3, r27	; 0x03
     440:	22 c0       	rjmp	.+68     	; 0x486 <updateTask+0x2f8>
		} else if (ship.pos.x > SCREEN_W) {
     442:	80 2f       	mov	r24, r16
     444:	91 2f       	mov	r25, r17
     446:	ae 2d       	mov	r26, r14
     448:	bf 2d       	mov	r27, r15
     44a:	bc 01       	movw	r22, r24
     44c:	cd 01       	movw	r24, r26
     44e:	20 e0       	ldi	r18, 0x00	; 0
     450:	30 e0       	ldi	r19, 0x00	; 0
     452:	48 e4       	ldi	r20, 0x48	; 72
     454:	54 e4       	ldi	r21, 0x44	; 68
     456:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <__gesf2>
     45a:	18 16       	cp	r1, r24
     45c:	a4 f4       	brge	.+40     	; 0x486 <updateTask+0x2f8>
			ship.pos.x -= SCREEN_W;
     45e:	80 2f       	mov	r24, r16
     460:	91 2f       	mov	r25, r17
     462:	ae 2d       	mov	r26, r14
     464:	bf 2d       	mov	r27, r15
     466:	bc 01       	movw	r22, r24
     468:	cd 01       	movw	r24, r26
     46a:	20 e0       	ldi	r18, 0x00	; 0
     46c:	30 e0       	ldi	r19, 0x00	; 0
     46e:	48 e4       	ldi	r20, 0x48	; 72
     470:	54 e4       	ldi	r21, 0x44	; 68
     472:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
     476:	dc 01       	movw	r26, r24
     478:	cb 01       	movw	r24, r22
     47a:	e9 e6       	ldi	r30, 0x69	; 105
     47c:	f2 e0       	ldi	r31, 0x02	; 2
     47e:	80 83       	st	Z, r24
     480:	91 83       	std	Z+1, r25	; 0x01
     482:	a2 83       	std	Z+2, r26	; 0x02
     484:	b3 83       	std	Z+3, r27	; 0x03
		}
		if (ship.pos.y < 0.0) {
     486:	ed e6       	ldi	r30, 0x6D	; 109
     488:	f2 e0       	ldi	r31, 0x02	; 2
     48a:	c0 80       	ld	r12, Z
     48c:	d1 80       	ldd	r13, Z+1	; 0x01
     48e:	e2 80       	ldd	r14, Z+2	; 0x02
     490:	f3 80       	ldd	r15, Z+3	; 0x03
     492:	c7 01       	movw	r24, r14
     494:	b6 01       	movw	r22, r12
     496:	20 e0       	ldi	r18, 0x00	; 0
     498:	30 e0       	ldi	r19, 0x00	; 0
     49a:	a9 01       	movw	r20, r18
     49c:	0e 94 43 1c 	call	0x3886	; 0x3886 <__cmpsf2>
     4a0:	88 23       	and	r24, r24
     4a2:	8c f4       	brge	.+34     	; 0x4c6 <updateTask+0x338>
			ship.pos.y += SCREEN_H;
     4a4:	c7 01       	movw	r24, r14
     4a6:	b6 01       	movw	r22, r12
     4a8:	20 e0       	ldi	r18, 0x00	; 0
     4aa:	30 e0       	ldi	r19, 0x00	; 0
     4ac:	46 e1       	ldi	r20, 0x16	; 22
     4ae:	54 e4       	ldi	r21, 0x44	; 68
     4b0:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     4b4:	dc 01       	movw	r26, r24
     4b6:	cb 01       	movw	r24, r22
     4b8:	ed e6       	ldi	r30, 0x6D	; 109
     4ba:	f2 e0       	ldi	r31, 0x02	; 2
     4bc:	80 83       	st	Z, r24
     4be:	91 83       	std	Z+1, r25	; 0x01
     4c0:	a2 83       	std	Z+2, r26	; 0x02
     4c2:	b3 83       	std	Z+3, r27	; 0x03
     4c4:	1a c0       	rjmp	.+52     	; 0x4fa <updateTask+0x36c>
		} else if (ship.pos.y > SCREEN_H) {
     4c6:	c7 01       	movw	r24, r14
     4c8:	b6 01       	movw	r22, r12
     4ca:	20 e0       	ldi	r18, 0x00	; 0
     4cc:	30 e0       	ldi	r19, 0x00	; 0
     4ce:	46 e1       	ldi	r20, 0x16	; 22
     4d0:	54 e4       	ldi	r21, 0x44	; 68
     4d2:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <__gesf2>
     4d6:	18 16       	cp	r1, r24
     4d8:	84 f4       	brge	.+32     	; 0x4fa <updateTask+0x36c>
			ship.pos.y -= SCREEN_H;
     4da:	c7 01       	movw	r24, r14
     4dc:	b6 01       	movw	r22, r12
     4de:	20 e0       	ldi	r18, 0x00	; 0
     4e0:	30 e0       	ldi	r19, 0x00	; 0
     4e2:	46 e1       	ldi	r20, 0x16	; 22
     4e4:	54 e4       	ldi	r21, 0x44	; 68
     4e6:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
     4ea:	dc 01       	movw	r26, r24
     4ec:	cb 01       	movw	r24, r22
     4ee:	ed e6       	ldi	r30, 0x6D	; 109
     4f0:	f2 e0       	ldi	r31, 0x02	; 2
     4f2:	80 83       	st	Z, r24
     4f4:	91 83       	std	Z+1, r25	; 0x01
     4f6:	a2 83       	std	Z+2, r26	; 0x02
     4f8:	b3 83       	std	Z+3, r27	; 0x03
		}
		// move bullets
		objPrev = NULL;
		objIter = bullets;
     4fa:	80 90 87 02 	lds	r8, 0x0287
     4fe:	90 90 88 02 	lds	r9, 0x0288
		while (objIter != NULL) {
     502:	81 14       	cp	r8, r1
     504:	91 04       	cpc	r9, r1
     506:	09 f4       	brne	.+2      	; 0x50a <updateTask+0x37c>
     508:	f1 c0       	rjmp	.+482    	; 0x6ec <updateTask+0x55e>
			ship.pos.y += SCREEN_H;
		} else if (ship.pos.y > SCREEN_H) {
			ship.pos.y -= SCREEN_H;
		}
		// move bullets
		objPrev = NULL;
     50a:	00 e0       	ldi	r16, 0x00	; 0
     50c:	10 e0       	ldi	r17, 0x00	; 0
		objIter = bullets;
		while (objIter != NULL) {
			// Kill bullet after a while
			objIter->life += FRAME_DELAY_MS;
     50e:	f4 01       	movw	r30, r8
     510:	81 8d       	ldd	r24, Z+25	; 0x19
     512:	92 8d       	ldd	r25, Z+26	; 0x1a
     514:	0a 96       	adiw	r24, 0x0a	; 10
     516:	92 8f       	std	Z+26, r25	; 0x1a
     518:	81 8f       	std	Z+25, r24	; 0x19
			if (objIter->life >= BULLET_LIFE_MS) {
     51a:	f3 e0       	ldi	r31, 0x03	; 3
     51c:	88 3e       	cpi	r24, 0xE8	; 232
     51e:	9f 07       	cpc	r25, r31
     520:	c8 f1       	brcs	.+114    	; 0x594 <updateTask+0x406>
				xSemaphoreTake(usartMutex, portMAX_DELAY);
     522:	80 91 85 02 	lds	r24, 0x0285
     526:	90 91 86 02 	lds	r25, 0x0286
     52a:	60 e0       	ldi	r22, 0x00	; 0
     52c:	70 e0       	ldi	r23, 0x00	; 0
     52e:	4f ef       	ldi	r20, 0xFF	; 255
     530:	5f ef       	ldi	r21, 0xFF	; 255
     532:	20 e0       	ldi	r18, 0x00	; 0
     534:	0e 94 28 14 	call	0x2850	; 0x2850 <xQueueGenericReceive>
				vSpriteDelete(objIter->handle);
     538:	f4 01       	movw	r30, r8
     53a:	80 81       	ld	r24, Z
     53c:	0e 94 46 0c 	call	0x188c	; 0x188c <vSpriteDelete>
				if (objPrev != NULL) {
     540:	01 15       	cp	r16, r1
     542:	11 05       	cpc	r17, r1
     544:	69 f0       	breq	.+26     	; 0x560 <updateTask+0x3d2>
					objPrev->next = objIter->next;
     546:	f4 01       	movw	r30, r8
     548:	83 8d       	ldd	r24, Z+27	; 0x1b
     54a:	94 8d       	ldd	r25, Z+28	; 0x1c
     54c:	f8 01       	movw	r30, r16
     54e:	94 8f       	std	Z+28, r25	; 0x1c
     550:	83 8f       	std	Z+27, r24	; 0x1b
					vPortFree(objIter);
     552:	c4 01       	movw	r24, r8
     554:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
					objIter = objPrev->next;
     558:	f8 01       	movw	r30, r16
     55a:	83 8c       	ldd	r8, Z+27	; 0x1b
     55c:	94 8c       	ldd	r9, Z+28	; 0x1c
     55e:	0e c0       	rjmp	.+28     	; 0x57c <updateTask+0x3ee>
				} else {
					bullets = objIter->next;
     560:	f4 01       	movw	r30, r8
     562:	83 8d       	ldd	r24, Z+27	; 0x1b
     564:	94 8d       	ldd	r25, Z+28	; 0x1c
     566:	90 93 88 02 	sts	0x0288, r25
     56a:	80 93 87 02 	sts	0x0287, r24
					vPortFree(objIter);
     56e:	c4 01       	movw	r24, r8
     570:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
					objIter = bullets;
     574:	80 90 87 02 	lds	r8, 0x0287
     578:	90 90 88 02 	lds	r9, 0x0288
				}
				xSemaphoreGive(usartMutex);
     57c:	80 91 85 02 	lds	r24, 0x0285
     580:	90 91 86 02 	lds	r25, 0x0286
     584:	60 e0       	ldi	r22, 0x00	; 0
     586:	70 e0       	ldi	r23, 0x00	; 0
     588:	40 e0       	ldi	r20, 0x00	; 0
     58a:	50 e0       	ldi	r21, 0x00	; 0
     58c:	20 e0       	ldi	r18, 0x00	; 0
     58e:	0e 94 2b 13 	call	0x2656	; 0x2656 <xQueueGenericSend>
     592:	a8 c0       	rjmp	.+336    	; 0x6e4 <updateTask+0x556>
			} else {
            objIter->pos.x += objIter->vel.x;
     594:	f4 01       	movw	r30, r8
     596:	61 81       	ldd	r22, Z+1	; 0x01
     598:	72 81       	ldd	r23, Z+2	; 0x02
     59a:	83 81       	ldd	r24, Z+3	; 0x03
     59c:	94 81       	ldd	r25, Z+4	; 0x04
     59e:	21 85       	ldd	r18, Z+9	; 0x09
     5a0:	32 85       	ldd	r19, Z+10	; 0x0a
     5a2:	43 85       	ldd	r20, Z+11	; 0x0b
     5a4:	54 85       	ldd	r21, Z+12	; 0x0c
     5a6:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     5aa:	16 2f       	mov	r17, r22
     5ac:	07 2f       	mov	r16, r23
     5ae:	f8 2e       	mov	r15, r24
     5b0:	e9 2e       	mov	r14, r25
     5b2:	86 2f       	mov	r24, r22
     5b4:	90 2f       	mov	r25, r16
     5b6:	af 2d       	mov	r26, r15
     5b8:	be 2d       	mov	r27, r14
     5ba:	f4 01       	movw	r30, r8
     5bc:	81 83       	std	Z+1, r24	; 0x01
     5be:	92 83       	std	Z+2, r25	; 0x02
     5c0:	a3 83       	std	Z+3, r26	; 0x03
     5c2:	b4 83       	std	Z+4, r27	; 0x04
            objIter->pos.y += objIter->vel.y;
     5c4:	65 81       	ldd	r22, Z+5	; 0x05
     5c6:	76 81       	ldd	r23, Z+6	; 0x06
     5c8:	87 81       	ldd	r24, Z+7	; 0x07
     5ca:	90 85       	ldd	r25, Z+8	; 0x08
     5cc:	25 85       	ldd	r18, Z+13	; 0x0d
     5ce:	36 85       	ldd	r19, Z+14	; 0x0e
     5d0:	47 85       	ldd	r20, Z+15	; 0x0f
     5d2:	50 89       	ldd	r21, Z+16	; 0x10
     5d4:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     5d8:	dc 01       	movw	r26, r24
     5da:	cb 01       	movw	r24, r22
     5dc:	f4 01       	movw	r30, r8
     5de:	85 83       	std	Z+5, r24	; 0x05
     5e0:	96 83       	std	Z+6, r25	; 0x06
     5e2:	a7 83       	std	Z+7, r26	; 0x07
     5e4:	b0 87       	std	Z+8, r27	; 0x08

            if (objIter->pos.x < 0.0) {
     5e6:	81 2f       	mov	r24, r17
     5e8:	90 2f       	mov	r25, r16
     5ea:	af 2d       	mov	r26, r15
     5ec:	be 2d       	mov	r27, r14
     5ee:	bc 01       	movw	r22, r24
     5f0:	cd 01       	movw	r24, r26
     5f2:	20 e0       	ldi	r18, 0x00	; 0
     5f4:	30 e0       	ldi	r19, 0x00	; 0
     5f6:	a9 01       	movw	r20, r18
     5f8:	0e 94 43 1c 	call	0x3886	; 0x3886 <__cmpsf2>
     5fc:	88 23       	and	r24, r24
     5fe:	a4 f4       	brge	.+40     	; 0x628 <updateTask+0x49a>
             objIter->pos.x += SCREEN_W;
     600:	81 2f       	mov	r24, r17
     602:	90 2f       	mov	r25, r16
     604:	af 2d       	mov	r26, r15
     606:	be 2d       	mov	r27, r14
     608:	bc 01       	movw	r22, r24
     60a:	cd 01       	movw	r24, r26
     60c:	20 e0       	ldi	r18, 0x00	; 0
     60e:	30 e0       	ldi	r19, 0x00	; 0
     610:	48 e4       	ldi	r20, 0x48	; 72
     612:	54 e4       	ldi	r21, 0x44	; 68
     614:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     618:	dc 01       	movw	r26, r24
     61a:	cb 01       	movw	r24, r22
     61c:	f4 01       	movw	r30, r8
     61e:	81 83       	std	Z+1, r24	; 0x01
     620:	92 83       	std	Z+2, r25	; 0x02
     622:	a3 83       	std	Z+3, r26	; 0x03
     624:	b4 83       	std	Z+4, r27	; 0x04
     626:	21 c0       	rjmp	.+66     	; 0x66a <updateTask+0x4dc>
            } else if (objIter->pos.x > SCREEN_W) {
     628:	81 2f       	mov	r24, r17
     62a:	90 2f       	mov	r25, r16
     62c:	af 2d       	mov	r26, r15
     62e:	be 2d       	mov	r27, r14
     630:	bc 01       	movw	r22, r24
     632:	cd 01       	movw	r24, r26
     634:	20 e0       	ldi	r18, 0x00	; 0
     636:	30 e0       	ldi	r19, 0x00	; 0
     638:	48 e4       	ldi	r20, 0x48	; 72
     63a:	54 e4       	ldi	r21, 0x44	; 68
     63c:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <__gesf2>
     640:	18 16       	cp	r1, r24
     642:	9c f4       	brge	.+38     	; 0x66a <updateTask+0x4dc>
             objIter->pos.x -= SCREEN_W;
     644:	81 2f       	mov	r24, r17
     646:	90 2f       	mov	r25, r16
     648:	af 2d       	mov	r26, r15
     64a:	be 2d       	mov	r27, r14
     64c:	bc 01       	movw	r22, r24
     64e:	cd 01       	movw	r24, r26
     650:	20 e0       	ldi	r18, 0x00	; 0
     652:	30 e0       	ldi	r19, 0x00	; 0
     654:	48 e4       	ldi	r20, 0x48	; 72
     656:	54 e4       	ldi	r21, 0x44	; 68
     658:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
     65c:	dc 01       	movw	r26, r24
     65e:	cb 01       	movw	r24, r22
     660:	f4 01       	movw	r30, r8
     662:	81 83       	std	Z+1, r24	; 0x01
     664:	92 83       	std	Z+2, r25	; 0x02
     666:	a3 83       	std	Z+3, r26	; 0x03
     668:	b4 83       	std	Z+4, r27	; 0x04
            }

            if (objIter->pos.y < 0.0) {
     66a:	f4 01       	movw	r30, r8
     66c:	c5 80       	ldd	r12, Z+5	; 0x05
     66e:	d6 80       	ldd	r13, Z+6	; 0x06
     670:	e7 80       	ldd	r14, Z+7	; 0x07
     672:	f0 84       	ldd	r15, Z+8	; 0x08
     674:	c7 01       	movw	r24, r14
     676:	b6 01       	movw	r22, r12
     678:	20 e0       	ldi	r18, 0x00	; 0
     67a:	30 e0       	ldi	r19, 0x00	; 0
     67c:	a9 01       	movw	r20, r18
     67e:	0e 94 43 1c 	call	0x3886	; 0x3886 <__cmpsf2>
     682:	88 23       	and	r24, r24
     684:	84 f4       	brge	.+32     	; 0x6a6 <updateTask+0x518>
             objIter->pos.y += SCREEN_H;
     686:	c7 01       	movw	r24, r14
     688:	b6 01       	movw	r22, r12
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	30 e0       	ldi	r19, 0x00	; 0
     68e:	46 e1       	ldi	r20, 0x16	; 22
     690:	54 e4       	ldi	r21, 0x44	; 68
     692:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     696:	dc 01       	movw	r26, r24
     698:	cb 01       	movw	r24, r22
     69a:	f4 01       	movw	r30, r8
     69c:	85 83       	std	Z+5, r24	; 0x05
     69e:	96 83       	std	Z+6, r25	; 0x06
     6a0:	a7 83       	std	Z+7, r26	; 0x07
     6a2:	b0 87       	std	Z+8, r27	; 0x08
     6a4:	19 c0       	rjmp	.+50     	; 0x6d8 <updateTask+0x54a>
            } else if (objIter->pos.y > SCREEN_H) {
     6a6:	c7 01       	movw	r24, r14
     6a8:	b6 01       	movw	r22, r12
     6aa:	20 e0       	ldi	r18, 0x00	; 0
     6ac:	30 e0       	ldi	r19, 0x00	; 0
     6ae:	46 e1       	ldi	r20, 0x16	; 22
     6b0:	54 e4       	ldi	r21, 0x44	; 68
     6b2:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <__gesf2>
     6b6:	18 16       	cp	r1, r24
     6b8:	7c f4       	brge	.+30     	; 0x6d8 <updateTask+0x54a>
             objIter->pos.y -= SCREEN_H;
     6ba:	c7 01       	movw	r24, r14
     6bc:	b6 01       	movw	r22, r12
     6be:	20 e0       	ldi	r18, 0x00	; 0
     6c0:	30 e0       	ldi	r19, 0x00	; 0
     6c2:	46 e1       	ldi	r20, 0x16	; 22
     6c4:	54 e4       	ldi	r21, 0x44	; 68
     6c6:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
     6ca:	dc 01       	movw	r26, r24
     6cc:	cb 01       	movw	r24, r22
     6ce:	f4 01       	movw	r30, r8
     6d0:	85 83       	std	Z+5, r24	; 0x05
     6d2:	96 83       	std	Z+6, r25	; 0x06
     6d4:	a7 83       	std	Z+7, r26	; 0x07
     6d6:	b0 87       	std	Z+8, r27	; 0x08
            }
            objPrev = objIter;
            objIter = objIter->next;
     6d8:	f4 01       	movw	r30, r8
     6da:	93 8d       	ldd	r25, Z+27	; 0x1b
     6dc:	84 8d       	ldd	r24, Z+28	; 0x1c
     6de:	84 01       	movw	r16, r8
     6e0:	89 2e       	mov	r8, r25
     6e2:	98 2e       	mov	r9, r24
			ship.pos.y -= SCREEN_H;
		}
		// move bullets
		objPrev = NULL;
		objIter = bullets;
		while (objIter != NULL) {
     6e4:	81 14       	cp	r8, r1
     6e6:	91 04       	cpc	r9, r1
     6e8:	09 f0       	breq	.+2      	; 0x6ec <updateTask+0x55e>
     6ea:	11 cf       	rjmp	.-478    	; 0x50e <updateTask+0x380>
			}			
		}
		
		// move asteroids
		objPrev = NULL;
		objIter = asteroids;
     6ec:	80 90 89 02 	lds	r8, 0x0289
     6f0:	90 90 8a 02 	lds	r9, 0x028A
		while (objIter != NULL) {
     6f4:	81 14       	cp	r8, r1
     6f6:	91 04       	cpc	r9, r1
     6f8:	09 f4       	brne	.+2      	; 0x6fc <updateTask+0x56e>
     6fa:	a9 c0       	rjmp	.+338    	; 0x84e <updateTask+0x6c0>
			objIter->pos.x += objIter->vel.x;
     6fc:	f4 01       	movw	r30, r8
     6fe:	61 81       	ldd	r22, Z+1	; 0x01
     700:	72 81       	ldd	r23, Z+2	; 0x02
     702:	83 81       	ldd	r24, Z+3	; 0x03
     704:	94 81       	ldd	r25, Z+4	; 0x04
     706:	21 85       	ldd	r18, Z+9	; 0x09
     708:	32 85       	ldd	r19, Z+10	; 0x0a
     70a:	43 85       	ldd	r20, Z+11	; 0x0b
     70c:	54 85       	ldd	r21, Z+12	; 0x0c
     70e:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     712:	16 2f       	mov	r17, r22
     714:	07 2f       	mov	r16, r23
     716:	f8 2e       	mov	r15, r24
     718:	e9 2e       	mov	r14, r25
     71a:	86 2f       	mov	r24, r22
     71c:	90 2f       	mov	r25, r16
     71e:	af 2d       	mov	r26, r15
     720:	be 2d       	mov	r27, r14
     722:	f4 01       	movw	r30, r8
     724:	81 83       	std	Z+1, r24	; 0x01
     726:	92 83       	std	Z+2, r25	; 0x02
     728:	a3 83       	std	Z+3, r26	; 0x03
     72a:	b4 83       	std	Z+4, r27	; 0x04
			objIter->pos.y += objIter->vel.y;
     72c:	65 81       	ldd	r22, Z+5	; 0x05
     72e:	76 81       	ldd	r23, Z+6	; 0x06
     730:	87 81       	ldd	r24, Z+7	; 0x07
     732:	90 85       	ldd	r25, Z+8	; 0x08
     734:	25 85       	ldd	r18, Z+13	; 0x0d
     736:	36 85       	ldd	r19, Z+14	; 0x0e
     738:	47 85       	ldd	r20, Z+15	; 0x0f
     73a:	50 89       	ldd	r21, Z+16	; 0x10
     73c:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     740:	dc 01       	movw	r26, r24
     742:	cb 01       	movw	r24, r22
     744:	f4 01       	movw	r30, r8
     746:	85 83       	std	Z+5, r24	; 0x05
     748:	96 83       	std	Z+6, r25	; 0x06
     74a:	a7 83       	std	Z+7, r26	; 0x07
     74c:	b0 87       	std	Z+8, r27	; 0x08
      
			if (objIter->pos.x < 0.0) {
     74e:	81 2f       	mov	r24, r17
     750:	90 2f       	mov	r25, r16
     752:	af 2d       	mov	r26, r15
     754:	be 2d       	mov	r27, r14
     756:	bc 01       	movw	r22, r24
     758:	cd 01       	movw	r24, r26
     75a:	20 e0       	ldi	r18, 0x00	; 0
     75c:	30 e0       	ldi	r19, 0x00	; 0
     75e:	a9 01       	movw	r20, r18
     760:	0e 94 43 1c 	call	0x3886	; 0x3886 <__cmpsf2>
     764:	88 23       	and	r24, r24
     766:	a4 f4       	brge	.+40     	; 0x790 <updateTask+0x602>
				objIter->pos.x += SCREEN_W;
     768:	81 2f       	mov	r24, r17
     76a:	90 2f       	mov	r25, r16
     76c:	af 2d       	mov	r26, r15
     76e:	be 2d       	mov	r27, r14
     770:	bc 01       	movw	r22, r24
     772:	cd 01       	movw	r24, r26
     774:	20 e0       	ldi	r18, 0x00	; 0
     776:	30 e0       	ldi	r19, 0x00	; 0
     778:	48 e4       	ldi	r20, 0x48	; 72
     77a:	54 e4       	ldi	r21, 0x44	; 68
     77c:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     780:	dc 01       	movw	r26, r24
     782:	cb 01       	movw	r24, r22
     784:	f4 01       	movw	r30, r8
     786:	81 83       	std	Z+1, r24	; 0x01
     788:	92 83       	std	Z+2, r25	; 0x02
     78a:	a3 83       	std	Z+3, r26	; 0x03
     78c:	b4 83       	std	Z+4, r27	; 0x04
     78e:	21 c0       	rjmp	.+66     	; 0x7d2 <updateTask+0x644>
			} else if (objIter->pos.x > SCREEN_W) {
     790:	81 2f       	mov	r24, r17
     792:	90 2f       	mov	r25, r16
     794:	af 2d       	mov	r26, r15
     796:	be 2d       	mov	r27, r14
     798:	bc 01       	movw	r22, r24
     79a:	cd 01       	movw	r24, r26
     79c:	20 e0       	ldi	r18, 0x00	; 0
     79e:	30 e0       	ldi	r19, 0x00	; 0
     7a0:	48 e4       	ldi	r20, 0x48	; 72
     7a2:	54 e4       	ldi	r21, 0x44	; 68
     7a4:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <__gesf2>
     7a8:	18 16       	cp	r1, r24
     7aa:	9c f4       	brge	.+38     	; 0x7d2 <updateTask+0x644>
				objIter->pos.x -= SCREEN_W;
     7ac:	81 2f       	mov	r24, r17
     7ae:	90 2f       	mov	r25, r16
     7b0:	af 2d       	mov	r26, r15
     7b2:	be 2d       	mov	r27, r14
     7b4:	bc 01       	movw	r22, r24
     7b6:	cd 01       	movw	r24, r26
     7b8:	20 e0       	ldi	r18, 0x00	; 0
     7ba:	30 e0       	ldi	r19, 0x00	; 0
     7bc:	48 e4       	ldi	r20, 0x48	; 72
     7be:	54 e4       	ldi	r21, 0x44	; 68
     7c0:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
     7c4:	dc 01       	movw	r26, r24
     7c6:	cb 01       	movw	r24, r22
     7c8:	f4 01       	movw	r30, r8
     7ca:	81 83       	std	Z+1, r24	; 0x01
     7cc:	92 83       	std	Z+2, r25	; 0x02
     7ce:	a3 83       	std	Z+3, r26	; 0x03
     7d0:	b4 83       	std	Z+4, r27	; 0x04
			}
      
			if (objIter->pos.y < 0.0) {
     7d2:	f4 01       	movw	r30, r8
     7d4:	c5 80       	ldd	r12, Z+5	; 0x05
     7d6:	d6 80       	ldd	r13, Z+6	; 0x06
     7d8:	e7 80       	ldd	r14, Z+7	; 0x07
     7da:	f0 84       	ldd	r15, Z+8	; 0x08
     7dc:	c7 01       	movw	r24, r14
     7de:	b6 01       	movw	r22, r12
     7e0:	20 e0       	ldi	r18, 0x00	; 0
     7e2:	30 e0       	ldi	r19, 0x00	; 0
     7e4:	a9 01       	movw	r20, r18
     7e6:	0e 94 43 1c 	call	0x3886	; 0x3886 <__cmpsf2>
     7ea:	88 23       	and	r24, r24
     7ec:	84 f4       	brge	.+32     	; 0x80e <updateTask+0x680>
				objIter->pos.y += SCREEN_H;
     7ee:	c7 01       	movw	r24, r14
     7f0:	b6 01       	movw	r22, r12
     7f2:	20 e0       	ldi	r18, 0x00	; 0
     7f4:	30 e0       	ldi	r19, 0x00	; 0
     7f6:	46 e1       	ldi	r20, 0x16	; 22
     7f8:	54 e4       	ldi	r21, 0x44	; 68
     7fa:	0e 94 df 1b 	call	0x37be	; 0x37be <__addsf3>
     7fe:	dc 01       	movw	r26, r24
     800:	cb 01       	movw	r24, r22
     802:	f4 01       	movw	r30, r8
     804:	85 83       	std	Z+5, r24	; 0x05
     806:	96 83       	std	Z+6, r25	; 0x06
     808:	a7 83       	std	Z+7, r26	; 0x07
     80a:	b0 87       	std	Z+8, r27	; 0x08
     80c:	19 c0       	rjmp	.+50     	; 0x840 <updateTask+0x6b2>
			} else if (objIter->pos.y > SCREEN_H) {
     80e:	c7 01       	movw	r24, r14
     810:	b6 01       	movw	r22, r12
     812:	20 e0       	ldi	r18, 0x00	; 0
     814:	30 e0       	ldi	r19, 0x00	; 0
     816:	46 e1       	ldi	r20, 0x16	; 22
     818:	54 e4       	ldi	r21, 0x44	; 68
     81a:	0e 94 ce 1d 	call	0x3b9c	; 0x3b9c <__gesf2>
     81e:	18 16       	cp	r1, r24
     820:	7c f4       	brge	.+30     	; 0x840 <updateTask+0x6b2>
				objIter->pos.y -= SCREEN_H;
     822:	c7 01       	movw	r24, r14
     824:	b6 01       	movw	r22, r12
     826:	20 e0       	ldi	r18, 0x00	; 0
     828:	30 e0       	ldi	r19, 0x00	; 0
     82a:	46 e1       	ldi	r20, 0x16	; 22
     82c:	54 e4       	ldi	r21, 0x44	; 68
     82e:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
     832:	dc 01       	movw	r26, r24
     834:	cb 01       	movw	r24, r22
     836:	f4 01       	movw	r30, r8
     838:	85 83       	std	Z+5, r24	; 0x05
     83a:	96 83       	std	Z+6, r25	; 0x06
     83c:	a7 83       	std	Z+7, r26	; 0x07
     83e:	b0 87       	std	Z+8, r27	; 0x08
			}
      
			objPrev = objIter;
			objIter = objIter->next;
     840:	f4 01       	movw	r30, r8
     842:	83 8c       	ldd	r8, Z+27	; 0x1b
     844:	94 8c       	ldd	r9, Z+28	; 0x1c
		}
		
		// move asteroids
		objPrev = NULL;
		objIter = asteroids;
		while (objIter != NULL) {
     846:	81 14       	cp	r8, r1
     848:	91 04       	cpc	r9, r1
     84a:	09 f0       	breq	.+2      	; 0x84e <updateTask+0x6c0>
     84c:	57 cf       	rjmp	.-338    	; 0x6fc <updateTask+0x56e>
			}
      
			objPrev = objIter;
			objIter = objIter->next;
		}
		vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
     84e:	8a e0       	ldi	r24, 0x0A	; 10
     850:	90 e0       	ldi	r25, 0x00	; 0
     852:	0e 94 e3 18 	call	0x31c6	; 0x31c6 <vTaskDelay>
	}
     856:	a6 cc       	rjmp	.-1716   	; 0x1a4 <updateTask+0x16>

00000858 <main>:
		vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
	}
}

int main(void) {
	DDRB = 0x00;
     858:	14 b8       	out	0x04, r1	; 4
	TCCR2A = _BV(CS00); 
     85a:	81 e0       	ldi	r24, 0x01	; 1
     85c:	80 93 b0 00 	sts	0x00B0, r24
	
	usartMutex = xSemaphoreCreateMutex();
     860:	0e 94 c9 13 	call	0x2792	; 0x2792 <xQueueCreateMutex>
     864:	90 93 86 02 	sts	0x0286, r25
     868:	80 93 85 02 	sts	0x0285, r24
	
	vWindowCreate(SCREEN_W, SCREEN_H);
     86c:	80 e2       	ldi	r24, 0x20	; 32
     86e:	93 e0       	ldi	r25, 0x03	; 3
     870:	68 e5       	ldi	r22, 0x58	; 88
     872:	72 e0       	ldi	r23, 0x02	; 2
     874:	0e 94 5b 0b 	call	0x16b6	; 0x16b6 <vWindowCreate>
	
	sei();
     878:	78 94       	sei
	
	xTaskCreate(inputTask, (signed char *) "i", 80, NULL, 1, &inputTaskHandle);
     87a:	85 ea       	ldi	r24, 0xA5	; 165
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	60 e0       	ldi	r22, 0x00	; 0
     880:	72 e0       	ldi	r23, 0x02	; 2
     882:	40 e5       	ldi	r20, 0x50	; 80
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	20 e0       	ldi	r18, 0x00	; 0
     888:	30 e0       	ldi	r19, 0x00	; 0
     88a:	01 e0       	ldi	r16, 0x01	; 1
     88c:	0f 2e       	mov	r0, r31
     88e:	ff e8       	ldi	r31, 0x8F	; 143
     890:	ef 2e       	mov	r14, r31
     892:	f2 e0       	ldi	r31, 0x02	; 2
     894:	ff 2e       	mov	r15, r31
     896:	f0 2d       	mov	r31, r0
     898:	cc 24       	eor	r12, r12
     89a:	dd 24       	eor	r13, r13
     89c:	aa 24       	eor	r10, r10
     89e:	bb 24       	eor	r11, r11
     8a0:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskGenericCreate>
	xTaskCreate(bulletTask, (signed char *) "b", 250, NULL, 2, &bulletTaskHandle);
     8a4:	85 e9       	ldi	r24, 0x95	; 149
     8a6:	97 e0       	ldi	r25, 0x07	; 7
     8a8:	62 e0       	ldi	r22, 0x02	; 2
     8aa:	72 e0       	ldi	r23, 0x02	; 2
     8ac:	4a ef       	ldi	r20, 0xFA	; 250
     8ae:	50 e0       	ldi	r21, 0x00	; 0
     8b0:	20 e0       	ldi	r18, 0x00	; 0
     8b2:	30 e0       	ldi	r19, 0x00	; 0
     8b4:	02 e0       	ldi	r16, 0x02	; 2
     8b6:	0f 2e       	mov	r0, r31
     8b8:	fd e8       	ldi	r31, 0x8D	; 141
     8ba:	ef 2e       	mov	r14, r31
     8bc:	f2 e0       	ldi	r31, 0x02	; 2
     8be:	ff 2e       	mov	r15, r31
     8c0:	f0 2d       	mov	r31, r0
     8c2:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskGenericCreate>
	xTaskCreate(updateTask, (signed char *) "u", 200, NULL, 4, &updateTaskHandle);
     8c6:	87 ec       	ldi	r24, 0xC7	; 199
     8c8:	90 e0       	ldi	r25, 0x00	; 0
     8ca:	64 e0       	ldi	r22, 0x04	; 4
     8cc:	72 e0       	ldi	r23, 0x02	; 2
     8ce:	48 ec       	ldi	r20, 0xC8	; 200
     8d0:	50 e0       	ldi	r21, 0x00	; 0
     8d2:	20 e0       	ldi	r18, 0x00	; 0
     8d4:	30 e0       	ldi	r19, 0x00	; 0
     8d6:	04 e0       	ldi	r16, 0x04	; 4
     8d8:	0f 2e       	mov	r0, r31
     8da:	fb e8       	ldi	r31, 0x8B	; 139
     8dc:	ef 2e       	mov	r14, r31
     8de:	f2 e0       	ldi	r31, 0x02	; 2
     8e0:	ff 2e       	mov	r15, r31
     8e2:	f0 2d       	mov	r31, r0
     8e4:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskGenericCreate>
	xTaskCreate(drawTask, (signed char *) "d", 1600, NULL, 3, NULL);
     8e8:	8b e7       	ldi	r24, 0x7B	; 123
     8ea:	99 e0       	ldi	r25, 0x09	; 9
     8ec:	66 e0       	ldi	r22, 0x06	; 6
     8ee:	72 e0       	ldi	r23, 0x02	; 2
     8f0:	40 e4       	ldi	r20, 0x40	; 64
     8f2:	56 e0       	ldi	r21, 0x06	; 6
     8f4:	20 e0       	ldi	r18, 0x00	; 0
     8f6:	30 e0       	ldi	r19, 0x00	; 0
     8f8:	03 e0       	ldi	r16, 0x03	; 3
     8fa:	ee 24       	eor	r14, r14
     8fc:	ff 24       	eor	r15, r15
     8fe:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskGenericCreate>
	xTaskCreate(USART_Write_Task, (signed char *) "w", 200, NULL, 5, NULL);
     902:	89 ec       	ldi	r24, 0xC9	; 201
     904:	9b e1       	ldi	r25, 0x1B	; 27
     906:	68 e0       	ldi	r22, 0x08	; 8
     908:	72 e0       	ldi	r23, 0x02	; 2
     90a:	48 ec       	ldi	r20, 0xC8	; 200
     90c:	50 e0       	ldi	r21, 0x00	; 0
     90e:	20 e0       	ldi	r18, 0x00	; 0
     910:	30 e0       	ldi	r19, 0x00	; 0
     912:	05 e0       	ldi	r16, 0x05	; 5
     914:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskGenericCreate>
	
	vTaskStartScheduler();
     918:	0e 94 44 17 	call	0x2e88	; 0x2e88 <vTaskStartScheduler>
     91c:	ff cf       	rjmp	.-2      	; 0x91c <main+0xc4>

0000091e <reset>:
 * Function: reset
 *
 * Description: This function destroys all game objects in the heap and clears
 *  their respective sprites from the window.
 *----------------------------------------------------------------------------*/
void reset(void) {
     91e:	cf 93       	push	r28
     920:	df 93       	push	r29
     *		thisObject = nextObject
     *	}
     */
	object *nextObject;
	// removes asteroids
	while (asteroids != NULL) {
     922:	c0 91 89 02 	lds	r28, 0x0289
     926:	d0 91 8a 02 	lds	r29, 0x028A
     92a:	20 97       	sbiw	r28, 0x00	; 0
     92c:	91 f0       	breq	.+36     	; 0x952 <reset+0x34>
      
		vSpriteDelete(asteroids->handle);
     92e:	88 81       	ld	r24, Y
     930:	0e 94 46 0c 	call	0x188c	; 0x188c <vSpriteDelete>
		nextObject = asteroids->next;
     934:	80 91 89 02 	lds	r24, 0x0289
     938:	90 91 8a 02 	lds	r25, 0x028A
     93c:	fc 01       	movw	r30, r24
     93e:	c3 8d       	ldd	r28, Z+27	; 0x1b
     940:	d4 8d       	ldd	r29, Z+28	; 0x1c
		vPortFree(asteroids);
     942:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
		asteroids = nextObject;
     946:	d0 93 8a 02 	sts	0x028A, r29
     94a:	c0 93 89 02 	sts	0x0289, r28
     *		thisObject = nextObject
     *	}
     */
	object *nextObject;
	// removes asteroids
	while (asteroids != NULL) {
     94e:	20 97       	sbiw	r28, 0x00	; 0
     950:	71 f7       	brne	.-36     	; 0x92e <reset+0x10>
		vSpriteDelete(asteroids->handle);
		nextObject = asteroids->next;
		vPortFree(asteroids);
		asteroids = nextObject;
	}
	vGroupDelete(astGroup);
     952:	80 91 91 02 	lds	r24, 0x0291
     956:	0e 94 76 0c 	call	0x18ec	; 0x18ec <vGroupDelete>
	
	// removes bullets
	while (bullets != NULL) {
     95a:	c0 91 87 02 	lds	r28, 0x0287
     95e:	d0 91 88 02 	lds	r29, 0x0288
     962:	20 97       	sbiw	r28, 0x00	; 0
     964:	91 f0       	breq	.+36     	; 0x98a <reset+0x6c>
   	vSpriteDelete(bullets->handle);
     966:	88 81       	ld	r24, Y
     968:	0e 94 46 0c 	call	0x188c	; 0x188c <vSpriteDelete>
   	nextObject = bullets->next;
     96c:	80 91 87 02 	lds	r24, 0x0287
     970:	90 91 88 02 	lds	r25, 0x0288
     974:	fc 01       	movw	r30, r24
     976:	c3 8d       	ldd	r28, Z+27	; 0x1b
     978:	d4 8d       	ldd	r29, Z+28	; 0x1c
   	vPortFree(bullets);
     97a:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
   	bullets = nextObject;
     97e:	d0 93 88 02 	sts	0x0288, r29
     982:	c0 93 87 02 	sts	0x0287, r28
		asteroids = nextObject;
	}
	vGroupDelete(astGroup);
	
	// removes bullets
	while (bullets != NULL) {
     986:	20 97       	sbiw	r28, 0x00	; 0
     988:	71 f7       	brne	.-36     	; 0x966 <reset+0x48>
   	nextObject = bullets->next;
   	vPortFree(bullets);
   	bullets = nextObject;
	}
   
   vSpriteDelete(ship.handle);
     98a:	80 91 68 02 	lds	r24, 0x0268
     98e:	0e 94 46 0c 	call	0x188c	; 0x188c <vSpriteDelete>
   vSpriteDelete(background);
     992:	80 91 92 02 	lds	r24, 0x0292
     996:	0e 94 46 0c 	call	0x188c	; 0x188c <vSpriteDelete>
}
     99a:	df 91       	pop	r29
     99c:	cf 91       	pop	r28
     99e:	08 95       	ret

000009a0 <getRandStartPosVal>:
 *
 * param dimOver2: Half of the dimension of the window for which a random
 *  coordinate value is desired.
 * return: A safe, pseudorandom coordinate value.
 *----------------------------------------------------------------------------*/
int16_t getRandStartPosVal(int16_t dimOver2) {
     9a0:	0f 93       	push	r16
     9a2:	1f 93       	push	r17
     9a4:	cf 93       	push	r28
     9a6:	df 93       	push	r29
     9a8:	ec 01       	movw	r28, r24
   return rand() % (dimOver2 - DEAD_ZONE_OVER_2) + (rand() % 2) * (dimOver2 + DEAD_ZONE_OVER_2);
     9aa:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
     9ae:	be 01       	movw	r22, r28
     9b0:	68 57       	subi	r22, 0x78	; 120
     9b2:	70 40       	sbci	r23, 0x00	; 0
     9b4:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
     9b8:	8c 01       	movw	r16, r24
     9ba:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
     9be:	62 e0       	ldi	r22, 0x02	; 2
     9c0:	70 e0       	ldi	r23, 0x00	; 0
     9c2:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
     9c6:	ac 01       	movw	r20, r24
     9c8:	9e 01       	movw	r18, r28
     9ca:	28 58       	subi	r18, 0x88	; 136
     9cc:	3f 4f       	sbci	r19, 0xFF	; 255
     9ce:	42 9f       	mul	r20, r18
     9d0:	c0 01       	movw	r24, r0
     9d2:	43 9f       	mul	r20, r19
     9d4:	90 0d       	add	r25, r0
     9d6:	52 9f       	mul	r21, r18
     9d8:	90 0d       	add	r25, r0
     9da:	11 24       	eor	r1, r1
     9dc:	80 0f       	add	r24, r16
     9de:	91 1f       	adc	r25, r17
}
     9e0:	df 91       	pop	r29
     9e2:	cf 91       	pop	r28
     9e4:	1f 91       	pop	r17
     9e6:	0f 91       	pop	r16
     9e8:	08 95       	ret

000009ea <sizeToPix>:
 * param size: A number in the range [1-3]
 * return: A pixel size which may be used to appropriately scale an asteroid
 *  sprite.
 *----------------------------------------------------------------------------*/
uint16_t sizeToPix(int8_t size) {
	switch (size) {
     9ea:	82 30       	cpi	r24, 0x02	; 2
     9ec:	71 f0       	breq	.+28     	; 0xa0a <sizeToPix+0x20>
     9ee:	83 30       	cpi	r24, 0x03	; 3
     9f0:	19 f0       	breq	.+6      	; 0x9f8 <sizeToPix+0xe>
     9f2:	81 30       	cpi	r24, 0x01	; 1
     9f4:	39 f4       	brne	.+14     	; 0xa04 <sizeToPix+0x1a>
     9f6:	03 c0       	rjmp	.+6      	; 0x9fe <sizeToPix+0x14>
		case 3:
		    return AST_SIZE_3;
     9f8:	84 e6       	ldi	r24, 0x64	; 100
     9fa:	90 e0       	ldi	r25, 0x00	; 0
     9fc:	08 95       	ret
		case 2:
		    return AST_SIZE_2;
		case 1:
		    return AST_SIZE_1;
     9fe:	8f e0       	ldi	r24, 0x0F	; 15
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	08 95       	ret
		default:
		    return AST_SIZE_3 << 2;
     a04:	80 e9       	ldi	r24, 0x90	; 144
     a06:	91 e0       	ldi	r25, 0x01	; 1
     a08:	08 95       	ret
uint16_t sizeToPix(int8_t size) {
	switch (size) {
		case 3:
		    return AST_SIZE_3;
		case 2:
		    return AST_SIZE_2;
     a0a:	88 e2       	ldi	r24, 0x28	; 40
     a0c:	90 e0       	ldi	r25, 0x00	; 0
		    return AST_SIZE_1;
		default:
		    return AST_SIZE_3 << 2;
	}
	return AST_SIZE_3 << 2;
}
     a0e:	08 95       	ret

00000a10 <createAsteroid>:
 * param size: The starting size of the asteroid. Must be in the range [1,3].
 * param nxt: A pointer to the next asteroid object in a linked list.
 * return: A pointer to a malloc'd asteroid object. Must be freed by the calling
 *  process.
 *----------------------------------------------------------------------------*/
object *createAsteroid(float x, float y, float velx, float vely, int16_t angle, int8_t avel, int8_t size, object *nxt) {
     a10:	2f 92       	push	r2
     a12:	3f 92       	push	r3
     a14:	4f 92       	push	r4
     a16:	5f 92       	push	r5
     a18:	6f 92       	push	r6
     a1a:	7f 92       	push	r7
     a1c:	8f 92       	push	r8
     a1e:	9f 92       	push	r9
     a20:	af 92       	push	r10
     a22:	bf 92       	push	r11
     a24:	cf 92       	push	r12
     a26:	df 92       	push	r13
     a28:	ef 92       	push	r14
     a2a:	ff 92       	push	r15
     a2c:	0f 93       	push	r16
     a2e:	1f 93       	push	r17
     a30:	cf 93       	push	r28
     a32:	df 93       	push	r29
     a34:	cd b7       	in	r28, 0x3d	; 61
     a36:	de b7       	in	r29, 0x3e	; 62
     a38:	60 97       	sbiw	r28, 0x10	; 16
     a3a:	0f b6       	in	r0, 0x3f	; 63
     a3c:	f8 94       	cli
     a3e:	de bf       	out	0x3e, r29	; 62
     a40:	0f be       	out	0x3f, r0	; 63
     a42:	cd bf       	out	0x3d, r28	; 61
     a44:	2b 01       	movw	r4, r22
     a46:	3c 01       	movw	r6, r24
     a48:	29 83       	std	Y+1, r18	; 0x01
     a4a:	3a 83       	std	Y+2, r19	; 0x02
     a4c:	4b 83       	std	Y+3, r20	; 0x03
     a4e:	5c 83       	std	Y+4, r21	; 0x04
     a50:	ed 82       	std	Y+5, r14	; 0x05
     a52:	fe 82       	std	Y+6, r15	; 0x06
     a54:	0f 83       	std	Y+7, r16	; 0x07
     a56:	18 87       	std	Y+8, r17	; 0x08
     a58:	a9 86       	std	Y+9, r10	; 0x09
     a5a:	ba 86       	std	Y+10, r11	; 0x0a
     a5c:	cb 86       	std	Y+11, r12	; 0x0b
     a5e:	dc 86       	std	Y+12, r13	; 0x0c
     a60:	df a0       	lds	r29, 0x8f
      //sprintf (debug, "velx = %d.%04d\n", d1, d2);
      //
      ////sprintf(debug, "velx: %d.%d, vely: %d.%d", (int)velx, ,vely);
      //vPrint(debug);
      
      object *newAsteroid = pvPortMalloc(sizeof(object));
     a62:	8d e1       	ldi	r24, 0x1D	; 29
     a64:	90 e0       	ldi	r25, 0x00	; 0
     a66:	0e 94 af 0c 	call	0x195e	; 0x195e <pvPortMalloc>
     a6a:	5c 01       	movw	r10, r24
      
      newAsteroid->handle = xSpriteCreate(
         astImages[rand() % 3],  //reference to png filename
     a6c:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
     a70:	8c 01       	movw	r16, r24
      ////sprintf(debug, "velx: %d.%d, vely: %d.%d", (int)velx, ,vely);
      //vPrint(debug);
      
      object *newAsteroid = pvPortMalloc(sizeof(object));
      
      newAsteroid->handle = xSpriteCreate(
     a72:	8d 2d       	mov	r24, r13
     a74:	0e 94 f5 04 	call	0x9ea	; 0x9ea <sizeToPix>
     a78:	7c 01       	movw	r14, r24
         astImages[rand() % 3],  //reference to png filename
     a7a:	c8 01       	movw	r24, r16
     a7c:	63 e0       	ldi	r22, 0x03	; 3
     a7e:	70 e0       	ldi	r23, 0x00	; 0
     a80:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
      ////sprintf(debug, "velx: %d.%d, vely: %d.%d", (int)velx, ,vely);
      //vPrint(debug);
      
      object *newAsteroid = pvPortMalloc(sizeof(object));
      
      newAsteroid->handle = xSpriteCreate(
     a84:	fc 01       	movw	r30, r24
     a86:	ee 0f       	add	r30, r30
     a88:	ff 1f       	adc	r31, r31
     a8a:	ec 5a       	subi	r30, 0xAC	; 172
     a8c:	fd 4f       	sbci	r31, 0xFD	; 253
     a8e:	20 80       	ld	r2, Z
     a90:	31 80       	ldd	r3, Z+1	; 0x01
     a92:	c3 01       	movw	r24, r6
     a94:	b2 01       	movw	r22, r4
     a96:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
     a9a:	6d 87       	std	Y+13, r22	; 0x0d
     a9c:	7e 87       	std	Y+14, r23	; 0x0e
     a9e:	8f 87       	std	Y+15, r24	; 0x0f
     aa0:	98 8b       	std	Y+16, r25	; 0x10
     aa2:	69 81       	ldd	r22, Y+1	; 0x01
     aa4:	7a 81       	ldd	r23, Y+2	; 0x02
     aa6:	8b 81       	ldd	r24, Y+3	; 0x03
     aa8:	9c 81       	ldd	r25, Y+4	; 0x04
     aaa:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
     aae:	8b 01       	movw	r16, r22
     ab0:	9c 01       	movw	r18, r24
     ab2:	c1 01       	movw	r24, r2
     ab4:	6d 85       	ldd	r22, Y+13	; 0x0d
     ab6:	7e 85       	ldd	r23, Y+14	; 0x0e
     ab8:	a8 01       	movw	r20, r16
     aba:	94 01       	movw	r18, r8
     abc:	87 01       	movw	r16, r14
     abe:	cc 24       	eor	r12, r12
     ac0:	c3 94       	inc	r12
     ac2:	0e 94 84 0b 	call	0x1708	; 0x1708 <xSpriteCreate>
     ac6:	68 2f       	mov	r22, r24
     ac8:	d5 01       	movw	r26, r10
     aca:	8c 93       	st	X, r24
         angle,                      //rAngle
         sizeToPix(size),        //width
         sizeToPix(size),        //height
         1);                     //depth
      
      newAsteroid->pos.x = x;
     acc:	f5 01       	movw	r30, r10
     ace:	41 82       	std	Z+1, r4	; 0x01
     ad0:	52 82       	std	Z+2, r5	; 0x02
     ad2:	63 82       	std	Z+3, r6	; 0x03
     ad4:	74 82       	std	Z+4, r7	; 0x04
      newAsteroid->pos.y = y;
     ad6:	89 81       	ldd	r24, Y+1	; 0x01
     ad8:	9a 81       	ldd	r25, Y+2	; 0x02
     ada:	ab 81       	ldd	r26, Y+3	; 0x03
     adc:	bc 81       	ldd	r27, Y+4	; 0x04
     ade:	85 83       	std	Z+5, r24	; 0x05
     ae0:	96 83       	std	Z+6, r25	; 0x06
     ae2:	a7 83       	std	Z+7, r26	; 0x07
     ae4:	b0 87       	std	Z+8, r27	; 0x08
      newAsteroid->vel.x = velx;
     ae6:	8d 81       	ldd	r24, Y+5	; 0x05
     ae8:	9e 81       	ldd	r25, Y+6	; 0x06
     aea:	af 81       	ldd	r26, Y+7	; 0x07
     aec:	b8 85       	ldd	r27, Y+8	; 0x08
     aee:	81 87       	std	Z+9, r24	; 0x09
     af0:	92 87       	std	Z+10, r25	; 0x0a
     af2:	a3 87       	std	Z+11, r26	; 0x0b
     af4:	b4 87       	std	Z+12, r27	; 0x0c
      newAsteroid->vel.y = vely;
     af6:	89 85       	ldd	r24, Y+9	; 0x09
     af8:	9a 85       	ldd	r25, Y+10	; 0x0a
     afa:	ab 85       	ldd	r26, Y+11	; 0x0b
     afc:	bc 85       	ldd	r27, Y+12	; 0x0c
     afe:	85 87       	std	Z+13, r24	; 0x0d
     b00:	96 87       	std	Z+14, r25	; 0x0e
     b02:	a7 87       	std	Z+15, r26	; 0x0f
     b04:	b0 8b       	std	Z+16, r27	; 0x10
      newAsteroid->angle = angle;
     b06:	96 8a       	std	Z+22, r9	; 0x16
     b08:	85 8a       	std	Z+21, r8	; 0x15
      newAsteroid->a_vel = avel;
     b0a:	8e a1       	lds	r24, 0x4e
     b0c:	87 8b       	std	Z+23, r24	; 0x17
      newAsteroid->size = size;
     b0e:	d0 8e       	std	Z+24, r13	; 0x18
      
      newAsteroid->next = asteroids;
     b10:	80 91 89 02 	lds	r24, 0x0289
     b14:	90 91 8a 02 	lds	r25, 0x028A
     b18:	94 8f       	std	Z+28, r25	; 0x1c
     b1a:	83 8f       	std	Z+27, r24	; 0x1b
      //int16_t angle;
      //int8_t a_vel;
      //uint8_t size;
      //uint16_t life;
      //struct object_s *next;
      vGroupAddSprite(astGroup, newAsteroid->handle);
     b1c:	80 91 91 02 	lds	r24, 0x0291
     b20:	0e 94 56 0c 	call	0x18ac	; 0x18ac <vGroupAddSprite>
      
      return newAsteroid;
}
     b24:	8a 2d       	mov	r24, r10
     b26:	9b 2d       	mov	r25, r11
     b28:	60 96       	adiw	r28, 0x10	; 16
     b2a:	0f b6       	in	r0, 0x3f	; 63
     b2c:	f8 94       	cli
     b2e:	de bf       	out	0x3e, r29	; 62
     b30:	0f be       	out	0x3f, r0	; 63
     b32:	cd bf       	out	0x3d, r28	; 61
     b34:	df 91       	pop	r29
     b36:	cf 91       	pop	r28
     b38:	1f 91       	pop	r17
     b3a:	0f 91       	pop	r16
     b3c:	ff 90       	pop	r15
     b3e:	ef 90       	pop	r14
     b40:	df 90       	pop	r13
     b42:	cf 90       	pop	r12
     b44:	bf 90       	pop	r11
     b46:	af 90       	pop	r10
     b48:	9f 90       	pop	r9
     b4a:	8f 90       	pop	r8
     b4c:	7f 90       	pop	r7
     b4e:	6f 90       	pop	r6
     b50:	5f 90       	pop	r5
     b52:	4f 90       	pop	r4
     b54:	3f 90       	pop	r3
     b56:	2f 90       	pop	r2
     b58:	08 95       	ret

00000b5a <init>:
 * Function: init
 *
 * Description: This function initializes a new game of asteroids. A window
 *  must be created before this function may be called.
 *----------------------------------------------------------------------------*/
void init(void) {
     b5a:	2f 92       	push	r2
     b5c:	3f 92       	push	r3
     b5e:	4f 92       	push	r4
     b60:	5f 92       	push	r5
     b62:	6f 92       	push	r6
     b64:	7f 92       	push	r7
     b66:	8f 92       	push	r8
     b68:	9f 92       	push	r9
     b6a:	af 92       	push	r10
     b6c:	bf 92       	push	r11
     b6e:	cf 92       	push	r12
     b70:	df 92       	push	r13
     b72:	ef 92       	push	r14
     b74:	ff 92       	push	r15
     b76:	0f 93       	push	r16
     b78:	1f 93       	push	r17
     b7a:	cf 93       	push	r28
     b7c:	df 93       	push	r29
     b7e:	cd b7       	in	r28, 0x3d	; 61
     b80:	de b7       	in	r29, 0x3e	; 62
     b82:	28 97       	sbiw	r28, 0x08	; 8
     b84:	0f b6       	in	r0, 0x3f	; 63
     b86:	f8 94       	cli
     b88:	de bf       	out	0x3e, r29	; 62
     b8a:	0f be       	out	0x3f, r0	; 63
     b8c:	cd bf       	out	0x3d, r28	; 61
	int i;
	
	bullets = NULL;
     b8e:	10 92 88 02 	sts	0x0288, r1
     b92:	10 92 87 02 	sts	0x0287, r1
	asteroids = NULL;
     b96:	10 92 8a 02 	sts	0x028A, r1
     b9a:	10 92 89 02 	sts	0x0289, r1
	astGroup = ERROR_HANDLE;
     b9e:	8f ef       	ldi	r24, 0xFF	; 255
     ba0:	80 93 91 02 	sts	0x0291, r24
	
	background = xSpriteCreate("stars.png", SCREEN_W>>1, SCREEN_H>>1, 0, SCREEN_W, SCREEN_H, 0);
     ba4:	8a e0       	ldi	r24, 0x0A	; 10
     ba6:	92 e0       	ldi	r25, 0x02	; 2
     ba8:	60 e9       	ldi	r22, 0x90	; 144
     baa:	71 e0       	ldi	r23, 0x01	; 1
     bac:	4c e2       	ldi	r20, 0x2C	; 44
     bae:	51 e0       	ldi	r21, 0x01	; 1
     bb0:	20 e0       	ldi	r18, 0x00	; 0
     bb2:	30 e0       	ldi	r19, 0x00	; 0
     bb4:	00 e2       	ldi	r16, 0x20	; 32
     bb6:	13 e0       	ldi	r17, 0x03	; 3
     bb8:	0f 2e       	mov	r0, r31
     bba:	f8 e5       	ldi	r31, 0x58	; 88
     bbc:	ef 2e       	mov	r14, r31
     bbe:	f2 e0       	ldi	r31, 0x02	; 2
     bc0:	ff 2e       	mov	r15, r31
     bc2:	f0 2d       	mov	r31, r0
     bc4:	cc 24       	eor	r12, r12
     bc6:	0e 94 84 0b 	call	0x1708	; 0x1708 <xSpriteCreate>
     bca:	80 93 92 02 	sts	0x0292, r24
	
	srand(TCNT0);
     bce:	86 b5       	in	r24, 0x26	; 38
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	0e 94 22 1f 	call	0x3e44	; 0x3e44 <srand>
	
	astGroup = xGroupCreate();
     bd6:	0e 94 50 0c 	call	0x18a0	; 0x18a0 <xGroupCreate>
     bda:	80 93 91 02 	sts	0x0291, r24
     bde:	0f 2e       	mov	r0, r31
     be0:	f5 e0       	ldi	r31, 0x05	; 5
     be2:	2f 2e       	mov	r2, r31
     be4:	33 24       	eor	r3, r3
     be6:	f0 2d       	mov	r31, r0
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(
         getRandStartPosVal(SCREEN_W >> 1),
     be8:	80 e9       	ldi	r24, 0x90	; 144
     bea:	91 e0       	ldi	r25, 0x01	; 1
     bec:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <getRandStartPosVal>
     bf0:	2c 01       	movw	r4, r24
         getRandStartPosVal(SCREEN_H >> 1),
     bf2:	8c e2       	ldi	r24, 0x2C	; 44
     bf4:	91 e0       	ldi	r25, 0x01	; 1
     bf6:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <getRandStartPosVal>
     bfa:	7c 01       	movw	r14, r24
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     bfc:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
     c00:	6c 01       	movw	r12, r24
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     c02:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
     c06:	5c 01       	movw	r10, r24
         rand() % 360,
     c08:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
     c0c:	4c 01       	movw	r8, r24
         (rand() % (int8_t)(AST_MAX_AVEL_3 * 10)) / 5.0 - AST_MAX_AVEL_3,
     c0e:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
     c12:	9c 83       	std	Y+4, r25	; 0x04
     c14:	8b 83       	std	Y+3, r24	; 0x03
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(
     c16:	00 d0       	rcall	.+0      	; 0xc18 <init+0xbe>
     c18:	0f 92       	push	r0
     c1a:	2d b7       	in	r18, 0x3d	; 61
     c1c:	3e b7       	in	r19, 0x3e	; 62
     c1e:	2f 5f       	subi	r18, 0xFF	; 255
     c20:	3f 4f       	sbci	r19, 0xFF	; 255
     c22:	3a 83       	std	Y+2, r19	; 0x02
     c24:	29 83       	std	Y+1, r18	; 0x01
     c26:	b2 01       	movw	r22, r4
     c28:	88 27       	eor	r24, r24
     c2a:	77 fd       	sbrc	r23, 7
     c2c:	80 95       	com	r24
     c2e:	98 2f       	mov	r25, r24
     c30:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
     c34:	6d 83       	std	Y+5, r22	; 0x05
     c36:	7e 83       	std	Y+6, r23	; 0x06
     c38:	8f 83       	std	Y+7, r24	; 0x07
     c3a:	98 87       	std	Y+8, r25	; 0x08
     c3c:	b7 01       	movw	r22, r14
     c3e:	88 27       	eor	r24, r24
     c40:	77 fd       	sbrc	r23, 7
     c42:	80 95       	com	r24
     c44:	98 2f       	mov	r25, r24
     c46:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
     c4a:	2b 01       	movw	r4, r22
     c4c:	3c 01       	movw	r6, r24
         getRandStartPosVal(SCREEN_W >> 1),
         getRandStartPosVal(SCREEN_H >> 1),
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     c4e:	c6 01       	movw	r24, r12
     c50:	64 e1       	ldi	r22, 0x14	; 20
     c52:	70 e0       	ldi	r23, 0x00	; 0
     c54:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
     c58:	fc 01       	movw	r30, r24
     c5a:	bf 01       	movw	r22, r30
     c5c:	88 27       	eor	r24, r24
     c5e:	77 fd       	sbrc	r23, 7
     c60:	80 95       	com	r24
     c62:	98 2f       	mov	r25, r24
     c64:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
     c68:	20 e0       	ldi	r18, 0x00	; 0
     c6a:	30 e0       	ldi	r19, 0x00	; 0
     c6c:	40 ea       	ldi	r20, 0xA0	; 160
     c6e:	50 e4       	ldi	r21, 0x40	; 64
     c70:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__divsf3>
     c74:	20 e0       	ldi	r18, 0x00	; 0
     c76:	30 e0       	ldi	r19, 0x00	; 0
     c78:	40 e0       	ldi	r20, 0x00	; 0
     c7a:	50 e4       	ldi	r21, 0x40	; 64
     c7c:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
     c80:	7b 01       	movw	r14, r22
     c82:	8c 01       	movw	r16, r24
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
     c84:	c5 01       	movw	r24, r10
     c86:	64 e1       	ldi	r22, 0x14	; 20
     c88:	70 e0       	ldi	r23, 0x00	; 0
     c8a:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
     c8e:	9c 01       	movw	r18, r24
     c90:	b9 01       	movw	r22, r18
     c92:	88 27       	eor	r24, r24
     c94:	77 fd       	sbrc	r23, 7
     c96:	80 95       	com	r24
     c98:	98 2f       	mov	r25, r24
     c9a:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
     c9e:	20 e0       	ldi	r18, 0x00	; 0
     ca0:	30 e0       	ldi	r19, 0x00	; 0
     ca2:	40 ea       	ldi	r20, 0xA0	; 160
     ca4:	50 e4       	ldi	r21, 0x40	; 64
     ca6:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__divsf3>
     caa:	20 e0       	ldi	r18, 0x00	; 0
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	40 e0       	ldi	r20, 0x00	; 0
     cb0:	50 e4       	ldi	r21, 0x40	; 64
     cb2:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
     cb6:	5b 01       	movw	r10, r22
     cb8:	6c 01       	movw	r12, r24
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(
     cba:	c4 01       	movw	r24, r8
     cbc:	68 e6       	ldi	r22, 0x68	; 104
     cbe:	71 e0       	ldi	r23, 0x01	; 1
     cc0:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
     cc4:	4c 01       	movw	r8, r24
         getRandStartPosVal(SCREEN_W >> 1),
         getRandStartPosVal(SCREEN_H >> 1),
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
         (rand() % (int8_t)(AST_MAX_VEL_3 * 10)) / 5.0 - AST_MAX_VEL_3,
         rand() % 360,
         (rand() % (int8_t)(AST_MAX_AVEL_3 * 10)) / 5.0 - AST_MAX_AVEL_3,
     cc6:	8b 81       	ldd	r24, Y+3	; 0x03
     cc8:	9c 81       	ldd	r25, Y+4	; 0x04
     cca:	6e e1       	ldi	r22, 0x1E	; 30
     ccc:	70 e0       	ldi	r23, 0x00	; 0
     cce:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
     cd2:	fc 01       	movw	r30, r24
     cd4:	bf 01       	movw	r22, r30
     cd6:	88 27       	eor	r24, r24
     cd8:	77 fd       	sbrc	r23, 7
     cda:	80 95       	com	r24
     cdc:	98 2f       	mov	r25, r24
     cde:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
     ce2:	20 e0       	ldi	r18, 0x00	; 0
     ce4:	30 e0       	ldi	r19, 0x00	; 0
     ce6:	40 ea       	ldi	r20, 0xA0	; 160
     ce8:	50 e4       	ldi	r21, 0x40	; 64
     cea:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__divsf3>
     cee:	20 e0       	ldi	r18, 0x00	; 0
     cf0:	30 e0       	ldi	r19, 0x00	; 0
     cf2:	40 e4       	ldi	r20, 0x40	; 64
     cf4:	50 e4       	ldi	r21, 0x40	; 64
     cf6:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
		asteroids = createAsteroid(
     cfa:	0e 94 b2 1c 	call	0x3964	; 0x3964 <__fixsfsi>
     cfe:	e9 81       	ldd	r30, Y+1	; 0x01
     d00:	fa 81       	ldd	r31, Y+2	; 0x02
     d02:	60 83       	st	Z, r22
     d04:	23 e0       	ldi	r18, 0x03	; 3
     d06:	21 83       	std	Z+1, r18	; 0x01
     d08:	80 91 89 02 	lds	r24, 0x0289
     d0c:	90 91 8a 02 	lds	r25, 0x028A
     d10:	93 83       	std	Z+3, r25	; 0x03
     d12:	82 83       	std	Z+2, r24	; 0x02
     d14:	6d 81       	ldd	r22, Y+5	; 0x05
     d16:	7e 81       	ldd	r23, Y+6	; 0x06
     d18:	8f 81       	ldd	r24, Y+7	; 0x07
     d1a:	98 85       	ldd	r25, Y+8	; 0x08
     d1c:	a3 01       	movw	r20, r6
     d1e:	92 01       	movw	r18, r4
     d20:	0e 94 08 05 	call	0xa10	; 0xa10 <createAsteroid>
     d24:	90 93 8a 02 	sts	0x028A, r25
     d28:	80 93 89 02 	sts	0x0289, r24
     d2c:	08 94       	sec
     d2e:	21 08       	sbc	r2, r1
     d30:	31 08       	sbc	r3, r1
	
	srand(TCNT0);
	
	astGroup = xGroupCreate();
	
	for (i = 0; i < INITIAL_ASTEROIDS; i++) {
     d32:	0f 90       	pop	r0
     d34:	0f 90       	pop	r0
     d36:	0f 90       	pop	r0
     d38:	0f 90       	pop	r0
     d3a:	21 14       	cp	r2, r1
     d3c:	31 04       	cpc	r3, r1
     d3e:	09 f0       	breq	.+2      	; 0xd42 <init+0x1e8>
     d40:	53 cf       	rjmp	.-346    	; 0xbe8 <init+0x8e>
         (rand() % (int8_t)(AST_MAX_AVEL_3 * 10)) / 5.0 - AST_MAX_AVEL_3,
         3,
         asteroids);
	}
	
	ship.handle = xSpriteCreate(
     d42:	84 e1       	ldi	r24, 0x14	; 20
     d44:	92 e0       	ldi	r25, 0x02	; 2
     d46:	60 e9       	ldi	r22, 0x90	; 144
     d48:	71 e0       	ldi	r23, 0x01	; 1
     d4a:	4c e2       	ldi	r20, 0x2C	; 44
     d4c:	51 e0       	ldi	r21, 0x01	; 1
     d4e:	20 e0       	ldi	r18, 0x00	; 0
     d50:	30 e0       	ldi	r19, 0x00	; 0
     d52:	0c e2       	ldi	r16, 0x2C	; 44
     d54:	10 e0       	ldi	r17, 0x00	; 0
     d56:	0f 2e       	mov	r0, r31
     d58:	fc e2       	ldi	r31, 0x2C	; 44
     d5a:	ef 2e       	mov	r14, r31
     d5c:	ff 24       	eor	r15, r15
     d5e:	f0 2d       	mov	r31, r0
     d60:	cc 24       	eor	r12, r12
     d62:	c3 94       	inc	r12
     d64:	0e 94 84 0b 	call	0x1708	; 0x1708 <xSpriteCreate>
     d68:	80 93 68 02 	sts	0x0268, r24
      0, 
      SHIP_SIZE, 
      SHIP_SIZE, 
      1);
   
	ship.pos.x = SCREEN_W >> 1;
     d6c:	80 e0       	ldi	r24, 0x00	; 0
     d6e:	90 e0       	ldi	r25, 0x00	; 0
     d70:	a8 ec       	ldi	r26, 0xC8	; 200
     d72:	b3 e4       	ldi	r27, 0x43	; 67
     d74:	80 93 69 02 	sts	0x0269, r24
     d78:	90 93 6a 02 	sts	0x026A, r25
     d7c:	a0 93 6b 02 	sts	0x026B, r26
     d80:	b0 93 6c 02 	sts	0x026C, r27
	ship.pos.y = SCREEN_H >> 1;
     d84:	80 e0       	ldi	r24, 0x00	; 0
     d86:	90 e0       	ldi	r25, 0x00	; 0
     d88:	a6 e9       	ldi	r26, 0x96	; 150
     d8a:	b3 e4       	ldi	r27, 0x43	; 67
     d8c:	80 93 6d 02 	sts	0x026D, r24
     d90:	90 93 6e 02 	sts	0x026E, r25
     d94:	a0 93 6f 02 	sts	0x026F, r26
     d98:	b0 93 70 02 	sts	0x0270, r27
	ship.vel.x = 0;
     d9c:	80 e0       	ldi	r24, 0x00	; 0
     d9e:	90 e0       	ldi	r25, 0x00	; 0
     da0:	dc 01       	movw	r26, r24
     da2:	80 93 71 02 	sts	0x0271, r24
     da6:	90 93 72 02 	sts	0x0272, r25
     daa:	a0 93 73 02 	sts	0x0273, r26
     dae:	b0 93 74 02 	sts	0x0274, r27
	ship.vel.y = 0;
     db2:	80 93 75 02 	sts	0x0275, r24
     db6:	90 93 76 02 	sts	0x0276, r25
     dba:	a0 93 77 02 	sts	0x0277, r26
     dbe:	b0 93 78 02 	sts	0x0278, r27
	ship.accel = 0;
     dc2:	80 93 79 02 	sts	0x0279, r24
     dc6:	90 93 7a 02 	sts	0x027A, r25
     dca:	a0 93 7b 02 	sts	0x027B, r26
     dce:	b0 93 7c 02 	sts	0x027C, r27
	ship.angle = 0;
     dd2:	10 92 7e 02 	sts	0x027E, r1
     dd6:	10 92 7d 02 	sts	0x027D, r1
	ship.a_vel = 0;
     dda:	10 92 7f 02 	sts	0x027F, r1
}
     dde:	28 96       	adiw	r28, 0x08	; 8
     de0:	0f b6       	in	r0, 0x3f	; 63
     de2:	f8 94       	cli
     de4:	de bf       	out	0x3e, r29	; 62
     de6:	0f be       	out	0x3f, r0	; 63
     de8:	cd bf       	out	0x3d, r28	; 61
     dea:	df 91       	pop	r29
     dec:	cf 91       	pop	r28
     dee:	1f 91       	pop	r17
     df0:	0f 91       	pop	r16
     df2:	ff 90       	pop	r15
     df4:	ef 90       	pop	r14
     df6:	df 90       	pop	r13
     df8:	cf 90       	pop	r12
     dfa:	bf 90       	pop	r11
     dfc:	af 90       	pop	r10
     dfe:	9f 90       	pop	r9
     e00:	8f 90       	pop	r8
     e02:	7f 90       	pop	r7
     e04:	6f 90       	pop	r6
     e06:	5f 90       	pop	r5
     e08:	4f 90       	pop	r4
     e0a:	3f 90       	pop	r3
     e0c:	2f 90       	pop	r2
     e0e:	08 95       	ret

00000e10 <createBullet>:
 * param vely: The new bullet's y velocity.
 * param nxt: A pointer to the next bullet object in a linked list of bullets.
 * return: A pointer to a malloc'd bullet object. This pointer must be freed by
 *  the caller.
 *----------------------------------------------------------------------------*/
object *createBullet(float x, float y, float velx, float vely, object *nxt) {
     e10:	4f 92       	push	r4
     e12:	5f 92       	push	r5
     e14:	6f 92       	push	r6
     e16:	7f 92       	push	r7
     e18:	8f 92       	push	r8
     e1a:	9f 92       	push	r9
     e1c:	af 92       	push	r10
     e1e:	bf 92       	push	r11
     e20:	cf 92       	push	r12
     e22:	df 92       	push	r13
     e24:	ef 92       	push	r14
     e26:	ff 92       	push	r15
     e28:	0f 93       	push	r16
     e2a:	1f 93       	push	r17
     e2c:	cf 93       	push	r28
     e2e:	df 93       	push	r29
     e30:	cd b7       	in	r28, 0x3d	; 61
     e32:	de b7       	in	r29, 0x3e	; 62
     e34:	60 97       	sbiw	r28, 0x10	; 16
     e36:	0f b6       	in	r0, 0x3f	; 63
     e38:	f8 94       	cli
     e3a:	de bf       	out	0x3e, r29	; 62
     e3c:	0f be       	out	0x3f, r0	; 63
     e3e:	cd bf       	out	0x3d, r28	; 61
     e40:	2b 01       	movw	r4, r22
     e42:	3c 01       	movw	r6, r24
     e44:	29 83       	std	Y+1, r18	; 0x01
     e46:	3a 83       	std	Y+2, r19	; 0x02
     e48:	4b 83       	std	Y+3, r20	; 0x03
     e4a:	5c 83       	std	Y+4, r21	; 0x04
     e4c:	ed 82       	std	Y+5, r14	; 0x05
     e4e:	fe 82       	std	Y+6, r15	; 0x06
     e50:	0f 83       	std	Y+7, r16	; 0x07
     e52:	18 87       	std	Y+8, r17	; 0x08
     e54:	a9 86       	std	Y+9, r10	; 0x09
     e56:	ba 86       	std	Y+10, r11	; 0x0a
     e58:	cb 86       	std	Y+11, r12	; 0x0b
     e5a:	dc 86       	std	Y+12, r13	; 0x0c
	//Create a new bullet object using a reentrant malloc() function
	object *newBullet = pvPortMalloc(sizeof(object));
     e5c:	8d e1       	ldi	r24, 0x1D	; 29
     e5e:	90 e0       	ldi	r25, 0x00	; 0
     e60:	0e 94 af 0c 	call	0x195e	; 0x195e <pvPortMalloc>
     e64:	5c 01       	movw	r10, r24
	
	//Setup the pointers in the linked list
	//Create a new sprite using xSpriteCreate()
	newBullet->handle = xSpriteCreate(
     e66:	c3 01       	movw	r24, r6
     e68:	b2 01       	movw	r22, r4
     e6a:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
     e6e:	6d 87       	std	Y+13, r22	; 0x0d
     e70:	7e 87       	std	Y+14, r23	; 0x0e
     e72:	8f 87       	std	Y+15, r24	; 0x0f
     e74:	98 8b       	std	Y+16, r25	; 0x10
     e76:	69 81       	ldd	r22, Y+1	; 0x01
     e78:	7a 81       	ldd	r23, Y+2	; 0x02
     e7a:	8b 81       	ldd	r24, Y+3	; 0x03
     e7c:	9c 81       	ldd	r25, Y+4	; 0x04
     e7e:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
     e82:	6b 01       	movw	r12, r22
     e84:	7c 01       	movw	r14, r24
     e86:	20 91 7d 02 	lds	r18, 0x027D
     e8a:	30 91 7e 02 	lds	r19, 0x027E
     e8e:	8d e1       	ldi	r24, 0x1D	; 29
     e90:	92 e0       	ldi	r25, 0x02	; 2
     e92:	6d 85       	ldd	r22, Y+13	; 0x0d
     e94:	7e 85       	ldd	r23, Y+14	; 0x0e
     e96:	a6 01       	movw	r20, r12
     e98:	0a e1       	ldi	r16, 0x1A	; 26
     e9a:	10 e0       	ldi	r17, 0x00	; 0
     e9c:	0f 2e       	mov	r0, r31
     e9e:	fa e1       	ldi	r31, 0x1A	; 26
     ea0:	ef 2e       	mov	r14, r31
     ea2:	ff 24       	eor	r15, r15
     ea4:	f0 2d       	mov	r31, r0
     ea6:	cc 24       	eor	r12, r12
     ea8:	c3 94       	inc	r12
     eaa:	0e 94 84 0b 	call	0x1708	; 0x1708 <xSpriteCreate>
     eae:	d5 01       	movw	r26, r10
     eb0:	8c 93       	st	X, r24
	ship.angle,             //rAngle
	BULLET_SIZE,			//width
	BULLET_SIZE,			//height
	1);                     //depth

   newBullet->pos.x = x;
     eb2:	f5 01       	movw	r30, r10
     eb4:	41 82       	std	Z+1, r4	; 0x01
     eb6:	52 82       	std	Z+2, r5	; 0x02
     eb8:	63 82       	std	Z+3, r6	; 0x03
     eba:	74 82       	std	Z+4, r7	; 0x04
   newBullet->pos.y = y;
     ebc:	89 81       	ldd	r24, Y+1	; 0x01
     ebe:	9a 81       	ldd	r25, Y+2	; 0x02
     ec0:	ab 81       	ldd	r26, Y+3	; 0x03
     ec2:	bc 81       	ldd	r27, Y+4	; 0x04
     ec4:	85 83       	std	Z+5, r24	; 0x05
     ec6:	96 83       	std	Z+6, r25	; 0x06
     ec8:	a7 83       	std	Z+7, r26	; 0x07
     eca:	b0 87       	std	Z+8, r27	; 0x08
   newBullet->vel.x = velx;
     ecc:	8d 81       	ldd	r24, Y+5	; 0x05
     ece:	9e 81       	ldd	r25, Y+6	; 0x06
     ed0:	af 81       	ldd	r26, Y+7	; 0x07
     ed2:	b8 85       	ldd	r27, Y+8	; 0x08
     ed4:	81 87       	std	Z+9, r24	; 0x09
     ed6:	92 87       	std	Z+10, r25	; 0x0a
     ed8:	a3 87       	std	Z+11, r26	; 0x0b
     eda:	b4 87       	std	Z+12, r27	; 0x0c
   newBullet->vel.y = vely;
     edc:	89 85       	ldd	r24, Y+9	; 0x09
     ede:	9a 85       	ldd	r25, Y+10	; 0x0a
     ee0:	ab 85       	ldd	r26, Y+11	; 0x0b
     ee2:	bc 85       	ldd	r27, Y+12	; 0x0c
     ee4:	85 87       	std	Z+13, r24	; 0x0d
     ee6:	96 87       	std	Z+14, r25	; 0x0e
     ee8:	a7 87       	std	Z+15, r26	; 0x0f
     eea:	b0 8b       	std	Z+16, r27	; 0x10
   newBullet->size = BULLET_SIZE;
     eec:	8a e1       	ldi	r24, 0x1A	; 26
     eee:	80 8f       	std	Z+24, r24	; 0x18
   newBullet->life = 0;
     ef0:	12 8e       	std	Z+26, r1	; 0x1a
     ef2:	11 8e       	std	Z+25, r1	; 0x19
   newBullet->next = nxt;
     ef4:	94 8e       	std	Z+28, r9	; 0x1c
     ef6:	83 8e       	std	Z+27, r8	; 0x1b

   return (newBullet); 
}
     ef8:	8a 2d       	mov	r24, r10
     efa:	9b 2d       	mov	r25, r11
     efc:	60 96       	adiw	r28, 0x10	; 16
     efe:	0f b6       	in	r0, 0x3f	; 63
     f00:	f8 94       	cli
     f02:	de bf       	out	0x3e, r29	; 62
     f04:	0f be       	out	0x3f, r0	; 63
     f06:	cd bf       	out	0x3d, r28	; 61
     f08:	df 91       	pop	r29
     f0a:	cf 91       	pop	r28
     f0c:	1f 91       	pop	r17
     f0e:	0f 91       	pop	r16
     f10:	ff 90       	pop	r15
     f12:	ef 90       	pop	r14
     f14:	df 90       	pop	r13
     f16:	cf 90       	pop	r12
     f18:	bf 90       	pop	r11
     f1a:	af 90       	pop	r10
     f1c:	9f 90       	pop	r9
     f1e:	8f 90       	pop	r8
     f20:	7f 90       	pop	r7
     f22:	6f 90       	pop	r6
     f24:	5f 90       	pop	r5
     f26:	4f 90       	pop	r4
     f28:	08 95       	ret

00000f2a <bulletTask>:
 *  second to regulate the fire rate.  If a bullet is not fired, the task
 *  blocks for a frame delay (FRAME_DELAY_MS)
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void bulletTask(void *vParam) {
     f2a:	cf 93       	push	r28
     f2c:	df 93       	push	r29
     f2e:	cd b7       	in	r28, 0x3d	; 61
     f30:	de b7       	in	r29, 0x3e	; 62
     f32:	28 97       	sbiw	r28, 0x08	; 8
     f34:	0f b6       	in	r0, 0x3f	; 63
     f36:	f8 94       	cli
     f38:	de bf       	out	0x3e, r29	; 62
     f3a:	0f be       	out	0x3f, r0	; 63
     f3c:	cd bf       	out	0x3d, r28	; 61
     bullets = createBullet(x, y, vx, vy, bullets);
     */
	// variable to hold ticks value of last task run
	portTickType xLastWakeTime;
	// Initialize the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();
     f3e:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <xTaskGetTickCount>

    while (1) {
	    if(SHOOT_BUTTON) {
		    xSemaphoreTake(usartMutex, portMAX_DELAY);
			//Make a new bullet and add to linked list
		    bullets = createBullet(ship.pos.x, ship.pos.y, -sin(ship.angle*DEG_TO_RAD)*BULLET_VEL, -cos(ship.angle*DEG_TO_RAD)*BULLET_VEL, bullets);
     f42:	0f 2e       	mov	r0, r31
     f44:	fd e7       	ldi	r31, 0x7D	; 125
     f46:	2f 2e       	mov	r2, r31
     f48:	f2 e0       	ldi	r31, 0x02	; 2
     f4a:	3f 2e       	mov	r3, r31
     f4c:	f0 2d       	mov	r31, r0
     f4e:	c1 01       	movw	r24, r2
     f50:	44 97       	sbiw	r24, 0x14	; 20
     f52:	9e 83       	std	Y+6, r25	; 0x06
     f54:	8d 83       	std	Y+5, r24	; 0x05
     f56:	d1 01       	movw	r26, r2
     f58:	50 97       	sbiw	r26, 0x10	; 16
     f5a:	b8 87       	std	Y+8, r27	; 0x08
     f5c:	af 83       	std	Y+7, r26	; 0x07
	portTickType xLastWakeTime;
	// Initialize the xLastWakeTime variable with the current time.
	xLastWakeTime = xTaskGetTickCount();

    while (1) {
	    if(SHOOT_BUTTON) {
     f5e:	18 99       	sbic	0x03, 0	; 3
     f60:	7f c0       	rjmp	.+254    	; 0x1060 <bulletTask+0x136>
		    xSemaphoreTake(usartMutex, portMAX_DELAY);
     f62:	80 91 85 02 	lds	r24, 0x0285
     f66:	90 91 86 02 	lds	r25, 0x0286
     f6a:	60 e0       	ldi	r22, 0x00	; 0
     f6c:	70 e0       	ldi	r23, 0x00	; 0
     f6e:	4f ef       	ldi	r20, 0xFF	; 255
     f70:	5f ef       	ldi	r21, 0xFF	; 255
     f72:	20 e0       	ldi	r18, 0x00	; 0
     f74:	0e 94 28 14 	call	0x2850	; 0x2850 <xQueueGenericReceive>
			//Make a new bullet and add to linked list
		    bullets = createBullet(ship.pos.x, ship.pos.y, -sin(ship.angle*DEG_TO_RAD)*BULLET_VEL, -cos(ship.angle*DEG_TO_RAD)*BULLET_VEL, bullets);
     f78:	f1 01       	movw	r30, r2
     f7a:	60 81       	ld	r22, Z
     f7c:	71 81       	ldd	r23, Z+1	; 0x01
     f7e:	88 27       	eor	r24, r24
     f80:	77 fd       	sbrc	r23, 7
     f82:	80 95       	com	r24
     f84:	98 2f       	mov	r25, r24
     f86:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
     f8a:	2b ed       	ldi	r18, 0xDB	; 219
     f8c:	3f e0       	ldi	r19, 0x0F	; 15
     f8e:	49 e4       	ldi	r20, 0x49	; 73
     f90:	50 e4       	ldi	r21, 0x40	; 64
     f92:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
     f96:	20 e0       	ldi	r18, 0x00	; 0
     f98:	30 e0       	ldi	r19, 0x00	; 0
     f9a:	44 e3       	ldi	r20, 0x34	; 52
     f9c:	53 e4       	ldi	r21, 0x43	; 67
     f9e:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__divsf3>
     fa2:	a6 2e       	mov	r10, r22
     fa4:	87 2e       	mov	r8, r23
     fa6:	18 2f       	mov	r17, r24
     fa8:	09 2f       	mov	r16, r25
     faa:	86 2f       	mov	r24, r22
     fac:	98 2d       	mov	r25, r8
     fae:	a1 2f       	mov	r26, r17
     fb0:	b0 2f       	mov	r27, r16
     fb2:	bc 01       	movw	r22, r24
     fb4:	cd 01       	movw	r24, r26
     fb6:	0e 94 35 1e 	call	0x3c6a	; 0x3c6a <sin>
     fba:	6b 01       	movw	r12, r22
     fbc:	7c 01       	movw	r14, r24
     fbe:	8a 2d       	mov	r24, r10
     fc0:	98 2d       	mov	r25, r8
     fc2:	a1 2f       	mov	r26, r17
     fc4:	b0 2f       	mov	r27, r16
     fc6:	bc 01       	movw	r22, r24
     fc8:	cd 01       	movw	r24, r26
     fca:	0e 94 47 1c 	call	0x388e	; 0x388e <cos>
     fce:	4b 01       	movw	r8, r22
     fd0:	5c 01       	movw	r10, r24
     fd2:	ad 81       	ldd	r26, Y+5	; 0x05
     fd4:	be 81       	ldd	r27, Y+6	; 0x06
     fd6:	4d 90       	ld	r4, X+
     fd8:	5d 90       	ld	r5, X+
     fda:	6d 90       	ld	r6, X+
     fdc:	7c 90       	ld	r7, X
     fde:	af 81       	ldd	r26, Y+7	; 0x07
     fe0:	b8 85       	ldd	r27, Y+8	; 0x08
     fe2:	8d 91       	ld	r24, X+
     fe4:	9d 91       	ld	r25, X+
     fe6:	0d 90       	ld	r0, X+
     fe8:	bc 91       	ld	r27, X
     fea:	a0 2d       	mov	r26, r0
     fec:	89 83       	std	Y+1, r24	; 0x01
     fee:	9a 83       	std	Y+2, r25	; 0x02
     ff0:	ab 83       	std	Y+3, r26	; 0x03
     ff2:	bc 83       	std	Y+4, r27	; 0x04
     ff4:	c7 01       	movw	r24, r14
     ff6:	b6 01       	movw	r22, r12
     ff8:	90 58       	subi	r25, 0x80	; 128
     ffa:	20 e0       	ldi	r18, 0x00	; 0
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	40 ec       	ldi	r20, 0xC0	; 192
    1000:	50 e4       	ldi	r21, 0x40	; 64
    1002:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
    1006:	7b 01       	movw	r14, r22
    1008:	8c 01       	movw	r16, r24
    100a:	c5 01       	movw	r24, r10
    100c:	b4 01       	movw	r22, r8
    100e:	90 58       	subi	r25, 0x80	; 128
    1010:	20 e0       	ldi	r18, 0x00	; 0
    1012:	30 e0       	ldi	r19, 0x00	; 0
    1014:	40 ec       	ldi	r20, 0xC0	; 192
    1016:	50 e4       	ldi	r21, 0x40	; 64
    1018:	0e 94 d2 1d 	call	0x3ba4	; 0x3ba4 <__mulsf3>
    101c:	5b 01       	movw	r10, r22
    101e:	6c 01       	movw	r12, r24
    1020:	80 90 87 02 	lds	r8, 0x0287
    1024:	90 90 88 02 	lds	r9, 0x0288
    1028:	c3 01       	movw	r24, r6
    102a:	b2 01       	movw	r22, r4
    102c:	29 81       	ldd	r18, Y+1	; 0x01
    102e:	3a 81       	ldd	r19, Y+2	; 0x02
    1030:	4b 81       	ldd	r20, Y+3	; 0x03
    1032:	5c 81       	ldd	r21, Y+4	; 0x04
    1034:	0e 94 08 07 	call	0xe10	; 0xe10 <createBullet>
    1038:	90 93 88 02 	sts	0x0288, r25
    103c:	80 93 87 02 	sts	0x0287, r24
			xSemaphoreGive(usartMutex);
    1040:	80 91 85 02 	lds	r24, 0x0285
    1044:	90 91 86 02 	lds	r25, 0x0286
    1048:	60 e0       	ldi	r22, 0x00	; 0
    104a:	70 e0       	ldi	r23, 0x00	; 0
    104c:	40 e0       	ldi	r20, 0x00	; 0
    104e:	50 e0       	ldi	r21, 0x00	; 0
    1050:	20 e0       	ldi	r18, 0x00	; 0
    1052:	0e 94 2b 13 	call	0x2656	; 0x2656 <xQueueGenericSend>
		    vTaskDelay(BULLET_DELAY_MS/portTICK_RATE_MS);
    1056:	84 ef       	ldi	r24, 0xF4	; 244
    1058:	91 e0       	ldi	r25, 0x01	; 1
    105a:	0e 94 e3 18 	call	0x31c6	; 0x31c6 <vTaskDelay>
    105e:	7f cf       	rjmp	.-258    	; 0xf5e <bulletTask+0x34>
	    }
		else
			vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
    1060:	8a e0       	ldi	r24, 0x0A	; 10
    1062:	90 e0       	ldi	r25, 0x00	; 0
    1064:	0e 94 e3 18 	call	0x31c6	; 0x31c6 <vTaskDelay>
    1068:	7a cf       	rjmp	.-268    	; 0xf5e <bulletTask+0x34>

0000106a <spawnAsteroid>:
 *
 * param pos: A pointer to the position at which the new asteroids will be
 *  created.
 * param size: The size of the asteroid being destroyed.
 *----------------------------------------------------------------------------*/
void spawnAsteroid(point *pos, uint8_t size) {
    106a:	2f 92       	push	r2
    106c:	3f 92       	push	r3
    106e:	4f 92       	push	r4
    1070:	5f 92       	push	r5
    1072:	6f 92       	push	r6
    1074:	7f 92       	push	r7
    1076:	8f 92       	push	r8
    1078:	9f 92       	push	r9
    107a:	af 92       	push	r10
    107c:	bf 92       	push	r11
    107e:	cf 92       	push	r12
    1080:	df 92       	push	r13
    1082:	ef 92       	push	r14
    1084:	ff 92       	push	r15
    1086:	0f 93       	push	r16
    1088:	1f 93       	push	r17
    108a:	cf 93       	push	r28
    108c:	df 93       	push	r29
    108e:	cd b7       	in	r28, 0x3d	; 61
    1090:	de b7       	in	r29, 0x3e	; 62
    1092:	6a 97       	sbiw	r28, 0x1a	; 26
    1094:	0f b6       	in	r0, 0x3f	; 63
    1096:	f8 94       	cli
    1098:	de bf       	out	0x3e, r29	; 62
    109a:	0f be       	out	0x3f, r0	; 63
    109c:	cd bf       	out	0x3d, r28	; 61
    109e:	9c 83       	std	Y+4, r25	; 0x04
    10a0:	8b 83       	std	Y+3, r24	; 0x03
	/* ToDo:
     * Spawn 3 smaller asteroids, or no asteroids depending on the size of this asteroid
     * Use createAsteroid()
     */
   int vel, accel;
   if (size > 1) {
    10a2:	62 30       	cpi	r22, 0x02	; 2
    10a4:	08 f4       	brcc	.+2      	; 0x10a8 <spawnAsteroid+0x3e>
    10a6:	0e c1       	rjmp	.+540    	; 0x12c4 <spawnAsteroid+0x25a>
      switch (size - 1) {
    10a8:	86 2f       	mov	r24, r22
    10aa:	90 e0       	ldi	r25, 0x00	; 0
    10ac:	01 97       	sbiw	r24, 0x01	; 1
    10ae:	81 30       	cpi	r24, 0x01	; 1
    10b0:	91 05       	cpc	r25, r1
    10b2:	69 f0       	breq	.+26     	; 0x10ce <spawnAsteroid+0x64>
    10b4:	82 30       	cpi	r24, 0x02	; 2
    10b6:	91 05       	cpc	r25, r1
    10b8:	29 f4       	brne	.+10     	; 0x10c4 <spawnAsteroid+0x5a>
         case 2:
            vel = AST_MAX_VEL_2;
            accel = AST_MAX_AVEL_2;
    10ba:	26 e0       	ldi	r18, 0x06	; 6
    10bc:	30 e0       	ldi	r19, 0x00	; 0
     */
   int vel, accel;
   if (size > 1) {
      switch (size - 1) {
         case 2:
            vel = AST_MAX_VEL_2;
    10be:	83 e0       	ldi	r24, 0x03	; 3
    10c0:	90 e0       	ldi	r25, 0x00	; 0
    10c2:	09 c0       	rjmp	.+18     	; 0x10d6 <spawnAsteroid+0x6c>
            vel = AST_MAX_VEL_1;
            accel = AST_MAX_AVEL_1;
            break;
         default:
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
    10c4:	23 e0       	ldi	r18, 0x03	; 3
    10c6:	30 e0       	ldi	r19, 0x00	; 0
         case 1:
            vel = AST_MAX_VEL_1;
            accel = AST_MAX_AVEL_1;
            break;
         default:
            vel = AST_MAX_VEL_3;
    10c8:	82 e0       	ldi	r24, 0x02	; 2
    10ca:	90 e0       	ldi	r25, 0x00	; 0
            accel = AST_MAX_AVEL_3;
            break;
    10cc:	04 c0       	rjmp	.+8      	; 0x10d6 <spawnAsteroid+0x6c>
            vel = AST_MAX_VEL_2;
            accel = AST_MAX_AVEL_2;
            break;
         case 1:
            vel = AST_MAX_VEL_1;
            accel = AST_MAX_AVEL_1;
    10ce:	29 e0       	ldi	r18, 0x09	; 9
    10d0:	30 e0       	ldi	r19, 0x00	; 0
         case 2:
            vel = AST_MAX_VEL_2;
            accel = AST_MAX_AVEL_2;
            break;
         case 1:
            vel = AST_MAX_VEL_1;
    10d2:	84 e0       	ldi	r24, 0x04	; 4
    10d4:	90 e0       	ldi	r25, 0x00	; 0
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
    10d6:	48 2f       	mov	r20, r24
    10d8:	44 0f       	add	r20, r20
    10da:	54 2f       	mov	r21, r20
    10dc:	55 0f       	add	r21, r21
    10de:	55 0f       	add	r21, r21
    10e0:	45 0f       	add	r20, r21
    10e2:	e4 2e       	mov	r14, r20
    10e4:	ff 24       	eor	r15, r15
    10e6:	e7 fc       	sbrc	r14, 7
    10e8:	f0 94       	com	r15
    10ea:	fe 82       	std	Y+6, r15	; 0x06
    10ec:	ed 82       	std	Y+5, r14	; 0x05
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
            rand() % 360,                                   //angle
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    10ee:	42 2f       	mov	r20, r18
    10f0:	44 0f       	add	r20, r20
    10f2:	54 2f       	mov	r21, r20
    10f4:	55 0f       	add	r21, r21
    10f6:	55 0f       	add	r21, r21
    10f8:	45 0f       	add	r20, r21
    10fa:	04 2f       	mov	r16, r20
    10fc:	11 27       	eor	r17, r17
    10fe:	07 fd       	sbrc	r16, 7
    1100:	10 95       	com	r17
    1102:	18 8b       	std	Y+16, r17	; 0x10
    1104:	0f 87       	std	Y+15, r16	; 0x0f
    1106:	0f 2e       	mov	r0, r31
    1108:	f3 e0       	ldi	r31, 0x03	; 3
    110a:	2f 2e       	mov	r2, r31
    110c:	33 24       	eor	r3, r3
    110e:	f0 2d       	mov	r31, r0
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    1110:	7c 01       	movw	r14, r24
    1112:	00 27       	eor	r16, r16
    1114:	f7 fc       	sbrc	r15, 7
    1116:	00 95       	com	r16
    1118:	10 2f       	mov	r17, r16
    111a:	e9 8a       	std	Y+17, r14	; 0x11
    111c:	fa 8a       	std	Y+18, r15	; 0x12
    111e:	0b 8b       	std	Y+19, r16	; 0x13
    1120:	1c 8b       	std	Y+20, r17	; 0x14
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
            rand() % 360,                                   //angle
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    1122:	c9 01       	movw	r24, r18
    1124:	aa 27       	eor	r26, r26
    1126:	97 fd       	sbrc	r25, 7
    1128:	a0 95       	com	r26
    112a:	ba 2f       	mov	r27, r26
    112c:	8d 8b       	std	Y+21, r24	; 0x15
    112e:	9e 8b       	std	Y+22, r25	; 0x16
    1130:	af 8b       	std	Y+23, r26	; 0x17
    1132:	b8 8f       	std	Y+24, r27	; 0x18
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    1134:	76 2e       	mov	r7, r22
    1136:	7a 94       	dec	r7
    1138:	3a 82       	std	Y+2, r3	; 0x02
    113a:	29 82       	std	Y+1, r2	; 0x01
    113c:	ab 81       	ldd	r26, Y+3	; 0x03
    113e:	bc 81       	ldd	r27, Y+4	; 0x04
    1140:	ed 90       	ld	r14, X+
    1142:	fd 90       	ld	r15, X+
    1144:	0d 91       	ld	r16, X+
    1146:	1c 91       	ld	r17, X
    1148:	13 97       	sbiw	r26, 0x03	; 3
    114a:	ef 82       	std	Y+7, r14	; 0x07
    114c:	f8 86       	std	Y+8, r15	; 0x08
    114e:	09 87       	std	Y+9, r16	; 0x09
    1150:	1a 87       	std	Y+10, r17	; 0x0a
    1152:	14 96       	adiw	r26, 0x04	; 4
    1154:	ed 90       	ld	r14, X+
    1156:	fd 90       	ld	r15, X+
    1158:	0d 91       	ld	r16, X+
    115a:	1c 91       	ld	r17, X
    115c:	17 97       	sbiw	r26, 0x07	; 7
    115e:	eb 86       	std	Y+11, r14	; 0x0b
    1160:	fc 86       	std	Y+12, r15	; 0x0c
    1162:	0d 87       	std	Y+13, r16	; 0x0d
    1164:	1e 87       	std	Y+14, r17	; 0x0e
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
    1166:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
    116a:	8c 01       	movw	r16, r24
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    116c:	69 89       	ldd	r22, Y+17	; 0x11
    116e:	7a 89       	ldd	r23, Y+18	; 0x12
    1170:	8b 89       	ldd	r24, Y+19	; 0x13
    1172:	9c 89       	ldd	r25, Y+20	; 0x14
    1174:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
    1178:	6b 01       	movw	r12, r22
    117a:	7c 01       	movw	r14, r24
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
    117c:	c8 01       	movw	r24, r16
    117e:	6d 81       	ldd	r22, Y+5	; 0x05
    1180:	7e 81       	ldd	r23, Y+6	; 0x06
    1182:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
    1186:	fc 01       	movw	r30, r24
    1188:	bf 01       	movw	r22, r30
    118a:	88 27       	eor	r24, r24
    118c:	77 fd       	sbrc	r23, 7
    118e:	80 95       	com	r24
    1190:	98 2f       	mov	r25, r24
    1192:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
    1196:	20 e0       	ldi	r18, 0x00	; 0
    1198:	30 e0       	ldi	r19, 0x00	; 0
    119a:	40 ea       	ldi	r20, 0xA0	; 160
    119c:	50 e4       	ldi	r21, 0x40	; 64
    119e:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__divsf3>
    11a2:	a7 01       	movw	r20, r14
    11a4:	96 01       	movw	r18, r12
    11a6:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
    11aa:	66 2e       	mov	r6, r22
    11ac:	57 2e       	mov	r5, r23
    11ae:	48 2e       	mov	r4, r24
    11b0:	29 2e       	mov	r2, r25
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
    11b2:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
    11b6:	6d 81       	ldd	r22, Y+5	; 0x05
    11b8:	7e 81       	ldd	r23, Y+6	; 0x06
    11ba:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
    11be:	8c 01       	movw	r16, r24
    11c0:	b8 01       	movw	r22, r16
    11c2:	88 27       	eor	r24, r24
    11c4:	77 fd       	sbrc	r23, 7
    11c6:	80 95       	com	r24
    11c8:	98 2f       	mov	r25, r24
    11ca:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
    11ce:	20 e0       	ldi	r18, 0x00	; 0
    11d0:	30 e0       	ldi	r19, 0x00	; 0
    11d2:	40 ea       	ldi	r20, 0xA0	; 160
    11d4:	50 e4       	ldi	r21, 0x40	; 64
    11d6:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__divsf3>
    11da:	a7 01       	movw	r20, r14
    11dc:	96 01       	movw	r18, r12
    11de:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
    11e2:	b6 2e       	mov	r11, r22
    11e4:	a7 2e       	mov	r10, r23
    11e6:	98 2e       	mov	r9, r24
    11e8:	89 2e       	mov	r8, r25
            rand() % 360,                                   //angle
    11ea:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
    11ee:	6c 01       	movw	r12, r24
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    11f0:	0e 94 1d 1f 	call	0x3e3a	; 0x3e3a <rand>
    11f4:	9c 01       	movw	r18, r24
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    11f6:	00 d0       	rcall	.+0      	; 0x11f8 <spawnAsteroid+0x18e>
    11f8:	0f 92       	push	r0
    11fa:	0d b7       	in	r16, 0x3d	; 61
    11fc:	1e b7       	in	r17, 0x3e	; 62
    11fe:	0f 5f       	subi	r16, 0xFF	; 255
    1200:	1f 4f       	sbci	r17, 0xFF	; 255
    1202:	c6 01       	movw	r24, r12
    1204:	68 e6       	ldi	r22, 0x68	; 104
    1206:	71 e0       	ldi	r23, 0x01	; 1
    1208:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
    120c:	9a 8f       	std	Y+26, r25	; 0x1a
    120e:	89 8f       	std	Y+25, r24	; 0x19
            pos->x,                                         //x pos
            pos->y,                                         //y pos
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //x vel
            (rand() % (int8_t)(vel * 10)) / 5.0 - vel,      //y vel
            rand() % 360,                                   //angle
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
    1210:	c9 01       	movw	r24, r18
    1212:	6f 85       	ldd	r22, Y+15	; 0x0f
    1214:	78 89       	ldd	r23, Y+16	; 0x10
    1216:	0e 94 7f 1e 	call	0x3cfe	; 0x3cfe <__divmodhi4>
    121a:	9c 01       	movw	r18, r24
    121c:	b9 01       	movw	r22, r18
    121e:	88 27       	eor	r24, r24
    1220:	77 fd       	sbrc	r23, 7
    1222:	80 95       	com	r24
    1224:	98 2f       	mov	r25, r24
    1226:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
    122a:	20 e0       	ldi	r18, 0x00	; 0
    122c:	30 e0       	ldi	r19, 0x00	; 0
    122e:	40 ea       	ldi	r20, 0xA0	; 160
    1230:	50 e4       	ldi	r21, 0x40	; 64
    1232:	0e 94 4a 1c 	call	0x3894	; 0x3894 <__divsf3>
    1236:	6b 01       	movw	r12, r22
    1238:	7c 01       	movw	r14, r24
    123a:	6d 89       	ldd	r22, Y+21	; 0x15
    123c:	7e 89       	ldd	r23, Y+22	; 0x16
    123e:	8f 89       	ldd	r24, Y+23	; 0x17
    1240:	98 8d       	ldd	r25, Y+24	; 0x18
    1242:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__floatsisf>
    1246:	9b 01       	movw	r18, r22
    1248:	ac 01       	movw	r20, r24
    124a:	c7 01       	movw	r24, r14
    124c:	b6 01       	movw	r22, r12
    124e:	0e 94 de 1b 	call	0x37bc	; 0x37bc <__subsf3>
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
         asteroids = createAsteroid(
    1252:	0e 94 b2 1c 	call	0x3964	; 0x3964 <__fixsfsi>
    1256:	d8 01       	movw	r26, r16
    1258:	6c 93       	st	X, r22
    125a:	11 96       	adiw	r26, 0x01	; 1
    125c:	7c 92       	st	X, r7
    125e:	11 97       	sbiw	r26, 0x01	; 1
    1260:	80 91 89 02 	lds	r24, 0x0289
    1264:	90 91 8a 02 	lds	r25, 0x028A
    1268:	13 96       	adiw	r26, 0x03	; 3
    126a:	9c 93       	st	X, r25
    126c:	8e 93       	st	-X, r24
    126e:	12 97       	sbiw	r26, 0x02	; 2
    1270:	6f 81       	ldd	r22, Y+7	; 0x07
    1272:	78 85       	ldd	r23, Y+8	; 0x08
    1274:	89 85       	ldd	r24, Y+9	; 0x09
    1276:	9a 85       	ldd	r25, Y+10	; 0x0a
    1278:	2b 85       	ldd	r18, Y+11	; 0x0b
    127a:	3c 85       	ldd	r19, Y+12	; 0x0c
    127c:	4d 85       	ldd	r20, Y+13	; 0x0d
    127e:	5e 85       	ldd	r21, Y+14	; 0x0e
    1280:	c6 2c       	mov	r12, r6
    1282:	d5 2c       	mov	r13, r5
    1284:	e4 2c       	mov	r14, r4
    1286:	f2 2c       	mov	r15, r2
    1288:	87 01       	movw	r16, r14
    128a:	76 01       	movw	r14, r12
    128c:	a9 2d       	mov	r26, r9
    128e:	b8 2d       	mov	r27, r8
    1290:	8b 2c       	mov	r8, r11
    1292:	9a 2c       	mov	r9, r10
    1294:	aa 2e       	mov	r10, r26
    1296:	bb 2e       	mov	r11, r27
    1298:	65 01       	movw	r12, r10
    129a:	54 01       	movw	r10, r8
    129c:	89 8c       	ldd	r8, Y+25	; 0x19
    129e:	9a 8c       	ldd	r9, Y+26	; 0x1a
    12a0:	0e 94 08 05 	call	0xa10	; 0xa10 <createAsteroid>
    12a4:	90 93 8a 02 	sts	0x028A, r25
    12a8:	80 93 89 02 	sts	0x0289, r24
    12ac:	e9 81       	ldd	r30, Y+1	; 0x01
    12ae:	fa 81       	ldd	r31, Y+2	; 0x02
    12b0:	31 97       	sbiw	r30, 0x01	; 1
    12b2:	fa 83       	std	Y+2, r31	; 0x02
    12b4:	e9 83       	std	Y+1, r30	; 0x01
         default:
            vel = AST_MAX_VEL_3;
            accel = AST_MAX_AVEL_3;
            break;
      }
		for(int i = 0; i < 3; i++) {
    12b6:	0f 90       	pop	r0
    12b8:	0f 90       	pop	r0
    12ba:	0f 90       	pop	r0
    12bc:	0f 90       	pop	r0
    12be:	30 97       	sbiw	r30, 0x00	; 0
    12c0:	09 f0       	breq	.+2      	; 0x12c4 <spawnAsteroid+0x25a>
    12c2:	3c cf       	rjmp	.-392    	; 0x113c <spawnAsteroid+0xd2>
            (rand() % (int8_t)(accel * 10)) / 5.0 - accel,  //accel
            size - 1,                                       //size
            asteroids);                                     //next asteroid
      }
   }
    12c4:	6a 96       	adiw	r28, 0x1a	; 26
    12c6:	0f b6       	in	r0, 0x3f	; 63
    12c8:	f8 94       	cli
    12ca:	de bf       	out	0x3e, r29	; 62
    12cc:	0f be       	out	0x3f, r0	; 63
    12ce:	cd bf       	out	0x3d, r28	; 61
    12d0:	df 91       	pop	r29
    12d2:	cf 91       	pop	r28
    12d4:	1f 91       	pop	r17
    12d6:	0f 91       	pop	r16
    12d8:	ff 90       	pop	r15
    12da:	ef 90       	pop	r14
    12dc:	df 90       	pop	r13
    12de:	cf 90       	pop	r12
    12e0:	bf 90       	pop	r11
    12e2:	af 90       	pop	r10
    12e4:	9f 90       	pop	r9
    12e6:	8f 90       	pop	r8
    12e8:	7f 90       	pop	r7
    12ea:	6f 90       	pop	r6
    12ec:	5f 90       	pop	r5
    12ee:	4f 90       	pop	r4
    12f0:	3f 90       	pop	r3
    12f2:	2f 90       	pop	r2
    12f4:	08 95       	ret

000012f6 <drawTask>:
 *  checks collisions and performs the proper action based on the types of the
 *  colliding objects.
 *
 * param vParam: This parameter is not used.
 *----------------------------------------------------------------------------*/
void drawTask(void *vParam) {
    12f6:	cf 93       	push	r28
    12f8:	df 93       	push	r29
    12fa:	cd b7       	in	r28, 0x3d	; 61
    12fc:	de b7       	in	r29, 0x3e	; 62
    12fe:	29 97       	sbiw	r28, 0x09	; 9
    1300:	0f b6       	in	r0, 0x3f	; 63
    1302:	f8 94       	cli
    1304:	de bf       	out	0x3e, r29	; 62
    1306:	0f be       	out	0x3f, r0	; 63
    1308:	cd bf       	out	0x3d, r28	; 61
	object *objIter, *objPrev, *astIter, *astPrev, *objTemp;
	xSpriteHandle hit, handle;
	point pos;
	uint8_t size;
	
	vTaskSuspend(updateTaskHandle);
    130a:	80 91 8b 02 	lds	r24, 0x028B
    130e:	90 91 8c 02 	lds	r25, 0x028C
    1312:	0e 94 aa 19 	call	0x3354	; 0x3354 <vTaskSuspend>
	vTaskSuspend(bulletTaskHandle);
    1316:	80 91 8d 02 	lds	r24, 0x028D
    131a:	90 91 8e 02 	lds	r25, 0x028E
    131e:	0e 94 aa 19 	call	0x3354	; 0x3354 <vTaskSuspend>
	vTaskSuspend(inputTaskHandle);
    1322:	80 91 8f 02 	lds	r24, 0x028F
    1326:	90 91 90 02 	lds	r25, 0x0290
    132a:	0e 94 aa 19 	call	0x3354	; 0x3354 <vTaskSuspend>
	init();
    132e:	0e 94 ad 05 	call	0xb5a	; 0xb5a <init>
	vTaskResume(updateTaskHandle);
    1332:	80 91 8b 02 	lds	r24, 0x028B
    1336:	90 91 8c 02 	lds	r25, 0x028C
    133a:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vTaskResume>
	vTaskResume(bulletTaskHandle);
    133e:	80 91 8d 02 	lds	r24, 0x028D
    1342:	90 91 8e 02 	lds	r25, 0x028E
    1346:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vTaskResume>
	vTaskResume(inputTaskHandle);
    134a:	80 91 8f 02 	lds	r24, 0x028F
    134e:	90 91 90 02 	lds	r25, 0x0290
    1352:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vTaskResume>
	
	for (;;) {
		xSemaphoreTake(usartMutex, portMAX_DELAY);
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
    1356:	0f 2e       	mov	r0, r31
    1358:	f8 e6       	ldi	r31, 0x68	; 104
    135a:	4f 2e       	mov	r4, r31
    135c:	f2 e0       	ldi	r31, 0x02	; 2
    135e:	5f 2e       	mov	r5, r31
    1360:	f0 2d       	mov	r31, r0
    1362:	0f 2e       	mov	r0, r31
    1364:	f5 e1       	ldi	r31, 0x15	; 21
    1366:	2f 2e       	mov	r2, r31
    1368:	33 24       	eor	r3, r3
    136a:	f0 2d       	mov	r31, r0
    136c:	24 0c       	add	r2, r4
    136e:	35 1c       	adc	r3, r5
	vTaskResume(updateTaskHandle);
	vTaskResume(bulletTaskHandle);
	vTaskResume(inputTaskHandle);
	
	for (;;) {
		xSemaphoreTake(usartMutex, portMAX_DELAY);
    1370:	80 91 85 02 	lds	r24, 0x0285
    1374:	90 91 86 02 	lds	r25, 0x0286
    1378:	60 e0       	ldi	r22, 0x00	; 0
    137a:	70 e0       	ldi	r23, 0x00	; 0
    137c:	4f ef       	ldi	r20, 0xFF	; 255
    137e:	5f ef       	ldi	r21, 0xFF	; 255
    1380:	20 e0       	ldi	r18, 0x00	; 0
    1382:	0e 94 28 14 	call	0x2850	; 0x2850 <xQueueGenericReceive>
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
    1386:	f1 01       	movw	r30, r2
    1388:	60 81       	ld	r22, Z
    138a:	71 81       	ldd	r23, Z+1	; 0x01
    138c:	f2 01       	movw	r30, r4
    138e:	80 81       	ld	r24, Z
    1390:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <vSpriteSetRotation>
		vSpriteSetPosition(ship.handle, (uint16_t)ship.pos.x, (uint16_t)ship.pos.y);
    1394:	e9 e6       	ldi	r30, 0x69	; 105
    1396:	f2 e0       	ldi	r31, 0x02	; 2
    1398:	60 81       	ld	r22, Z
    139a:	71 81       	ldd	r23, Z+1	; 0x01
    139c:	82 81       	ldd	r24, Z+2	; 0x02
    139e:	93 81       	ldd	r25, Z+3	; 0x03
    13a0:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
    13a4:	6b 01       	movw	r12, r22
    13a6:	7c 01       	movw	r14, r24
    13a8:	ed e6       	ldi	r30, 0x6D	; 109
    13aa:	f2 e0       	ldi	r31, 0x02	; 2
    13ac:	60 81       	ld	r22, Z
    13ae:	71 81       	ldd	r23, Z+1	; 0x01
    13b0:	82 81       	ldd	r24, Z+2	; 0x02
    13b2:	93 81       	ldd	r25, Z+3	; 0x03
    13b4:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
    13b8:	8b 01       	movw	r16, r22
    13ba:	9c 01       	movw	r18, r24
    13bc:	f2 01       	movw	r30, r4
    13be:	80 81       	ld	r24, Z
    13c0:	b6 01       	movw	r22, r12
    13c2:	a8 01       	movw	r20, r16
    13c4:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <vSpriteSetPosition>
		objPrev = NULL;
		objIter = bullets;
    13c8:	e0 90 87 02 	lds	r14, 0x0287
    13cc:	f0 90 88 02 	lds	r15, 0x0288
		while (objIter != NULL) {
    13d0:	e1 14       	cp	r14, r1
    13d2:	f1 04       	cpc	r15, r1
    13d4:	09 f4       	brne	.+2      	; 0x13d8 <drawTask+0xe2>
    13d6:	98 c0       	rjmp	.+304    	; 0x1508 <drawTask+0x212>
	
	for (;;) {
		xSemaphoreTake(usartMutex, portMAX_DELAY);
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
		vSpriteSetPosition(ship.handle, (uint16_t)ship.pos.x, (uint16_t)ship.pos.y);
		objPrev = NULL;
    13d8:	66 24       	eor	r6, r6
    13da:	77 24       	eor	r7, r7
		objIter = bullets;
		while (objIter != NULL) {
			vSpriteSetPosition(objIter->handle, (uint16_t)objIter->pos.x, (uint16_t)objIter->pos.y);
    13dc:	f7 01       	movw	r30, r14
    13de:	61 81       	ldd	r22, Z+1	; 0x01
    13e0:	72 81       	ldd	r23, Z+2	; 0x02
    13e2:	83 81       	ldd	r24, Z+3	; 0x03
    13e4:	94 81       	ldd	r25, Z+4	; 0x04
    13e6:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
    13ea:	4b 01       	movw	r8, r22
    13ec:	5c 01       	movw	r10, r24
    13ee:	f7 01       	movw	r30, r14
    13f0:	65 81       	ldd	r22, Z+5	; 0x05
    13f2:	76 81       	ldd	r23, Z+6	; 0x06
    13f4:	87 81       	ldd	r24, Z+7	; 0x07
    13f6:	90 85       	ldd	r25, Z+8	; 0x08
    13f8:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
    13fc:	8b 01       	movw	r16, r22
    13fe:	9c 01       	movw	r18, r24
    1400:	f7 01       	movw	r30, r14
    1402:	80 81       	ld	r24, Z
    1404:	b4 01       	movw	r22, r8
    1406:	a8 01       	movw	r20, r16
    1408:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <vSpriteSetPosition>
			if (uCollide(objIter->handle, astGroup, &hit, 1) > 0) {
    140c:	f7 01       	movw	r30, r14
    140e:	80 81       	ld	r24, Z
    1410:	60 91 91 02 	lds	r22, 0x0291
    1414:	ae 01       	movw	r20, r28
    1416:	4f 5f       	subi	r20, 0xFF	; 255
    1418:	5f 4f       	sbci	r21, 0xFF	; 255
    141a:	21 e0       	ldi	r18, 0x01	; 1
    141c:	0e 94 80 0c 	call	0x1900	; 0x1900 <uCollide>
    1420:	88 23       	and	r24, r24
    1422:	09 f4       	brne	.+2      	; 0x1426 <drawTask+0x130>
    1424:	67 c0       	rjmp	.+206    	; 0x14f4 <drawTask+0x1fe>
				vSpriteDelete(objIter->handle);
    1426:	f7 01       	movw	r30, r14
    1428:	80 81       	ld	r24, Z
    142a:	0e 94 46 0c 	call	0x188c	; 0x188c <vSpriteDelete>
				
				if (objPrev != NULL) {
    142e:	61 14       	cp	r6, r1
    1430:	71 04       	cpc	r7, r1
    1432:	69 f0       	breq	.+26     	; 0x144e <drawTask+0x158>
					objPrev->next = objIter->next;
    1434:	f7 01       	movw	r30, r14
    1436:	83 8d       	ldd	r24, Z+27	; 0x1b
    1438:	94 8d       	ldd	r25, Z+28	; 0x1c
    143a:	f3 01       	movw	r30, r6
    143c:	94 8f       	std	Z+28, r25	; 0x1c
    143e:	83 8f       	std	Z+27, r24	; 0x1b
					vPortFree(objIter);
    1440:	c7 01       	movw	r24, r14
    1442:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
					objIter = objPrev->next;
    1446:	f3 01       	movw	r30, r6
    1448:	e3 8c       	ldd	r14, Z+27	; 0x1b
    144a:	f4 8c       	ldd	r15, Z+28	; 0x1c
    144c:	0e c0       	rjmp	.+28     	; 0x146a <drawTask+0x174>
				} else {
					bullets = objIter->next;
    144e:	f7 01       	movw	r30, r14
    1450:	83 8d       	ldd	r24, Z+27	; 0x1b
    1452:	94 8d       	ldd	r25, Z+28	; 0x1c
    1454:	90 93 88 02 	sts	0x0288, r25
    1458:	80 93 87 02 	sts	0x0287, r24
					vPortFree(objIter);
    145c:	c7 01       	movw	r24, r14
    145e:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
					objIter = bullets;
    1462:	e0 90 87 02 	lds	r14, 0x0287
    1466:	f0 90 88 02 	lds	r15, 0x0288
				}
				astPrev = NULL;
				astIter = asteroids;
    146a:	c0 90 89 02 	lds	r12, 0x0289
    146e:	d0 90 8a 02 	lds	r13, 0x028A
				while (astIter != NULL) {
    1472:	c1 14       	cp	r12, r1
    1474:	d1 04       	cpc	r13, r1
    1476:	09 f4       	brne	.+2      	; 0x147a <drawTask+0x184>
    1478:	43 c0       	rjmp	.+134    	; 0x1500 <drawTask+0x20a>
					if (astIter->handle == hit) {
    147a:	99 81       	ldd	r25, Y+1	; 0x01
    147c:	f6 01       	movw	r30, r12
    147e:	80 81       	ld	r24, Z
    1480:	89 17       	cp	r24, r25
    1482:	89 f5       	brne	.+98     	; 0x14e6 <drawTask+0x1f0>
    1484:	f3 c0       	rjmp	.+486    	; 0x166c <drawTask+0x376>
    1486:	f8 01       	movw	r30, r16
    1488:	80 81       	ld	r24, Z
    148a:	89 17       	cp	r24, r25
    148c:	59 f5       	brne	.+86     	; 0x14e4 <drawTask+0x1ee>
						spawnAsteroid(&pos, size);
						break;					
						
					} else {
						astPrev = astIter;
						astIter = astIter->next;
    148e:	48 01       	movw	r8, r16
				}
				astPrev = NULL;
				astIter = asteroids;
				while (astIter != NULL) {
					if (astIter->handle == hit) {
						pos = astIter->pos;
    1490:	de 01       	movw	r26, r28
    1492:	12 96       	adiw	r26, 0x02	; 2
    1494:	31 96       	adiw	r30, 0x01	; 1
    1496:	88 e0       	ldi	r24, 0x08	; 8
    1498:	01 90       	ld	r0, Z+
    149a:	0d 92       	st	X+, r0
    149c:	81 50       	subi	r24, 0x01	; 1
    149e:	e1 f7       	brne	.-8      	; 0x1498 <drawTask+0x1a2>
						size = astIter->size;
    14a0:	f4 01       	movw	r30, r8
    14a2:	b0 8c       	ldd	r11, Z+24	; 0x18
						vSpriteDelete(astIter->handle);
    14a4:	80 81       	ld	r24, Z
    14a6:	0e 94 46 0c 	call	0x188c	; 0x188c <vSpriteDelete>
						if (astPrev != NULL) {
    14aa:	c1 14       	cp	r12, r1
    14ac:	d1 04       	cpc	r13, r1
    14ae:	51 f0       	breq	.+20     	; 0x14c4 <drawTask+0x1ce>
					        astPrev->next = astIter->next;
    14b0:	f4 01       	movw	r30, r8
    14b2:	83 8d       	ldd	r24, Z+27	; 0x1b
    14b4:	94 8d       	ldd	r25, Z+28	; 0x1c
    14b6:	f6 01       	movw	r30, r12
    14b8:	94 8f       	std	Z+28, r25	; 0x1c
    14ba:	83 8f       	std	Z+27, r24	; 0x1b
					        vPortFree(astIter);
    14bc:	c4 01       	movw	r24, r8
    14be:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
    14c2:	0a c0       	rjmp	.+20     	; 0x14d8 <drawTask+0x1e2>
					        astIter = astPrev->next;
				        } else {
					        asteroids = astIter->next;
    14c4:	f8 01       	movw	r30, r16
    14c6:	83 8d       	ldd	r24, Z+27	; 0x1b
    14c8:	94 8d       	ldd	r25, Z+28	; 0x1c
    14ca:	90 93 8a 02 	sts	0x028A, r25
    14ce:	80 93 89 02 	sts	0x0289, r24
					        vPortFree(astIter);
    14d2:	c8 01       	movw	r24, r16
    14d4:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
				        }
						spawnAsteroid(&pos, size);
    14d8:	ce 01       	movw	r24, r28
    14da:	02 96       	adiw	r24, 0x02	; 2
    14dc:	6b 2d       	mov	r22, r11
    14de:	0e 94 35 08 	call	0x106a	; 0x106a <spawnAsteroid>
						break;					
    14e2:	0e c0       	rjmp	.+28     	; 0x1500 <drawTask+0x20a>
						
					} else {
						astPrev = astIter;
						astIter = astIter->next;
    14e4:	68 01       	movw	r12, r16
    14e6:	f6 01       	movw	r30, r12
    14e8:	03 8d       	ldd	r16, Z+27	; 0x1b
    14ea:	14 8d       	ldd	r17, Z+28	; 0x1c
					vPortFree(objIter);
					objIter = bullets;
				}
				astPrev = NULL;
				astIter = asteroids;
				while (astIter != NULL) {
    14ec:	01 15       	cp	r16, r1
    14ee:	11 05       	cpc	r17, r1
    14f0:	51 f6       	brne	.-108    	; 0x1486 <drawTask+0x190>
    14f2:	06 c0       	rjmp	.+12     	; 0x1500 <drawTask+0x20a>
						astIter = astIter->next;
					}
				}
			} else {
				objPrev = objIter;
			   objIter = objIter->next;
    14f4:	f7 01       	movw	r30, r14
    14f6:	93 8d       	ldd	r25, Z+27	; 0x1b
    14f8:	84 8d       	ldd	r24, Z+28	; 0x1c
    14fa:	37 01       	movw	r6, r14
    14fc:	e9 2e       	mov	r14, r25
    14fe:	f8 2e       	mov	r15, r24
		xSemaphoreTake(usartMutex, portMAX_DELAY);
		vSpriteSetRotation(ship.handle, (uint16_t)ship.angle);
		vSpriteSetPosition(ship.handle, (uint16_t)ship.pos.x, (uint16_t)ship.pos.y);
		objPrev = NULL;
		objIter = bullets;
		while (objIter != NULL) {
    1500:	e1 14       	cp	r14, r1
    1502:	f1 04       	cpc	r15, r1
    1504:	09 f0       	breq	.+2      	; 0x1508 <drawTask+0x212>
    1506:	6a cf       	rjmp	.-300    	; 0x13dc <drawTask+0xe6>
				objPrev = objIter;
			   objIter = objIter->next;
			}			
		}
		
		objIter = asteroids;
    1508:	00 91 89 02 	lds	r16, 0x0289
    150c:	10 91 8a 02 	lds	r17, 0x028A
		while (objIter != NULL) {
    1510:	01 15       	cp	r16, r1
    1512:	11 05       	cpc	r17, r1
    1514:	21 f1       	breq	.+72     	; 0x155e <drawTask+0x268>
			vSpriteSetPosition(objIter->handle, (uint16_t)objIter->pos.x, (uint16_t)objIter->pos.y);
    1516:	f8 01       	movw	r30, r16
    1518:	61 81       	ldd	r22, Z+1	; 0x01
    151a:	72 81       	ldd	r23, Z+2	; 0x02
    151c:	83 81       	ldd	r24, Z+3	; 0x03
    151e:	94 81       	ldd	r25, Z+4	; 0x04
    1520:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
    1524:	4b 01       	movw	r8, r22
    1526:	5c 01       	movw	r10, r24
    1528:	f8 01       	movw	r30, r16
    152a:	65 81       	ldd	r22, Z+5	; 0x05
    152c:	76 81       	ldd	r23, Z+6	; 0x06
    152e:	87 81       	ldd	r24, Z+7	; 0x07
    1530:	90 85       	ldd	r25, Z+8	; 0x08
    1532:	0e 94 b7 1c 	call	0x396e	; 0x396e <__fixunssfsi>
    1536:	6b 01       	movw	r12, r22
    1538:	7c 01       	movw	r14, r24
    153a:	f8 01       	movw	r30, r16
    153c:	80 81       	ld	r24, Z
    153e:	b4 01       	movw	r22, r8
    1540:	a6 01       	movw	r20, r12
    1542:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <vSpriteSetPosition>
			vSpriteSetRotation(objIter->handle, objIter->angle);
    1546:	f8 01       	movw	r30, r16
    1548:	65 89       	ldd	r22, Z+21	; 0x15
    154a:	76 89       	ldd	r23, Z+22	; 0x16
    154c:	80 81       	ld	r24, Z
    154e:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <vSpriteSetRotation>
			objIter = objIter->next;
    1552:	f8 01       	movw	r30, r16
    1554:	03 8d       	ldd	r16, Z+27	; 0x1b
    1556:	14 8d       	ldd	r17, Z+28	; 0x1c
			   objIter = objIter->next;
			}			
		}
		
		objIter = asteroids;
		while (objIter != NULL) {
    1558:	01 15       	cp	r16, r1
    155a:	11 05       	cpc	r17, r1
    155c:	e1 f6       	brne	.-72     	; 0x1516 <drawTask+0x220>
			vSpriteSetPosition(objIter->handle, (uint16_t)objIter->pos.x, (uint16_t)objIter->pos.y);
			vSpriteSetRotation(objIter->handle, objIter->angle);
			objIter = objIter->next;
		}			
				
		if (uCollide(ship.handle, astGroup, &hit, 1) > 0 || asteroids == NULL) {
    155e:	f2 01       	movw	r30, r4
    1560:	80 81       	ld	r24, Z
    1562:	60 91 91 02 	lds	r22, 0x0291
    1566:	ae 01       	movw	r20, r28
    1568:	4f 5f       	subi	r20, 0xFF	; 255
    156a:	5f 4f       	sbci	r21, 0xFF	; 255
    156c:	21 e0       	ldi	r18, 0x01	; 1
    156e:	0e 94 80 0c 	call	0x1900	; 0x1900 <uCollide>
    1572:	88 23       	and	r24, r24
    1574:	39 f4       	brne	.+14     	; 0x1584 <drawTask+0x28e>
    1576:	80 91 89 02 	lds	r24, 0x0289
    157a:	90 91 8a 02 	lds	r25, 0x028A
    157e:	00 97       	sbiw	r24, 0x00	; 0
    1580:	09 f0       	breq	.+2      	; 0x1584 <drawTask+0x28e>
    1582:	64 c0       	rjmp	.+200    	; 0x164c <drawTask+0x356>
			vTaskSuspend(updateTaskHandle);
    1584:	80 91 8b 02 	lds	r24, 0x028B
    1588:	90 91 8c 02 	lds	r25, 0x028C
    158c:	0e 94 aa 19 	call	0x3354	; 0x3354 <vTaskSuspend>
			vTaskSuspend(bulletTaskHandle);
    1590:	80 91 8d 02 	lds	r24, 0x028D
    1594:	90 91 8e 02 	lds	r25, 0x028E
    1598:	0e 94 aa 19 	call	0x3354	; 0x3354 <vTaskSuspend>
			vTaskSuspend(inputTaskHandle);
    159c:	80 91 8f 02 	lds	r24, 0x028F
    15a0:	90 91 90 02 	lds	r25, 0x0290
    15a4:	0e 94 aa 19 	call	0x3354	; 0x3354 <vTaskSuspend>
			
			if (asteroids == NULL)
    15a8:	80 91 89 02 	lds	r24, 0x0289
    15ac:	90 91 8a 02 	lds	r25, 0x028A
    15b0:	00 97       	sbiw	r24, 0x00	; 0
    15b2:	c1 f4       	brne	.+48     	; 0x15e4 <drawTask+0x2ee>
			   handle = xSpriteCreate("win.png", SCREEN_W>>1, SCREEN_H>>1, 20, SCREEN_W>>1, SCREEN_H>>1, 100);
    15b4:	88 e2       	ldi	r24, 0x28	; 40
    15b6:	92 e0       	ldi	r25, 0x02	; 2
    15b8:	60 e9       	ldi	r22, 0x90	; 144
    15ba:	71 e0       	ldi	r23, 0x01	; 1
    15bc:	4c e2       	ldi	r20, 0x2C	; 44
    15be:	51 e0       	ldi	r21, 0x01	; 1
    15c0:	24 e1       	ldi	r18, 0x14	; 20
    15c2:	30 e0       	ldi	r19, 0x00	; 0
    15c4:	00 e9       	ldi	r16, 0x90	; 144
    15c6:	11 e0       	ldi	r17, 0x01	; 1
    15c8:	0f 2e       	mov	r0, r31
    15ca:	fc e2       	ldi	r31, 0x2C	; 44
    15cc:	ef 2e       	mov	r14, r31
    15ce:	f1 e0       	ldi	r31, 0x01	; 1
    15d0:	ff 2e       	mov	r15, r31
    15d2:	f0 2d       	mov	r31, r0
    15d4:	0f 2e       	mov	r0, r31
    15d6:	f4 e6       	ldi	r31, 0x64	; 100
    15d8:	cf 2e       	mov	r12, r31
    15da:	f0 2d       	mov	r31, r0
    15dc:	0e 94 84 0b 	call	0x1708	; 0x1708 <xSpriteCreate>
    15e0:	08 2f       	mov	r16, r24
    15e2:	17 c0       	rjmp	.+46     	; 0x1612 <drawTask+0x31c>
			else
			   handle = xSpriteCreate("lose.png", SCREEN_W>>1, SCREEN_H>>1, 0, SCREEN_W>>1, SCREEN_H>>1, 100);
    15e4:	80 e3       	ldi	r24, 0x30	; 48
    15e6:	92 e0       	ldi	r25, 0x02	; 2
    15e8:	60 e9       	ldi	r22, 0x90	; 144
    15ea:	71 e0       	ldi	r23, 0x01	; 1
    15ec:	4c e2       	ldi	r20, 0x2C	; 44
    15ee:	51 e0       	ldi	r21, 0x01	; 1
    15f0:	20 e0       	ldi	r18, 0x00	; 0
    15f2:	30 e0       	ldi	r19, 0x00	; 0
    15f4:	00 e9       	ldi	r16, 0x90	; 144
    15f6:	11 e0       	ldi	r17, 0x01	; 1
    15f8:	0f 2e       	mov	r0, r31
    15fa:	fc e2       	ldi	r31, 0x2C	; 44
    15fc:	ef 2e       	mov	r14, r31
    15fe:	f1 e0       	ldi	r31, 0x01	; 1
    1600:	ff 2e       	mov	r15, r31
    1602:	f0 2d       	mov	r31, r0
    1604:	0f 2e       	mov	r0, r31
    1606:	f4 e6       	ldi	r31, 0x64	; 100
    1608:	cf 2e       	mov	r12, r31
    160a:	f0 2d       	mov	r31, r0
    160c:	0e 94 84 0b 	call	0x1708	; 0x1708 <xSpriteCreate>
    1610:	08 2f       	mov	r16, r24
				
			vTaskDelay(3000 / portTICK_RATE_MS);
    1612:	88 eb       	ldi	r24, 0xB8	; 184
    1614:	9b e0       	ldi	r25, 0x0B	; 11
    1616:	0e 94 e3 18 	call	0x31c6	; 0x31c6 <vTaskDelay>
			vSpriteDelete(handle);
    161a:	80 2f       	mov	r24, r16
    161c:	0e 94 46 0c 	call	0x188c	; 0x188c <vSpriteDelete>
			
			reset();
    1620:	0e 94 8f 04 	call	0x91e	; 0x91e <reset>
			init();
    1624:	0e 94 ad 05 	call	0xb5a	; 0xb5a <init>
			
			vTaskResume(updateTaskHandle);
    1628:	80 91 8b 02 	lds	r24, 0x028B
    162c:	90 91 8c 02 	lds	r25, 0x028C
    1630:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vTaskResume>
			vTaskResume(bulletTaskHandle);
    1634:	80 91 8d 02 	lds	r24, 0x028D
    1638:	90 91 8e 02 	lds	r25, 0x028E
    163c:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vTaskResume>
			vTaskResume(inputTaskHandle);
    1640:	80 91 8f 02 	lds	r24, 0x028F
    1644:	90 91 90 02 	lds	r25, 0x0290
    1648:	0e 94 b8 16 	call	0x2d70	; 0x2d70 <vTaskResume>
		}
		
		xSemaphoreGive(usartMutex);
    164c:	80 91 85 02 	lds	r24, 0x0285
    1650:	90 91 86 02 	lds	r25, 0x0286
    1654:	60 e0       	ldi	r22, 0x00	; 0
    1656:	70 e0       	ldi	r23, 0x00	; 0
    1658:	40 e0       	ldi	r20, 0x00	; 0
    165a:	50 e0       	ldi	r21, 0x00	; 0
    165c:	20 e0       	ldi	r18, 0x00	; 0
    165e:	0e 94 2b 13 	call	0x2656	; 0x2656 <xQueueGenericSend>
		vTaskDelay(FRAME_DELAY_MS / portTICK_RATE_MS);
    1662:	8a e0       	ldi	r24, 0x0A	; 10
    1664:	90 e0       	ldi	r25, 0x00	; 0
    1666:	0e 94 e3 18 	call	0x31c6	; 0x31c6 <vTaskDelay>
	}
    166a:	82 ce       	rjmp	.-764    	; 0x1370 <drawTask+0x7a>
				}
				astPrev = NULL;
				astIter = asteroids;
				while (astIter != NULL) {
					if (astIter->handle == hit) {
						pos = astIter->pos;
    166c:	de 01       	movw	r26, r28
    166e:	12 96       	adiw	r26, 0x02	; 2
    1670:	f6 01       	movw	r30, r12
    1672:	31 96       	adiw	r30, 0x01	; 1
    1674:	88 e0       	ldi	r24, 0x08	; 8
    1676:	01 90       	ld	r0, Z+
    1678:	0d 92       	st	X+, r0
    167a:	81 50       	subi	r24, 0x01	; 1
    167c:	e1 f7       	brne	.-8      	; 0x1676 <drawTask+0x380>
						size = astIter->size;
    167e:	f6 01       	movw	r30, r12
    1680:	b0 8c       	ldd	r11, Z+24	; 0x18
						vSpriteDelete(astIter->handle);
    1682:	80 81       	ld	r24, Z
    1684:	0e 94 46 0c 	call	0x188c	; 0x188c <vSpriteDelete>
					bullets = objIter->next;
					vPortFree(objIter);
					objIter = bullets;
				}
				astPrev = NULL;
				astIter = asteroids;
    1688:	86 01       	movw	r16, r12
    168a:	1c cf       	rjmp	.-456    	; 0x14c4 <drawTask+0x1ce>

0000168c <vPrint>:
* Description: Prints the supplied string to the python terminal.  Useful for 
*  debugging.
*
* param s: The string to print out.
*******************************************************************************/
void vPrint(const char *s) {
    168c:	cf 93       	push	r28
    168e:	df 93       	push	r29
    1690:	ec 01       	movw	r28, r24
	USART_Write(PYTHON_PRINT);
    1692:	8b e0       	ldi	r24, 0x0B	; 11
    1694:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	while (*s != '\0') {
    1698:	88 81       	ld	r24, Y
    169a:	88 23       	and	r24, r24
    169c:	31 f0       	breq	.+12     	; 0x16aa <vPrint+0x1e>
* Description: Prints the supplied string to the python terminal.  Useful for 
*  debugging.
*
* param s: The string to print out.
*******************************************************************************/
void vPrint(const char *s) {
    169e:	21 96       	adiw	r28, 0x01	; 1
	USART_Write(PYTHON_PRINT);
	while (*s != '\0') {
		USART_Write((uint8_t)*s++);
    16a0:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
*
* param s: The string to print out.
*******************************************************************************/
void vPrint(const char *s) {
	USART_Write(PYTHON_PRINT);
	while (*s != '\0') {
    16a4:	89 91       	ld	r24, Y+
    16a6:	88 23       	and	r24, r24
    16a8:	d9 f7       	brne	.-10     	; 0x16a0 <vPrint+0x14>
		USART_Write((uint8_t)*s++);
	}
	USART_Write(0x00);  /* string is null-terminated */
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
}
    16b0:	df 91       	pop	r29
    16b2:	cf 91       	pop	r28
    16b4:	08 95       	ret

000016b6 <vWindowCreate>:
*  context and opens a window for drawing with the specified dimensions.
*
* param width: Desired width of the window in pixels
* param height: Desired height of the window in pixels
*******************************************************************************/
void vWindowCreate(uint16_t width, uint16_t height) {
    16b6:	0f 93       	push	r16
    16b8:	1f 93       	push	r17
    16ba:	cf 93       	push	r28
    16bc:	df 93       	push	r29
    16be:	18 2f       	mov	r17, r24
    16c0:	09 2f       	mov	r16, r25
    16c2:	c6 2f       	mov	r28, r22
    16c4:	d7 2f       	mov	r29, r23
	USART_Init(BAUD_RATE, configCPU_CLOCK_HZ);
    16c6:	80 e0       	ldi	r24, 0x00	; 0
    16c8:	96 e9       	ldi	r25, 0x96	; 150
    16ca:	40 e0       	ldi	r20, 0x00	; 0
    16cc:	54 e2       	ldi	r21, 0x24	; 36
    16ce:	64 ef       	ldi	r22, 0xF4	; 244
    16d0:	70 e0       	ldi	r23, 0x00	; 0
    16d2:	0e 94 68 1b 	call	0x36d0	; 0x36d0 <USART_Init>

	USART_Read();
    16d6:	0e 94 c1 1b 	call	0x3782	; 0x3782 <USART_Read>
	USART_Write_Unprotected(0xFF);
    16da:	8f ef       	ldi	r24, 0xFF	; 255
    16dc:	0e 94 b9 1b 	call	0x3772	; 0x3772 <USART_Write_Unprotected>
	
	USART_Write_Unprotected(CREATE_WINDOW);
    16e0:	8a e0       	ldi	r24, 0x0A	; 10
    16e2:	0e 94 b9 1b 	call	0x3772	; 0x3772 <USART_Write_Unprotected>
	USART_Write_Unprotected(width >> 8);
    16e6:	80 2f       	mov	r24, r16
    16e8:	0e 94 b9 1b 	call	0x3772	; 0x3772 <USART_Write_Unprotected>
	USART_Write_Unprotected(width & 0x00FF);
    16ec:	81 2f       	mov	r24, r17
    16ee:	0e 94 b9 1b 	call	0x3772	; 0x3772 <USART_Write_Unprotected>
	USART_Write_Unprotected(height >> 8);
    16f2:	8d 2f       	mov	r24, r29
    16f4:	0e 94 b9 1b 	call	0x3772	; 0x3772 <USART_Write_Unprotected>
	USART_Write_Unprotected(height & 0x00FF);
    16f8:	8c 2f       	mov	r24, r28
    16fa:	0e 94 b9 1b 	call	0x3772	; 0x3772 <USART_Write_Unprotected>
}
    16fe:	df 91       	pop	r29
    1700:	cf 91       	pop	r28
    1702:	1f 91       	pop	r17
    1704:	0f 91       	pop	r16
    1706:	08 95       	ret

00001708 <xSpriteCreate>:
* param height: Initial, unrotated height of the sprite in pixels
* param depth: Initial draw depth of the sprite (larger numbers are in front)
* return: A valid handle to the new sprite on success; ERROR_HANDLE otherwise
*******************************************************************************/
xSpriteHandle xSpriteCreate(const char *filename, uint16_t xPos, uint16_t yPos,
 uint16_t rAngle, uint16_t width, uint16_t height, uint8_t depth) {
    1708:	7f 92       	push	r7
    170a:	8f 92       	push	r8
    170c:	9f 92       	push	r9
    170e:	af 92       	push	r10
    1710:	bf 92       	push	r11
    1712:	cf 92       	push	r12
    1714:	df 92       	push	r13
    1716:	ef 92       	push	r14
    1718:	ff 92       	push	r15
    171a:	0f 93       	push	r16
    171c:	1f 93       	push	r17
    171e:	cf 93       	push	r28
    1720:	df 93       	push	r29
    1722:	ec 01       	movw	r28, r24
    1724:	b6 2e       	mov	r11, r22
    1726:	d7 2e       	mov	r13, r23
    1728:	94 2e       	mov	r9, r20
    172a:	a5 2e       	mov	r10, r21
    172c:	72 2e       	mov	r7, r18
    172e:	83 2e       	mov	r8, r19
	
	USART_Write(CREATE_SPRITE);
    1730:	81 e0       	ldi	r24, 0x01	; 1
    1732:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>

	while (*filename != '\0') {
    1736:	88 81       	ld	r24, Y
    1738:	88 23       	and	r24, r24
    173a:	31 f0       	breq	.+12     	; 0x1748 <xSpriteCreate+0x40>
* param width: Initial, unrotated width of the sprite in pixels
* param height: Initial, unrotated height of the sprite in pixels
* param depth: Initial draw depth of the sprite (larger numbers are in front)
* return: A valid handle to the new sprite on success; ERROR_HANDLE otherwise
*******************************************************************************/
xSpriteHandle xSpriteCreate(const char *filename, uint16_t xPos, uint16_t yPos,
    173c:	21 96       	adiw	r28, 0x01	; 1
 uint16_t rAngle, uint16_t width, uint16_t height, uint8_t depth) {
	
	USART_Write(CREATE_SPRITE);

	while (*filename != '\0') {
		USART_Write((uint8_t)*filename++);
    173e:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
xSpriteHandle xSpriteCreate(const char *filename, uint16_t xPos, uint16_t yPos,
 uint16_t rAngle, uint16_t width, uint16_t height, uint8_t depth) {
	
	USART_Write(CREATE_SPRITE);

	while (*filename != '\0') {
    1742:	89 91       	ld	r24, Y+
    1744:	88 23       	and	r24, r24
    1746:	d9 f7       	brne	.-10     	; 0x173e <xSpriteCreate+0x36>
		USART_Write((uint8_t)*filename++);
	}
	USART_Write(0x00);  /* Filename is null-terminated */
    1748:	80 e0       	ldi	r24, 0x00	; 0
    174a:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>

	USART_Write(xPos >> 8);
    174e:	8d 2d       	mov	r24, r13
    1750:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(xPos & 0x00FF);
    1754:	8b 2d       	mov	r24, r11
    1756:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(yPos >> 8);
    175a:	8a 2d       	mov	r24, r10
    175c:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(yPos & 0x00FF);
    1760:	89 2d       	mov	r24, r9
    1762:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(rAngle >> 8);
    1766:	88 2d       	mov	r24, r8
    1768:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(rAngle & 0x00FF);
    176c:	87 2d       	mov	r24, r7
    176e:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(width >> 8);
    1772:	81 2f       	mov	r24, r17
    1774:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(width & 0x00FF);
    1778:	80 2f       	mov	r24, r16
    177a:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(height >> 8);
    177e:	8f 2d       	mov	r24, r15
    1780:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(height & 0x00FF);
    1784:	8e 2d       	mov	r24, r14
    1786:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(depth);
    178a:	8c 2d       	mov	r24, r12
    178c:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	
	PORTA = 0xAA;
    1790:	8a ea       	ldi	r24, 0xAA	; 170
    1792:	82 b9       	out	0x02, r24	; 2
	xSpriteHandle result = (xSpriteHandle)USART_Read();
    1794:	0e 94 c1 1b 	call	0x3782	; 0x3782 <USART_Read>
	PORTA = 0xFF;
    1798:	9f ef       	ldi	r25, 0xFF	; 255
    179a:	92 b9       	out	0x02, r25	; 2
	
	return result;
}
    179c:	df 91       	pop	r29
    179e:	cf 91       	pop	r28
    17a0:	1f 91       	pop	r17
    17a2:	0f 91       	pop	r16
    17a4:	ff 90       	pop	r15
    17a6:	ef 90       	pop	r14
    17a8:	df 90       	pop	r13
    17aa:	cf 90       	pop	r12
    17ac:	bf 90       	pop	r11
    17ae:	af 90       	pop	r10
    17b0:	9f 90       	pop	r9
    17b2:	8f 90       	pop	r8
    17b4:	7f 90       	pop	r7
    17b6:	08 95       	ret

000017b8 <vSpriteSetPosition>:
*
* param sprite: The handle to the sprite
* param x: New x-position of the sprite's center in window coordinates
* param y: New y-position of the sprite's center in window coordinates
*******************************************************************************/
void vSpriteSetPosition(xSpriteHandle sprite, uint16_t x, uint16_t y) {
    17b8:	ff 92       	push	r15
    17ba:	0f 93       	push	r16
    17bc:	1f 93       	push	r17
    17be:	cf 93       	push	r28
    17c0:	df 93       	push	r29
    17c2:	f8 2e       	mov	r15, r24
    17c4:	16 2f       	mov	r17, r22
    17c6:	07 2f       	mov	r16, r23
    17c8:	c4 2f       	mov	r28, r20
    17ca:	d5 2f       	mov	r29, r21
	USART_Write(SET_POS);
    17cc:	82 e0       	ldi	r24, 0x02	; 2
    17ce:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(sprite);
    17d2:	8f 2d       	mov	r24, r15
    17d4:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(x >> 8);
    17d8:	80 2f       	mov	r24, r16
    17da:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(x & 0x00FF);
    17de:	81 2f       	mov	r24, r17
    17e0:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(y >> 8);
    17e4:	8d 2f       	mov	r24, r29
    17e6:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(y & 0x00FF);
    17ea:	8c 2f       	mov	r24, r28
    17ec:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
}
    17f0:	df 91       	pop	r29
    17f2:	cf 91       	pop	r28
    17f4:	1f 91       	pop	r17
    17f6:	0f 91       	pop	r16
    17f8:	ff 90       	pop	r15
    17fa:	08 95       	ret

000017fc <vSpriteSetRotation>:
* Description: Sets the given sprite's rotation.
*
* param sprite: The handle to the sprite
* param angle: Angle in degrees to rotate the sprite CCW about its center
*******************************************************************************/
void vSpriteSetRotation(xSpriteHandle sprite, uint16_t angle) {
    17fc:	1f 93       	push	r17
    17fe:	cf 93       	push	r28
    1800:	df 93       	push	r29
    1802:	18 2f       	mov	r17, r24
    1804:	c6 2f       	mov	r28, r22
    1806:	d7 2f       	mov	r29, r23
	USART_Write(SET_ROT);
    1808:	83 e0       	ldi	r24, 0x03	; 3
    180a:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(sprite);
    180e:	81 2f       	mov	r24, r17
    1810:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(angle >> 8);
    1814:	8d 2f       	mov	r24, r29
    1816:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(angle & 0x00FF);
    181a:	8c 2f       	mov	r24, r28
    181c:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
}
    1820:	df 91       	pop	r29
    1822:	cf 91       	pop	r28
    1824:	1f 91       	pop	r17
    1826:	08 95       	ret

00001828 <vSpriteSetSize>:
*
* param sprite: The handle to the sprite
* param width: New width of the sprite in pixels before applying rotation
* param height: New height of the sprite in pixels before applying rotation
*******************************************************************************/
void vSpriteSetSize(xSpriteHandle sprite, uint16_t width, uint16_t height) {
    1828:	ff 92       	push	r15
    182a:	0f 93       	push	r16
    182c:	1f 93       	push	r17
    182e:	cf 93       	push	r28
    1830:	df 93       	push	r29
    1832:	f8 2e       	mov	r15, r24
    1834:	16 2f       	mov	r17, r22
    1836:	07 2f       	mov	r16, r23
    1838:	c4 2f       	mov	r28, r20
    183a:	d5 2f       	mov	r29, r21
	USART_Write(SET_SIZE);
    183c:	8d e0       	ldi	r24, 0x0D	; 13
    183e:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(sprite);
    1842:	8f 2d       	mov	r24, r15
    1844:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(width >> 8);
    1848:	80 2f       	mov	r24, r16
    184a:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(width & 0x00FF);
    184e:	81 2f       	mov	r24, r17
    1850:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(height >> 8);
    1854:	8d 2f       	mov	r24, r29
    1856:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(height & 0x00FF);
    185a:	8c 2f       	mov	r24, r28
    185c:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
}
    1860:	df 91       	pop	r29
    1862:	cf 91       	pop	r28
    1864:	1f 91       	pop	r17
    1866:	0f 91       	pop	r16
    1868:	ff 90       	pop	r15
    186a:	08 95       	ret

0000186c <vSpriteSetDepth>:
* Description: Sets the draw depth of the given sprite.
*
* param sprite: The handle to the sprite
* param depth: New draw depth (larger depths are in front of smaller depths)
*******************************************************************************/
void vSpriteSetDepth(xSpriteHandle sprite, uint8_t depth) {
    186c:	cf 93       	push	r28
    186e:	df 93       	push	r29
    1870:	d8 2f       	mov	r29, r24
    1872:	c6 2f       	mov	r28, r22
	USART_Write(SET_ORDER);
    1874:	8c e0       	ldi	r24, 0x0C	; 12
    1876:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(sprite);
    187a:	8d 2f       	mov	r24, r29
    187c:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(depth);
    1880:	8c 2f       	mov	r24, r28
    1882:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
}
    1886:	df 91       	pop	r29
    1888:	cf 91       	pop	r28
    188a:	08 95       	ret

0000188c <vSpriteDelete>:
* Description: Removes the sprite from the window and invalidates the given
*  handle.
*
* param sprite: The handle to the sprite to be deleted
*******************************************************************************/
void vSpriteDelete(xSpriteHandle sprite) {
    188c:	cf 93       	push	r28
    188e:	c8 2f       	mov	r28, r24
	USART_Write(DELETE_SPRITE);
    1890:	84 e0       	ldi	r24, 0x04	; 4
    1892:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(sprite);
    1896:	8c 2f       	mov	r24, r28
    1898:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
}
    189c:	cf 91       	pop	r28
    189e:	08 95       	ret

000018a0 <xGroupCreate>:
*  collision tests (see bCollide).
*
* return: A valid handle to the new group on success; ERROR_HANDLE otherwise
*******************************************************************************/
xGroupHandle xGroupCreate(void) {
	USART_Write(CREATE_GROUP);
    18a0:	85 e0       	ldi	r24, 0x05	; 5
    18a2:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	xGroupHandle result = (xGroupHandle)USART_Read();
    18a6:	0e 94 c1 1b 	call	0x3782	; 0x3782 <USART_Read>
	
	return result;
}
    18aa:	08 95       	ret

000018ac <vGroupAddSprite>:
* Description: Adds the given sprite to the given group.
*
* param group: The handle to the group to add the sprite to
* param sprite: The handle to the sprite to add to the group
*******************************************************************************/
void vGroupAddSprite(xGroupHandle group, xSpriteHandle sprite) {
    18ac:	cf 93       	push	r28
    18ae:	df 93       	push	r29
    18b0:	d8 2f       	mov	r29, r24
    18b2:	c6 2f       	mov	r28, r22
	USART_Write(ADD_TO_GROUP);
    18b4:	86 e0       	ldi	r24, 0x06	; 6
    18b6:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(group);
    18ba:	8d 2f       	mov	r24, r29
    18bc:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(sprite);
    18c0:	8c 2f       	mov	r24, r28
    18c2:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
}
    18c6:	df 91       	pop	r29
    18c8:	cf 91       	pop	r28
    18ca:	08 95       	ret

000018cc <vGroupRemoveSprite>:
* Description: Removes the given sprite from the given group.
*
* param group: The handle to the group to remove the sprite from
* param sprite: The handle to the sprite to remove from the group
*******************************************************************************/
void vGroupRemoveSprite(xGroupHandle group, xSpriteHandle sprite) {
    18cc:	cf 93       	push	r28
    18ce:	df 93       	push	r29
    18d0:	d8 2f       	mov	r29, r24
    18d2:	c6 2f       	mov	r28, r22
	USART_Write(REMOVE_FROM_GROUP);
    18d4:	87 e0       	ldi	r24, 0x07	; 7
    18d6:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(group);
    18da:	8d 2f       	mov	r24, r29
    18dc:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(sprite);
    18e0:	8c 2f       	mov	r24, r28
    18e2:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
}
    18e6:	df 91       	pop	r29
    18e8:	cf 91       	pop	r28
    18ea:	08 95       	ret

000018ec <vGroupDelete>:
* Description: Invalidates the given group handle and removes all the sprites
*  it contains from it.
*
* param group: The handle to the group to be deleted
*******************************************************************************/
void vGroupDelete(xGroupHandle group) {
    18ec:	cf 93       	push	r28
    18ee:	c8 2f       	mov	r28, r24
	USART_Write(DELETE_GROUP);
    18f0:	88 e0       	ldi	r24, 0x08	; 8
    18f2:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(group);
    18f6:	8c 2f       	mov	r24, r28
    18f8:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
}
    18fc:	cf 91       	pop	r28
    18fe:	08 95       	ret

00001900 <uCollide>:
*  sprite collided with
* param hitsSize: The size of the hits array
* return: The number of hits stored in the hits array
*******************************************************************************/
uint8_t uCollide(xSpriteHandle sprite, xGroupHandle group,
 xSpriteHandle hits[], uint8_t hitsSize) {
    1900:	ff 92       	push	r15
    1902:	0f 93       	push	r16
    1904:	1f 93       	push	r17
    1906:	cf 93       	push	r28
    1908:	df 93       	push	r29
    190a:	d8 2f       	mov	r29, r24
    190c:	c6 2f       	mov	r28, r22
    190e:	04 2f       	mov	r16, r20
    1910:	f5 2e       	mov	r15, r21
    1912:	12 2f       	mov	r17, r18
	uint8_t hitCount = 0;
	
	USART_Write(COLLIDE);
    1914:	89 e0       	ldi	r24, 0x09	; 9
    1916:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(sprite);
    191a:	8d 2f       	mov	r24, r29
    191c:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	USART_Write(group);
    1920:	8c 2f       	mov	r24, r28
    1922:	0e 94 a3 1b 	call	0x3746	; 0x3746 <USART_Write>
	
	while (hitCount < hitsSize) {
    1926:	11 23       	and	r17, r17
    1928:	61 f0       	breq	.+24     	; 0x1942 <uCollide+0x42>
    192a:	c0 2f       	mov	r28, r16
    192c:	df 2d       	mov	r29, r15
* param hitsSize: The size of the hits array
* return: The number of hits stored in the hits array
*******************************************************************************/
uint8_t uCollide(xSpriteHandle sprite, xGroupHandle group,
 xSpriteHandle hits[], uint8_t hitsSize) {
	uint8_t hitCount = 0;
    192e:	00 e0       	ldi	r16, 0x00	; 0
	USART_Write(COLLIDE);
	USART_Write(sprite);
	USART_Write(group);
	
	while (hitCount < hitsSize) {
		hits[hitCount] = USART_Read();
    1930:	0e 94 c1 1b 	call	0x3782	; 0x3782 <USART_Read>
    1934:	89 93       	st	Y+, r24
		if (hits[hitCount] == ERROR_HANDLE) {
    1936:	8f 3f       	cpi	r24, 0xFF	; 255
    1938:	59 f0       	breq	.+22     	; 0x1950 <uCollide+0x50>
			return hitCount;
		}
		hitCount++;
    193a:	0f 5f       	subi	r16, 0xFF	; 255
	
	USART_Write(COLLIDE);
	USART_Write(sprite);
	USART_Write(group);
	
	while (hitCount < hitsSize) {
    193c:	01 17       	cp	r16, r17
    193e:	c1 f7       	brne	.-16     	; 0x1930 <uCollide+0x30>
    1940:	03 c0       	rjmp	.+6      	; 0x1948 <uCollide+0x48>
* param hitsSize: The size of the hits array
* return: The number of hits stored in the hits array
*******************************************************************************/
uint8_t uCollide(xSpriteHandle sprite, xGroupHandle group,
 xSpriteHandle hits[], uint8_t hitsSize) {
	uint8_t hitCount = 0;
    1942:	00 e0       	ldi	r16, 0x00	; 0
    1944:	01 c0       	rjmp	.+2      	; 0x1948 <uCollide+0x48>
		}
		hitCount++;
	}
	
	while (USART_Read() != ERROR_HANDLE)
	    hitCount++;
    1946:	0f 5f       	subi	r16, 0xFF	; 255
			return hitCount;
		}
		hitCount++;
	}
	
	while (USART_Read() != ERROR_HANDLE)
    1948:	0e 94 c1 1b 	call	0x3782	; 0x3782 <USART_Read>
    194c:	8f 3f       	cpi	r24, 0xFF	; 255
    194e:	d9 f7       	brne	.-10     	; 0x1946 <uCollide+0x46>
	    hitCount++;
		
	return hitCount;
    1950:	80 2f       	mov	r24, r16
    1952:	df 91       	pop	r29
    1954:	cf 91       	pop	r28
    1956:	1f 91       	pop	r17
    1958:	0f 91       	pop	r16
    195a:	ff 90       	pop	r15
    195c:	08 95       	ret

0000195e <pvPortMalloc>:
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;										\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    195e:	0f 93       	push	r16
    1960:	1f 93       	push	r17
    1962:	cf 93       	push	r28
    1964:	df 93       	push	r29
    1966:	ec 01       	movw	r28, r24
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1968:	0e 94 75 17 	call	0x2eea	; 0x2eea <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
    196c:	80 91 93 02 	lds	r24, 0x0293
    1970:	88 23       	and	r24, r24
    1972:	f9 f4       	brne	.+62     	; 0x19b2 <pvPortMalloc+0x54>
		{
			prvHeapInit();
    1974:	88 e9       	ldi	r24, 0x98	; 152
    1976:	92 e0       	ldi	r25, 0x02	; 2
    1978:	90 93 95 02 	sts	0x0295, r25
    197c:	80 93 94 02 	sts	0x0294, r24
    1980:	10 92 97 02 	sts	0x0297, r1
    1984:	10 92 96 02 	sts	0x0296, r1
    1988:	80 e0       	ldi	r24, 0x00	; 0
    198a:	98 e1       	ldi	r25, 0x18	; 24
    198c:	90 93 9b 1a 	sts	0x1A9B, r25
    1990:	80 93 9a 1a 	sts	0x1A9A, r24
    1994:	ea e9       	ldi	r30, 0x9A	; 154
    1996:	fa e1       	ldi	r31, 0x1A	; 26
    1998:	12 92       	st	-Z, r1
    199a:	12 92       	st	-Z, r1
    199c:	90 93 9b 02 	sts	0x029B, r25
    19a0:	80 93 9a 02 	sts	0x029A, r24
    19a4:	f0 93 99 02 	sts	0x0299, r31
    19a8:	e0 93 98 02 	sts	0x0298, r30
			xHeapHasBeenInitialised = pdTRUE;
    19ac:	81 e0       	ldi	r24, 0x01	; 1
    19ae:	80 93 93 02 	sts	0x0293, r24
		}

		/* The wanted size is increased so it can contain a xBlockLink
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
    19b2:	20 97       	sbiw	r28, 0x00	; 0
    19b4:	09 f4       	brne	.+2      	; 0x19b8 <pvPortMalloc+0x5a>
    19b6:	62 c0       	rjmp	.+196    	; 0x1a7c <pvPortMalloc+0x11e>
		{
			xWantedSize += heapSTRUCT_SIZE;
    19b8:	9e 01       	movw	r18, r28
    19ba:	2b 5f       	subi	r18, 0xFB	; 251
    19bc:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
    19be:	24 96       	adiw	r28, 0x04	; 4
    19c0:	87 e1       	ldi	r24, 0x17	; 23
    19c2:	cf 3f       	cpi	r28, 0xFF	; 255
    19c4:	d8 07       	cpc	r29, r24
    19c6:	08 f0       	brcs	.+2      	; 0x19ca <pvPortMalloc+0x6c>
    19c8:	5c c0       	rjmp	.+184    	; 0x1a82 <pvPortMalloc+0x124>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
    19ca:	e0 91 94 02 	lds	r30, 0x0294
    19ce:	f0 91 95 02 	lds	r31, 0x0295

		if( ( xWantedSize > 0 ) && ( xWantedSize < configTOTAL_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
    19d2:	a4 e9       	ldi	r26, 0x94	; 148
    19d4:	b2 e0       	ldi	r27, 0x02	; 2
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    19d6:	02 c0       	rjmp	.+4      	; 0x19dc <pvPortMalloc+0x7e>
    19d8:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
    19da:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock ) )
    19dc:	82 81       	ldd	r24, Z+2	; 0x02
    19de:	93 81       	ldd	r25, Z+3	; 0x03
    19e0:	82 17       	cp	r24, r18
    19e2:	93 07       	cpc	r25, r19
    19e4:	20 f4       	brcc	.+8      	; 0x19ee <pvPortMalloc+0x90>
    19e6:	80 81       	ld	r24, Z
    19e8:	91 81       	ldd	r25, Z+1	; 0x01
    19ea:	00 97       	sbiw	r24, 0x00	; 0
    19ec:	a9 f7       	brne	.-22     	; 0x19d8 <pvPortMalloc+0x7a>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
    19ee:	ca e1       	ldi	r28, 0x1A	; 26
    19f0:	e8 39       	cpi	r30, 0x98	; 152
    19f2:	fc 07       	cpc	r31, r28
    19f4:	09 f4       	brne	.+2      	; 0x19f8 <pvPortMalloc+0x9a>
    19f6:	48 c0       	rjmp	.+144    	; 0x1a88 <pvPortMalloc+0x12a>
			{
				/* Return the memory space - jumping over the xBlockLink structure
				at its start. */
				pvReturn = ( void * ) ( ( ( unsigned char * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
    19f8:	8d 91       	ld	r24, X+
    19fa:	9c 91       	ld	r25, X
    19fc:	11 97       	sbiw	r26, 0x01	; 1
    19fe:	8c 01       	movw	r16, r24
    1a00:	0b 5f       	subi	r16, 0xFB	; 251
    1a02:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken our of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1a04:	80 81       	ld	r24, Z
    1a06:	91 81       	ldd	r25, Z+1	; 0x01
    1a08:	11 96       	adiw	r26, 0x01	; 1
    1a0a:	9c 93       	st	X, r25
    1a0c:	8e 93       	st	-X, r24

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1a0e:	82 81       	ldd	r24, Z+2	; 0x02
    1a10:	93 81       	ldd	r25, Z+3	; 0x03
    1a12:	82 1b       	sub	r24, r18
    1a14:	93 0b       	sbc	r25, r19
    1a16:	8b 30       	cpi	r24, 0x0B	; 11
    1a18:	91 05       	cpc	r25, r1
    1a1a:	18 f1       	brcs	.+70     	; 0x1a62 <pvPortMalloc+0x104>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( unsigned char * ) pxBlock ) + xWantedSize );
    1a1c:	af 01       	movw	r20, r30
    1a1e:	42 0f       	add	r20, r18
    1a20:	53 1f       	adc	r21, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1a22:	da 01       	movw	r26, r20
    1a24:	13 96       	adiw	r26, 0x03	; 3
    1a26:	9c 93       	st	X, r25
    1a28:	8e 93       	st	-X, r24
    1a2a:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
    1a2c:	33 83       	std	Z+3, r19	; 0x03
    1a2e:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
    1a30:	12 96       	adiw	r26, 0x02	; 2
    1a32:	2d 91       	ld	r18, X+
    1a34:	3c 91       	ld	r19, X
    1a36:	13 97       	sbiw	r26, 0x03	; 3
    1a38:	64 e9       	ldi	r22, 0x94	; 148
    1a3a:	72 e0       	ldi	r23, 0x02	; 2
    1a3c:	01 c0       	rjmp	.+2      	; 0x1a40 <pvPortMalloc+0xe2>
    1a3e:	bd 01       	movw	r22, r26
    1a40:	eb 01       	movw	r28, r22
    1a42:	a8 81       	ld	r26, Y
    1a44:	b9 81       	ldd	r27, Y+1	; 0x01
    1a46:	12 96       	adiw	r26, 0x02	; 2
    1a48:	8d 91       	ld	r24, X+
    1a4a:	9c 91       	ld	r25, X
    1a4c:	13 97       	sbiw	r26, 0x03	; 3
    1a4e:	82 17       	cp	r24, r18
    1a50:	93 07       	cpc	r25, r19
    1a52:	a8 f3       	brcs	.-22     	; 0x1a3e <pvPortMalloc+0xe0>
    1a54:	ea 01       	movw	r28, r20
    1a56:	b9 83       	std	Y+1, r27	; 0x01
    1a58:	a8 83       	st	Y, r26
    1a5a:	db 01       	movw	r26, r22
    1a5c:	11 96       	adiw	r26, 0x01	; 1
    1a5e:	5c 93       	st	X, r21
    1a60:	4e 93       	st	-X, r20
				}
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
    1a62:	80 91 5a 02 	lds	r24, 0x025A
    1a66:	90 91 5b 02 	lds	r25, 0x025B
    1a6a:	22 81       	ldd	r18, Z+2	; 0x02
    1a6c:	33 81       	ldd	r19, Z+3	; 0x03
    1a6e:	82 1b       	sub	r24, r18
    1a70:	93 0b       	sbc	r25, r19
    1a72:	90 93 5b 02 	sts	0x025B, r25
    1a76:	80 93 5a 02 	sts	0x025A, r24
    1a7a:	08 c0       	rjmp	.+16     	; 0x1a8c <pvPortMalloc+0x12e>

void *pvPortMalloc( size_t xWantedSize )
{
xBlockLink *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static portBASE_TYPE xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
    1a7c:	00 e0       	ldi	r16, 0x00	; 0
    1a7e:	10 e0       	ldi	r17, 0x00	; 0
    1a80:	05 c0       	rjmp	.+10     	; 0x1a8c <pvPortMalloc+0x12e>
    1a82:	00 e0       	ldi	r16, 0x00	; 0
    1a84:	10 e0       	ldi	r17, 0x00	; 0
    1a86:	02 c0       	rjmp	.+4      	; 0x1a8c <pvPortMalloc+0x12e>
    1a88:	00 e0       	ldi	r16, 0x00	; 0
    1a8a:	10 e0       	ldi	r17, 0x00	; 0
				
				xFreeBytesRemaining -= pxBlock->xBlockSize;
			}
		}
	}
	xTaskResumeAll();
    1a8c:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1a90:	80 2f       	mov	r24, r16
    1a92:	91 2f       	mov	r25, r17
    1a94:	df 91       	pop	r29
    1a96:	cf 91       	pop	r28
    1a98:	1f 91       	pop	r17
    1a9a:	0f 91       	pop	r16
    1a9c:	08 95       	ret

00001a9e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1a9e:	0f 93       	push	r16
    1aa0:	1f 93       	push	r17
    1aa2:	cf 93       	push	r28
    1aa4:	df 93       	push	r29
    1aa6:	ec 01       	movw	r28, r24
unsigned char *puc = ( unsigned char * ) pv;
xBlockLink *pxLink;

	if( pv )
    1aa8:	00 97       	sbiw	r24, 0x00	; 0
    1aaa:	39 f1       	breq	.+78     	; 0x1afa <vPortFree+0x5c>
		/* The memory being freed will have an xBlockLink structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
    1aac:	8c 01       	movw	r16, r24
    1aae:	05 50       	subi	r16, 0x05	; 5
    1ab0:	10 40       	sbci	r17, 0x00	; 0

		vTaskSuspendAll();
    1ab2:	0e 94 75 17 	call	0x2eea	; 0x2eea <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( xBlockLink * ) pxLink ) );
    1ab6:	f8 01       	movw	r30, r16
    1ab8:	22 81       	ldd	r18, Z+2	; 0x02
    1aba:	33 81       	ldd	r19, Z+3	; 0x03
    1abc:	a4 e9       	ldi	r26, 0x94	; 148
    1abe:	b2 e0       	ldi	r27, 0x02	; 2
    1ac0:	01 c0       	rjmp	.+2      	; 0x1ac4 <vPortFree+0x26>
    1ac2:	df 01       	movw	r26, r30
    1ac4:	ed 91       	ld	r30, X+
    1ac6:	fc 91       	ld	r31, X
    1ac8:	11 97       	sbiw	r26, 0x01	; 1
    1aca:	82 81       	ldd	r24, Z+2	; 0x02
    1acc:	93 81       	ldd	r25, Z+3	; 0x03
    1ace:	82 17       	cp	r24, r18
    1ad0:	93 07       	cpc	r25, r19
    1ad2:	b8 f3       	brcs	.-18     	; 0x1ac2 <vPortFree+0x24>
    1ad4:	25 97       	sbiw	r28, 0x05	; 5
    1ad6:	f9 83       	std	Y+1, r31	; 0x01
    1ad8:	e8 83       	st	Y, r30
    1ada:	0d 93       	st	X+, r16
    1adc:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
    1ade:	80 91 5a 02 	lds	r24, 0x025A
    1ae2:	90 91 5b 02 	lds	r25, 0x025B
    1ae6:	2a 81       	ldd	r18, Y+2	; 0x02
    1ae8:	3b 81       	ldd	r19, Y+3	; 0x03
    1aea:	82 0f       	add	r24, r18
    1aec:	93 1f       	adc	r25, r19
    1aee:	90 93 5b 02 	sts	0x025B, r25
    1af2:	80 93 5a 02 	sts	0x025A, r24
		}
		xTaskResumeAll();
    1af6:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>
	}
}
    1afa:	df 91       	pop	r29
    1afc:	cf 91       	pop	r28
    1afe:	1f 91       	pop	r17
    1b00:	0f 91       	pop	r16
    1b02:	08 95       	ret

00001b04 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1b04:	80 91 5a 02 	lds	r24, 0x025A
    1b08:	90 91 5b 02 	lds	r25, 0x025B
    1b0c:	08 95       	ret

00001b0e <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* This just exists to keep the linker quiet. */
}
    1b0e:	08 95       	ret

00001b10 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1b10:	af 92       	push	r10
    1b12:	bf 92       	push	r11
    1b14:	cf 92       	push	r12
    1b16:	df 92       	push	r13
    1b18:	ef 92       	push	r14
    1b1a:	ff 92       	push	r15
    1b1c:	0f 93       	push	r16
    1b1e:	1f 93       	push	r17
    1b20:	cf 93       	push	r28
    1b22:	df 93       	push	r29
    1b24:	6c 01       	movw	r12, r24
    1b26:	e6 2e       	mov	r14, r22
    1b28:	f4 2e       	mov	r15, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1b2a:	8a e1       	ldi	r24, 0x1A	; 26
    1b2c:	90 e0       	ldi	r25, 0x00	; 0
    1b2e:	0e 94 af 0c 	call	0x195e	; 0x195e <pvPortMalloc>
    1b32:	8c 01       	movw	r16, r24
	if( pxCoRoutine )
    1b34:	00 97       	sbiw	r24, 0x00	; 0
    1b36:	09 f4       	brne	.+2      	; 0x1b3a <xCoRoutineCreate+0x2a>
    1b38:	62 c0       	rjmp	.+196    	; 0x1bfe <xCoRoutineCreate+0xee>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1b3a:	80 91 9c 1a 	lds	r24, 0x1A9C
    1b3e:	90 91 9d 1a 	lds	r25, 0x1A9D
    1b42:	00 97       	sbiw	r24, 0x00	; 0
    1b44:	39 f5       	brne	.+78     	; 0x1b94 <xCoRoutineCreate+0x84>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1b46:	10 93 9d 1a 	sts	0x1A9D, r17
    1b4a:	00 93 9c 1a 	sts	0x1A9C, r16
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1b4e:	cf e9       	ldi	r28, 0x9F	; 159
    1b50:	da e1       	ldi	r29, 0x1A	; 26
    1b52:	ce 01       	movw	r24, r28
    1b54:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
    1b58:	ce 01       	movw	r24, r28
    1b5a:	09 96       	adiw	r24, 0x09	; 9
    1b5c:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1b60:	c1 eb       	ldi	r28, 0xB1	; 177
    1b62:	da e1       	ldi	r29, 0x1A	; 26
    1b64:	ce 01       	movw	r24, r28
    1b66:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1b6a:	0f 2e       	mov	r0, r31
    1b6c:	fa eb       	ldi	r31, 0xBA	; 186
    1b6e:	af 2e       	mov	r10, r31
    1b70:	fa e1       	ldi	r31, 0x1A	; 26
    1b72:	bf 2e       	mov	r11, r31
    1b74:	f0 2d       	mov	r31, r0
    1b76:	c5 01       	movw	r24, r10
    1b78:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1b7c:	83 ec       	ldi	r24, 0xC3	; 195
    1b7e:	9a e1       	ldi	r25, 0x1A	; 26
    1b80:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1b84:	d0 93 cd 1a 	sts	0x1ACD, r29
    1b88:	c0 93 cc 1a 	sts	0x1ACC, r28
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1b8c:	b0 92 cf 1a 	sts	0x1ACF, r11
    1b90:	a0 92 ce 1a 	sts	0x1ACE, r10
    1b94:	ce 2d       	mov	r28, r14
    1b96:	e1 10       	cpse	r14, r1
    1b98:	c1 e0       	ldi	r28, 0x01	; 1
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1b9a:	f8 01       	movw	r30, r16
    1b9c:	11 8e       	std	Z+25, r1	; 0x19
    1b9e:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1ba0:	c6 8b       	std	Z+22, r28	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1ba2:	f7 8a       	std	Z+23, r15	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1ba4:	c1 92       	st	Z+, r12
    1ba6:	d1 92       	st	Z+, r13
    1ba8:	7f 01       	movw	r14, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1baa:	cf 01       	movw	r24, r30
    1bac:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1bb0:	c8 01       	movw	r24, r16
    1bb2:	0c 96       	adiw	r24, 0x0c	; 12
    1bb4:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1bb8:	f8 01       	movw	r30, r16
    1bba:	11 87       	std	Z+9, r17	; 0x09
    1bbc:	00 87       	std	Z+8, r16	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1bbe:	13 8b       	std	Z+19, r17	; 0x13
    1bc0:	02 8b       	std	Z+18, r16	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1bc2:	84 e0       	ldi	r24, 0x04	; 4
    1bc4:	90 e0       	ldi	r25, 0x00	; 0
    1bc6:	8c 1b       	sub	r24, r28
    1bc8:	91 09       	sbc	r25, r1
    1bca:	95 87       	std	Z+13, r25	; 0x0d
    1bcc:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1bce:	86 89       	ldd	r24, Z+22	; 0x16
    1bd0:	90 91 9e 1a 	lds	r25, 0x1A9E
    1bd4:	98 17       	cp	r25, r24
    1bd6:	10 f4       	brcc	.+4      	; 0x1bdc <xCoRoutineCreate+0xcc>
    1bd8:	80 93 9e 1a 	sts	0x1A9E, r24
    1bdc:	90 e0       	ldi	r25, 0x00	; 0
    1bde:	9c 01       	movw	r18, r24
    1be0:	22 0f       	add	r18, r18
    1be2:	33 1f       	adc	r19, r19
    1be4:	22 0f       	add	r18, r18
    1be6:	33 1f       	adc	r19, r19
    1be8:	22 0f       	add	r18, r18
    1bea:	33 1f       	adc	r19, r19
    1bec:	82 0f       	add	r24, r18
    1bee:	93 1f       	adc	r25, r19
    1bf0:	81 56       	subi	r24, 0x61	; 97
    1bf2:	95 4e       	sbci	r25, 0xE5	; 229
    1bf4:	b7 01       	movw	r22, r14
    1bf6:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>

		xReturn = pdPASS;
    1bfa:	81 e0       	ldi	r24, 0x01	; 1
    1bfc:	01 c0       	rjmp	.+2      	; 0x1c00 <xCoRoutineCreate+0xf0>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    1bfe:	8f ef       	ldi	r24, 0xFF	; 255
	}
	
	return xReturn;	
}
    1c00:	df 91       	pop	r29
    1c02:	cf 91       	pop	r28
    1c04:	1f 91       	pop	r17
    1c06:	0f 91       	pop	r16
    1c08:	ff 90       	pop	r15
    1c0a:	ef 90       	pop	r14
    1c0c:	df 90       	pop	r13
    1c0e:	cf 90       	pop	r12
    1c10:	bf 90       	pop	r11
    1c12:	af 90       	pop	r10
    1c14:	08 95       	ret

00001c16 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1c16:	0f 93       	push	r16
    1c18:	1f 93       	push	r17
    1c1a:	cf 93       	push	r28
    1c1c:	df 93       	push	r29
    1c1e:	8b 01       	movw	r16, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1c20:	c0 91 d0 1a 	lds	r28, 0x1AD0
    1c24:	d0 91 d1 1a 	lds	r29, 0x1AD1
    1c28:	c8 0f       	add	r28, r24
    1c2a:	d9 1f       	adc	r29, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1c2c:	80 91 9c 1a 	lds	r24, 0x1A9C
    1c30:	90 91 9d 1a 	lds	r25, 0x1A9D
    1c34:	02 96       	adiw	r24, 0x02	; 2
    1c36:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1c3a:	e0 91 9c 1a 	lds	r30, 0x1A9C
    1c3e:	f0 91 9d 1a 	lds	r31, 0x1A9D
    1c42:	d3 83       	std	Z+3, r29	; 0x03
    1c44:	c2 83       	std	Z+2, r28	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1c46:	80 91 d0 1a 	lds	r24, 0x1AD0
    1c4a:	90 91 d1 1a 	lds	r25, 0x1AD1
    1c4e:	c8 17       	cp	r28, r24
    1c50:	d9 07       	cpc	r29, r25
    1c52:	50 f4       	brcc	.+20     	; 0x1c68 <vCoRoutineAddToDelayedList+0x52>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1c54:	bf 01       	movw	r22, r30
    1c56:	6e 5f       	subi	r22, 0xFE	; 254
    1c58:	7f 4f       	sbci	r23, 0xFF	; 255
    1c5a:	80 91 ce 1a 	lds	r24, 0x1ACE
    1c5e:	90 91 cf 1a 	lds	r25, 0x1ACF
    1c62:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <vListInsert>
    1c66:	09 c0       	rjmp	.+18     	; 0x1c7a <vCoRoutineAddToDelayedList+0x64>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1c68:	bf 01       	movw	r22, r30
    1c6a:	6e 5f       	subi	r22, 0xFE	; 254
    1c6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6e:	80 91 cc 1a 	lds	r24, 0x1ACC
    1c72:	90 91 cd 1a 	lds	r25, 0x1ACD
    1c76:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <vListInsert>
	}

	if( pxEventList )
    1c7a:	01 15       	cp	r16, r1
    1c7c:	11 05       	cpc	r17, r1
    1c7e:	49 f0       	breq	.+18     	; 0x1c92 <vCoRoutineAddToDelayedList+0x7c>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1c80:	60 91 9c 1a 	lds	r22, 0x1A9C
    1c84:	70 91 9d 1a 	lds	r23, 0x1A9D
    1c88:	64 5f       	subi	r22, 0xF4	; 244
    1c8a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c8c:	c8 01       	movw	r24, r16
    1c8e:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <vListInsert>
	}
}
    1c92:	df 91       	pop	r29
    1c94:	cf 91       	pop	r28
    1c96:	1f 91       	pop	r17
    1c98:	0f 91       	pop	r16
    1c9a:	08 95       	ret

00001c9c <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1c9c:	cf 92       	push	r12
    1c9e:	df 92       	push	r13
    1ca0:	ef 92       	push	r14
    1ca2:	ff 92       	push	r15
    1ca4:	0f 93       	push	r16
    1ca6:	1f 93       	push	r17
    1ca8:	cf 93       	push	r28
    1caa:	df 93       	push	r29
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1cac:	80 91 c3 1a 	lds	r24, 0x1AC3
    1cb0:	88 23       	and	r24, r24
    1cb2:	b9 f1       	breq	.+110    	; 0x1d22 <vCoRoutineSchedule+0x86>
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1cb4:	0f 2e       	mov	r0, r31
    1cb6:	f8 ec       	ldi	r31, 0xC8	; 200
    1cb8:	ef 2e       	mov	r14, r31
    1cba:	fa e1       	ldi	r31, 0x1A	; 26
    1cbc:	ff 2e       	mov	r15, r31
    1cbe:	f0 2d       	mov	r31, r0
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1cc0:	0f 2e       	mov	r0, r31
    1cc2:	f3 ec       	ldi	r31, 0xC3	; 195
    1cc4:	cf 2e       	mov	r12, r31
    1cc6:	fa e1       	ldi	r31, 0x1A	; 26
    1cc8:	df 2e       	mov	r13, r31
    1cca:	f0 2d       	mov	r31, r0
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1ccc:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1cce:	d7 01       	movw	r26, r14
    1cd0:	ed 91       	ld	r30, X+
    1cd2:	fc 91       	ld	r31, X
    1cd4:	c6 81       	ldd	r28, Z+6	; 0x06
    1cd6:	d7 81       	ldd	r29, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1cd8:	ce 01       	movw	r24, r28
    1cda:	0c 96       	adiw	r24, 0x0c	; 12
    1cdc:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    1ce0:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1ce2:	8e 01       	movw	r16, r28
    1ce4:	0e 5f       	subi	r16, 0xFE	; 254
    1ce6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ce8:	c8 01       	movw	r24, r16
    1cea:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    1cee:	8e 89       	ldd	r24, Y+22	; 0x16
    1cf0:	90 91 9e 1a 	lds	r25, 0x1A9E
    1cf4:	98 17       	cp	r25, r24
    1cf6:	10 f4       	brcc	.+4      	; 0x1cfc <vCoRoutineSchedule+0x60>
    1cf8:	80 93 9e 1a 	sts	0x1A9E, r24
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	9c 01       	movw	r18, r24
    1d00:	22 0f       	add	r18, r18
    1d02:	33 1f       	adc	r19, r19
    1d04:	22 0f       	add	r18, r18
    1d06:	33 1f       	adc	r19, r19
    1d08:	22 0f       	add	r18, r18
    1d0a:	33 1f       	adc	r19, r19
    1d0c:	82 0f       	add	r24, r18
    1d0e:	93 1f       	adc	r25, r19
    1d10:	81 56       	subi	r24, 0x61	; 97
    1d12:	95 4e       	sbci	r25, 0xE5	; 229
    1d14:	b8 01       	movw	r22, r16
    1d16:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1d1a:	f6 01       	movw	r30, r12
    1d1c:	80 81       	ld	r24, Z
    1d1e:	88 23       	and	r24, r24
    1d20:	a9 f6       	brne	.-86     	; 0x1ccc <vCoRoutineSchedule+0x30>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    1d22:	0e 94 7b 17 	call	0x2ef6	; 0x2ef6 <xTaskGetTickCount>
    1d26:	20 91 d2 1a 	lds	r18, 0x1AD2
    1d2a:	30 91 d3 1a 	lds	r19, 0x1AD3
    1d2e:	82 1b       	sub	r24, r18
    1d30:	93 0b       	sbc	r25, r19
    1d32:	90 93 d5 1a 	sts	0x1AD5, r25
    1d36:	80 93 d4 1a 	sts	0x1AD4, r24
    1d3a:	74 c0       	rjmp	.+232    	; 0x1e24 <vCoRoutineSchedule+0x188>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    1d3c:	20 91 d0 1a 	lds	r18, 0x1AD0
    1d40:	30 91 d1 1a 	lds	r19, 0x1AD1
    1d44:	2f 5f       	subi	r18, 0xFF	; 255
    1d46:	3f 4f       	sbci	r19, 0xFF	; 255
    1d48:	30 93 d1 1a 	sts	0x1AD1, r19
    1d4c:	20 93 d0 1a 	sts	0x1AD0, r18
		xPassedTicks--;
    1d50:	01 97       	sbiw	r24, 0x01	; 1
    1d52:	90 93 d5 1a 	sts	0x1AD5, r25
    1d56:	80 93 d4 1a 	sts	0x1AD4, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    1d5a:	21 15       	cp	r18, r1
    1d5c:	31 05       	cpc	r19, r1
    1d5e:	81 f4       	brne	.+32     	; 0x1d80 <vCoRoutineSchedule+0xe4>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1d60:	80 91 cc 1a 	lds	r24, 0x1ACC
    1d64:	90 91 cd 1a 	lds	r25, 0x1ACD
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1d68:	20 91 ce 1a 	lds	r18, 0x1ACE
    1d6c:	30 91 cf 1a 	lds	r19, 0x1ACF
    1d70:	30 93 cd 1a 	sts	0x1ACD, r19
    1d74:	20 93 cc 1a 	sts	0x1ACC, r18
			pxOverflowDelayedCoRoutineList = pxTemp;
    1d78:	90 93 cf 1a 	sts	0x1ACF, r25
    1d7c:	80 93 ce 1a 	sts	0x1ACE, r24
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1d80:	e0 91 cc 1a 	lds	r30, 0x1ACC
    1d84:	f0 91 cd 1a 	lds	r31, 0x1ACD
    1d88:	80 81       	ld	r24, Z
    1d8a:	88 23       	and	r24, r24
    1d8c:	09 f4       	brne	.+2      	; 0x1d90 <vCoRoutineSchedule+0xf4>
    1d8e:	4a c0       	rjmp	.+148    	; 0x1e24 <vCoRoutineSchedule+0x188>
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1d90:	05 80       	ldd	r0, Z+5	; 0x05
    1d92:	f6 81       	ldd	r31, Z+6	; 0x06
    1d94:	e0 2d       	mov	r30, r0
    1d96:	c6 81       	ldd	r28, Z+6	; 0x06
    1d98:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1d9a:	2a 81       	ldd	r18, Y+2	; 0x02
    1d9c:	3b 81       	ldd	r19, Y+3	; 0x03
    1d9e:	80 91 d0 1a 	lds	r24, 0x1AD0
    1da2:	90 91 d1 1a 	lds	r25, 0x1AD1
    1da6:	82 17       	cp	r24, r18
    1da8:	93 07       	cpc	r25, r19
    1daa:	78 f4       	brcc	.+30     	; 0x1dca <vCoRoutineSchedule+0x12e>
    1dac:	3b c0       	rjmp	.+118    	; 0x1e24 <vCoRoutineSchedule+0x188>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1dae:	05 80       	ldd	r0, Z+5	; 0x05
    1db0:	f6 81       	ldd	r31, Z+6	; 0x06
    1db2:	e0 2d       	mov	r30, r0
    1db4:	c6 81       	ldd	r28, Z+6	; 0x06
    1db6:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1db8:	2a 81       	ldd	r18, Y+2	; 0x02
    1dba:	3b 81       	ldd	r19, Y+3	; 0x03
    1dbc:	80 91 d0 1a 	lds	r24, 0x1AD0
    1dc0:	90 91 d1 1a 	lds	r25, 0x1AD1
    1dc4:	82 17       	cp	r24, r18
    1dc6:	93 07       	cpc	r25, r19
    1dc8:	68 f1       	brcs	.+90     	; 0x1e24 <vCoRoutineSchedule+0x188>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    1dca:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );											
    1dcc:	8e 01       	movw	r16, r28
    1dce:	0e 5f       	subi	r16, 0xFE	; 254
    1dd0:	1f 4f       	sbci	r17, 0xFF	; 255
    1dd2:	c8 01       	movw	r24, r16
    1dd4:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1dd8:	8c 89       	ldd	r24, Y+20	; 0x14
    1dda:	9d 89       	ldd	r25, Y+21	; 0x15
    1ddc:	00 97       	sbiw	r24, 0x00	; 0
    1dde:	21 f0       	breq	.+8      	; 0x1de8 <vCoRoutineSchedule+0x14c>
				{															
					uxListRemove( &( pxCRCB->xEventListItem ) );											
    1de0:	ce 01       	movw	r24, r28
    1de2:	0c 96       	adiw	r24, 0x0c	; 12
    1de4:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1de8:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1dea:	8e 89       	ldd	r24, Y+22	; 0x16
    1dec:	90 91 9e 1a 	lds	r25, 0x1A9E
    1df0:	98 17       	cp	r25, r24
    1df2:	10 f4       	brcc	.+4      	; 0x1df8 <vCoRoutineSchedule+0x15c>
    1df4:	80 93 9e 1a 	sts	0x1A9E, r24
    1df8:	90 e0       	ldi	r25, 0x00	; 0
    1dfa:	9c 01       	movw	r18, r24
    1dfc:	22 0f       	add	r18, r18
    1dfe:	33 1f       	adc	r19, r19
    1e00:	22 0f       	add	r18, r18
    1e02:	33 1f       	adc	r19, r19
    1e04:	22 0f       	add	r18, r18
    1e06:	33 1f       	adc	r19, r19
    1e08:	82 0f       	add	r24, r18
    1e0a:	93 1f       	adc	r25, r19
    1e0c:	81 56       	subi	r24, 0x61	; 97
    1e0e:	95 4e       	sbci	r25, 0xE5	; 229
    1e10:	b8 01       	movw	r22, r16
    1e12:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1e16:	e0 91 cc 1a 	lds	r30, 0x1ACC
    1e1a:	f0 91 cd 1a 	lds	r31, 0x1ACD
    1e1e:	80 81       	ld	r24, Z
    1e20:	88 23       	and	r24, r24
    1e22:	29 f6       	brne	.-118    	; 0x1dae <vCoRoutineSchedule+0x112>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1e24:	80 91 d4 1a 	lds	r24, 0x1AD4
    1e28:	90 91 d5 1a 	lds	r25, 0x1AD5
    1e2c:	00 97       	sbiw	r24, 0x00	; 0
    1e2e:	09 f0       	breq	.+2      	; 0x1e32 <vCoRoutineSchedule+0x196>
    1e30:	85 cf       	rjmp	.-246    	; 0x1d3c <vCoRoutineSchedule+0xa0>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    1e32:	80 91 d0 1a 	lds	r24, 0x1AD0
    1e36:	90 91 d1 1a 	lds	r25, 0x1AD1
    1e3a:	90 93 d3 1a 	sts	0x1AD3, r25
    1e3e:	80 93 d2 1a 	sts	0x1AD2, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1e42:	20 91 9e 1a 	lds	r18, 0x1A9E
    1e46:	82 2f       	mov	r24, r18
    1e48:	90 e0       	ldi	r25, 0x00	; 0
    1e4a:	fc 01       	movw	r30, r24
    1e4c:	ee 0f       	add	r30, r30
    1e4e:	ff 1f       	adc	r31, r31
    1e50:	ee 0f       	add	r30, r30
    1e52:	ff 1f       	adc	r31, r31
    1e54:	ee 0f       	add	r30, r30
    1e56:	ff 1f       	adc	r31, r31
    1e58:	e8 0f       	add	r30, r24
    1e5a:	f9 1f       	adc	r31, r25
    1e5c:	e1 56       	subi	r30, 0x61	; 97
    1e5e:	f5 4e       	sbci	r31, 0xE5	; 229
    1e60:	30 81       	ld	r19, Z
    1e62:	33 23       	and	r19, r19
    1e64:	d9 f4       	brne	.+54     	; 0x1e9c <vCoRoutineSchedule+0x200>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1e66:	22 23       	and	r18, r18
    1e68:	31 f4       	brne	.+12     	; 0x1e76 <vCoRoutineSchedule+0x1da>
    1e6a:	47 c0       	rjmp	.+142    	; 0x1efa <vCoRoutineSchedule+0x25e>
    1e6c:	22 23       	and	r18, r18
    1e6e:	19 f4       	brne	.+6      	; 0x1e76 <vCoRoutineSchedule+0x1da>
    1e70:	20 93 9e 1a 	sts	0x1A9E, r18
    1e74:	42 c0       	rjmp	.+132    	; 0x1efa <vCoRoutineSchedule+0x25e>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1e76:	21 50       	subi	r18, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1e78:	82 2f       	mov	r24, r18
    1e7a:	90 e0       	ldi	r25, 0x00	; 0
    1e7c:	fc 01       	movw	r30, r24
    1e7e:	ee 0f       	add	r30, r30
    1e80:	ff 1f       	adc	r31, r31
    1e82:	ee 0f       	add	r30, r30
    1e84:	ff 1f       	adc	r31, r31
    1e86:	ee 0f       	add	r30, r30
    1e88:	ff 1f       	adc	r31, r31
    1e8a:	e8 0f       	add	r30, r24
    1e8c:	f9 1f       	adc	r31, r25
    1e8e:	e1 56       	subi	r30, 0x61	; 97
    1e90:	f5 4e       	sbci	r31, 0xE5	; 229
    1e92:	30 81       	ld	r19, Z
    1e94:	33 23       	and	r19, r19
    1e96:	51 f3       	breq	.-44     	; 0x1e6c <vCoRoutineSchedule+0x1d0>
    1e98:	20 93 9e 1a 	sts	0x1A9E, r18
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1e9c:	fc 01       	movw	r30, r24
    1e9e:	ee 0f       	add	r30, r30
    1ea0:	ff 1f       	adc	r31, r31
    1ea2:	ee 0f       	add	r30, r30
    1ea4:	ff 1f       	adc	r31, r31
    1ea6:	ee 0f       	add	r30, r30
    1ea8:	ff 1f       	adc	r31, r31
    1eaa:	8e 0f       	add	r24, r30
    1eac:	9f 1f       	adc	r25, r31
    1eae:	fc 01       	movw	r30, r24
    1eb0:	e1 56       	subi	r30, 0x61	; 97
    1eb2:	f5 4e       	sbci	r31, 0xE5	; 229
    1eb4:	a1 81       	ldd	r26, Z+1	; 0x01
    1eb6:	b2 81       	ldd	r27, Z+2	; 0x02
    1eb8:	12 96       	adiw	r26, 0x02	; 2
    1eba:	0d 90       	ld	r0, X+
    1ebc:	bc 91       	ld	r27, X
    1ebe:	a0 2d       	mov	r26, r0
    1ec0:	b2 83       	std	Z+2, r27	; 0x02
    1ec2:	a1 83       	std	Z+1, r26	; 0x01
    1ec4:	cf 01       	movw	r24, r30
    1ec6:	03 96       	adiw	r24, 0x03	; 3
    1ec8:	a8 17       	cp	r26, r24
    1eca:	b9 07       	cpc	r27, r25
    1ecc:	31 f4       	brne	.+12     	; 0x1eda <vCoRoutineSchedule+0x23e>
    1ece:	12 96       	adiw	r26, 0x02	; 2
    1ed0:	8d 91       	ld	r24, X+
    1ed2:	9c 91       	ld	r25, X
    1ed4:	13 97       	sbiw	r26, 0x03	; 3
    1ed6:	92 83       	std	Z+2, r25	; 0x02
    1ed8:	81 83       	std	Z+1, r24	; 0x01
    1eda:	01 80       	ldd	r0, Z+1	; 0x01
    1edc:	f2 81       	ldd	r31, Z+2	; 0x02
    1ede:	e0 2d       	mov	r30, r0
    1ee0:	a6 81       	ldd	r26, Z+6	; 0x06
    1ee2:	b7 81       	ldd	r27, Z+7	; 0x07
    1ee4:	b0 93 9d 1a 	sts	0x1A9D, r27
    1ee8:	a0 93 9c 1a 	sts	0x1A9C, r26

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1eec:	ed 91       	ld	r30, X+
    1eee:	fc 91       	ld	r31, X
    1ef0:	11 97       	sbiw	r26, 0x01	; 1
    1ef2:	cd 01       	movw	r24, r26
    1ef4:	57 96       	adiw	r26, 0x17	; 23
    1ef6:	6c 91       	ld	r22, X
    1ef8:	19 95       	eicall

	return;
}
    1efa:	df 91       	pop	r29
    1efc:	cf 91       	pop	r28
    1efe:	1f 91       	pop	r17
    1f00:	0f 91       	pop	r16
    1f02:	ff 90       	pop	r15
    1f04:	ef 90       	pop	r14
    1f06:	df 90       	pop	r13
    1f08:	cf 90       	pop	r12
    1f0a:	08 95       	ret

00001f0c <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1f0c:	0f 93       	push	r16
    1f0e:	1f 93       	push	r17
    1f10:	cf 93       	push	r28
    1f12:	df 93       	push	r29
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1f14:	dc 01       	movw	r26, r24
    1f16:	15 96       	adiw	r26, 0x05	; 5
    1f18:	ed 91       	ld	r30, X+
    1f1a:	fc 91       	ld	r31, X
    1f1c:	16 97       	sbiw	r26, 0x06	; 6
    1f1e:	06 81       	ldd	r16, Z+6	; 0x06
    1f20:	17 81       	ldd	r17, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1f22:	e8 01       	movw	r28, r16
    1f24:	2c 96       	adiw	r28, 0x0c	; 12
    1f26:	ce 01       	movw	r24, r28
    1f28:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1f2c:	83 ec       	ldi	r24, 0xC3	; 195
    1f2e:	9a e1       	ldi	r25, 0x1A	; 26
    1f30:	be 01       	movw	r22, r28
    1f32:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    1f36:	e0 91 9c 1a 	lds	r30, 0x1A9C
    1f3a:	f0 91 9d 1a 	lds	r31, 0x1A9D
	{
		xReturn = pdTRUE;
    1f3e:	81 e0       	ldi	r24, 0x01	; 1
    1f40:	d8 01       	movw	r26, r16
    1f42:	56 96       	adiw	r26, 0x16	; 22
    1f44:	2c 91       	ld	r18, X
    1f46:	56 97       	sbiw	r26, 0x16	; 22
    1f48:	96 89       	ldd	r25, Z+22	; 0x16
    1f4a:	29 17       	cp	r18, r25
    1f4c:	08 f4       	brcc	.+2      	; 0x1f50 <xCoRoutineRemoveFromEventList+0x44>
    1f4e:	80 e0       	ldi	r24, 0x00	; 0
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    1f50:	df 91       	pop	r29
    1f52:	cf 91       	pop	r28
    1f54:	1f 91       	pop	r17
    1f56:	0f 91       	pop	r16
    1f58:	08 95       	ret

00001f5a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    1f5a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    1f5c:	03 96       	adiw	r24, 0x03	; 3
    1f5e:	92 83       	std	Z+2, r25	; 0x02
    1f60:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1f62:	2f ef       	ldi	r18, 0xFF	; 255
    1f64:	3f ef       	ldi	r19, 0xFF	; 255
    1f66:	34 83       	std	Z+4, r19	; 0x04
    1f68:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    1f6a:	96 83       	std	Z+6, r25	; 0x06
    1f6c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    1f6e:	90 87       	std	Z+8, r25	; 0x08
    1f70:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    1f72:	10 82       	st	Z, r1
}
    1f74:	08 95       	ret

00001f76 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1f76:	fc 01       	movw	r30, r24
    1f78:	11 86       	std	Z+9, r1	; 0x09
    1f7a:	10 86       	std	Z+8, r1	; 0x08
}
    1f7c:	08 95       	ret

00001f7e <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    1f7e:	cf 93       	push	r28
    1f80:	df 93       	push	r29
    1f82:	ec 01       	movw	r28, r24
    1f84:	fb 01       	movw	r30, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1f86:	89 81       	ldd	r24, Y+1	; 0x01
    1f88:	9a 81       	ldd	r25, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1f8a:	dc 01       	movw	r26, r24
    1f8c:	12 96       	adiw	r26, 0x02	; 2
    1f8e:	2d 91       	ld	r18, X+
    1f90:	3c 91       	ld	r19, X
    1f92:	13 97       	sbiw	r26, 0x03	; 3
    1f94:	33 83       	std	Z+3, r19	; 0x03
    1f96:	22 83       	std	Z+2, r18	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1f98:	29 81       	ldd	r18, Y+1	; 0x01
    1f9a:	3a 81       	ldd	r19, Y+2	; 0x02
    1f9c:	35 83       	std	Z+5, r19	; 0x05
    1f9e:	24 83       	std	Z+4, r18	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1fa0:	12 96       	adiw	r26, 0x02	; 2
    1fa2:	2d 91       	ld	r18, X+
    1fa4:	3c 91       	ld	r19, X
    1fa6:	13 97       	sbiw	r26, 0x03	; 3
    1fa8:	d9 01       	movw	r26, r18
    1faa:	15 96       	adiw	r26, 0x05	; 5
    1fac:	7c 93       	st	X, r23
    1fae:	6e 93       	st	-X, r22
    1fb0:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    1fb2:	dc 01       	movw	r26, r24
    1fb4:	13 96       	adiw	r26, 0x03	; 3
    1fb6:	7c 93       	st	X, r23
    1fb8:	6e 93       	st	-X, r22
    1fba:	12 97       	sbiw	r26, 0x02	; 2
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1fbc:	7a 83       	std	Y+2, r23	; 0x02
    1fbe:	69 83       	std	Y+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1fc0:	d1 87       	std	Z+9, r29	; 0x09
    1fc2:	c0 87       	std	Z+8, r28	; 0x08

	( pxList->uxNumberOfItems )++;
    1fc4:	88 81       	ld	r24, Y
    1fc6:	8f 5f       	subi	r24, 0xFF	; 255
    1fc8:	88 83       	st	Y, r24
}
    1fca:	df 91       	pop	r29
    1fcc:	cf 91       	pop	r28
    1fce:	08 95       	ret

00001fd0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    1fd0:	cf 93       	push	r28
    1fd2:	df 93       	push	r29
    1fd4:	ac 01       	movw	r20, r24
    1fd6:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1fd8:	28 81       	ld	r18, Y
    1fda:	39 81       	ldd	r19, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1fdc:	8f ef       	ldi	r24, 0xFF	; 255
    1fde:	2f 3f       	cpi	r18, 0xFF	; 255
    1fe0:	38 07       	cpc	r19, r24
    1fe2:	21 f4       	brne	.+8      	; 0x1fec <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1fe4:	fa 01       	movw	r30, r20
    1fe6:	a7 81       	ldd	r26, Z+7	; 0x07
    1fe8:	b0 85       	ldd	r27, Z+8	; 0x08
    1fea:	18 c0       	rjmp	.+48     	; 0x201c <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1fec:	da 01       	movw	r26, r20
    1fee:	13 96       	adiw	r26, 0x03	; 3
    1ff0:	fa 01       	movw	r30, r20
    1ff2:	85 81       	ldd	r24, Z+5	; 0x05
    1ff4:	96 81       	ldd	r25, Z+6	; 0x06
    1ff6:	fc 01       	movw	r30, r24
    1ff8:	80 81       	ld	r24, Z
    1ffa:	91 81       	ldd	r25, Z+1	; 0x01
    1ffc:	28 17       	cp	r18, r24
    1ffe:	39 07       	cpc	r19, r25
    2000:	68 f0       	brcs	.+26     	; 0x201c <vListInsert+0x4c>
    2002:	12 96       	adiw	r26, 0x02	; 2
    2004:	0d 90       	ld	r0, X+
    2006:	bc 91       	ld	r27, X
    2008:	a0 2d       	mov	r26, r0
    200a:	12 96       	adiw	r26, 0x02	; 2
    200c:	ed 91       	ld	r30, X+
    200e:	fc 91       	ld	r31, X
    2010:	13 97       	sbiw	r26, 0x03	; 3
    2012:	80 81       	ld	r24, Z
    2014:	91 81       	ldd	r25, Z+1	; 0x01
    2016:	28 17       	cp	r18, r24
    2018:	39 07       	cpc	r19, r25
    201a:	98 f7       	brcc	.-26     	; 0x2002 <vListInsert+0x32>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    201c:	12 96       	adiw	r26, 0x02	; 2
    201e:	ed 91       	ld	r30, X+
    2020:	fc 91       	ld	r31, X
    2022:	13 97       	sbiw	r26, 0x03	; 3
    2024:	fb 83       	std	Y+3, r31	; 0x03
    2026:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2028:	d5 83       	std	Z+5, r29	; 0x05
    202a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    202c:	bd 83       	std	Y+5, r27	; 0x05
    202e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    2030:	13 96       	adiw	r26, 0x03	; 3
    2032:	dc 93       	st	X, r29
    2034:	ce 93       	st	-X, r28
    2036:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2038:	59 87       	std	Y+9, r21	; 0x09
    203a:	48 87       	std	Y+8, r20	; 0x08

	( pxList->uxNumberOfItems )++;
    203c:	fa 01       	movw	r30, r20
    203e:	80 81       	ld	r24, Z
    2040:	8f 5f       	subi	r24, 0xFF	; 255
    2042:	80 83       	st	Z, r24
}
    2044:	df 91       	pop	r29
    2046:	cf 91       	pop	r28
    2048:	08 95       	ret

0000204a <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    204a:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    204c:	a2 81       	ldd	r26, Z+2	; 0x02
    204e:	b3 81       	ldd	r27, Z+3	; 0x03
    2050:	84 81       	ldd	r24, Z+4	; 0x04
    2052:	95 81       	ldd	r25, Z+5	; 0x05
    2054:	15 96       	adiw	r26, 0x05	; 5
    2056:	9c 93       	st	X, r25
    2058:	8e 93       	st	-X, r24
    205a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    205c:	a4 81       	ldd	r26, Z+4	; 0x04
    205e:	b5 81       	ldd	r27, Z+5	; 0x05
    2060:	82 81       	ldd	r24, Z+2	; 0x02
    2062:	93 81       	ldd	r25, Z+3	; 0x03
    2064:	13 96       	adiw	r26, 0x03	; 3
    2066:	9c 93       	st	X, r25
    2068:	8e 93       	st	-X, r24
    206a:	12 97       	sbiw	r26, 0x02	; 2

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    206c:	a0 85       	ldd	r26, Z+8	; 0x08
    206e:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    2070:	11 96       	adiw	r26, 0x01	; 1
    2072:	8d 91       	ld	r24, X+
    2074:	9c 91       	ld	r25, X
    2076:	12 97       	sbiw	r26, 0x02	; 2
    2078:	8e 17       	cp	r24, r30
    207a:	9f 07       	cpc	r25, r31
    207c:	31 f4       	brne	.+12     	; 0x208a <uxListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    207e:	84 81       	ldd	r24, Z+4	; 0x04
    2080:	95 81       	ldd	r25, Z+5	; 0x05
    2082:	12 96       	adiw	r26, 0x02	; 2
    2084:	9c 93       	st	X, r25
    2086:	8e 93       	st	-X, r24
    2088:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
    208a:	11 86       	std	Z+9, r1	; 0x09
    208c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    208e:	8c 91       	ld	r24, X
    2090:	81 50       	subi	r24, 0x01	; 1
    2092:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    2094:	8c 91       	ld	r24, X
}
    2096:	08 95       	ret

00002098 <pxPortInitialiseStack>:
#endif

	/* Place a few bytes of known values on the bottom of the stack.
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    2098:	21 e1       	ldi	r18, 0x11	; 17
    209a:	fc 01       	movw	r30, r24
    209c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    209e:	31 97       	sbiw	r30, 0x01	; 1
    20a0:	32 e2       	ldi	r19, 0x22	; 34
    20a2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    20a4:	fc 01       	movw	r30, r24
    20a6:	32 97       	sbiw	r30, 0x02	; 2
    20a8:	a3 e3       	ldi	r26, 0x33	; 51
    20aa:	a0 83       	st	Z, r26
	 *
	 * In order to do this properly, we would need to get a full 3-byte pointer to
	 * pxCode.  That requires a change to GCC.  Not likely to happen any time soon.
	 */
	usAddress = ( unsigned portSHORT ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    20ac:	fc 01       	movw	r30, r24
    20ae:	33 97       	sbiw	r30, 0x03	; 3
    20b0:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned portSHORT ) 0x00ff );
    20b2:	fc 01       	movw	r30, r24
    20b4:	34 97       	sbiw	r30, 0x04	; 4
    20b6:	70 83       	st	Z, r23
	pxTopOfStack--;

	*pxTopOfStack = 0;
    20b8:	fc 01       	movw	r30, r24
    20ba:	35 97       	sbiw	r30, 0x05	; 5
    20bc:	10 82       	st	Z, r1

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    20be:	fc 01       	movw	r30, r24
    20c0:	36 97       	sbiw	r30, 0x06	; 6
    20c2:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    20c4:	fc 01       	movw	r30, r24
    20c6:	37 97       	sbiw	r30, 0x07	; 7
    20c8:	60 e8       	ldi	r22, 0x80	; 128
    20ca:	60 83       	st	Z, r22
#if defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)

	/* If we have an ATmega256x, we are also saving the RAMPZ and EIND registers.
	 * We should default those to 0.
	 */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* EIND */
    20cc:	fc 01       	movw	r30, r24
    20ce:	38 97       	sbiw	r30, 0x08	; 8
    20d0:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* RAMPZ */
    20d2:	fc 01       	movw	r30, r24
    20d4:	39 97       	sbiw	r30, 0x09	; 9
    20d6:	10 82       	st	Z, r1
	pxTopOfStack--;

#endif

	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    20d8:	fc 01       	movw	r30, r24
    20da:	3a 97       	sbiw	r30, 0x0a	; 10
    20dc:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    20de:	fc 01       	movw	r30, r24
    20e0:	3b 97       	sbiw	r30, 0x0b	; 11
    20e2:	62 e0       	ldi	r22, 0x02	; 2
    20e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    20e6:	fc 01       	movw	r30, r24
    20e8:	3c 97       	sbiw	r30, 0x0c	; 12
    20ea:	63 e0       	ldi	r22, 0x03	; 3
    20ec:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    20ee:	fc 01       	movw	r30, r24
    20f0:	3d 97       	sbiw	r30, 0x0d	; 13
    20f2:	64 e0       	ldi	r22, 0x04	; 4
    20f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    20f6:	fc 01       	movw	r30, r24
    20f8:	3e 97       	sbiw	r30, 0x0e	; 14
    20fa:	65 e0       	ldi	r22, 0x05	; 5
    20fc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    20fe:	fc 01       	movw	r30, r24
    2100:	3f 97       	sbiw	r30, 0x0f	; 15
    2102:	66 e0       	ldi	r22, 0x06	; 6
    2104:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    2106:	fc 01       	movw	r30, r24
    2108:	70 97       	sbiw	r30, 0x10	; 16
    210a:	67 e0       	ldi	r22, 0x07	; 7
    210c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    210e:	fc 01       	movw	r30, r24
    2110:	71 97       	sbiw	r30, 0x11	; 17
    2112:	68 e0       	ldi	r22, 0x08	; 8
    2114:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    2116:	fc 01       	movw	r30, r24
    2118:	72 97       	sbiw	r30, 0x12	; 18
    211a:	69 e0       	ldi	r22, 0x09	; 9
    211c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    211e:	fc 01       	movw	r30, r24
    2120:	73 97       	sbiw	r30, 0x13	; 19
    2122:	60 e1       	ldi	r22, 0x10	; 16
    2124:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    2126:	fc 01       	movw	r30, r24
    2128:	74 97       	sbiw	r30, 0x14	; 20
    212a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    212c:	fc 01       	movw	r30, r24
    212e:	75 97       	sbiw	r30, 0x15	; 21
    2130:	22 e1       	ldi	r18, 0x12	; 18
    2132:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    2134:	fc 01       	movw	r30, r24
    2136:	76 97       	sbiw	r30, 0x16	; 22
    2138:	23 e1       	ldi	r18, 0x13	; 19
    213a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    213c:	fc 01       	movw	r30, r24
    213e:	77 97       	sbiw	r30, 0x17	; 23
    2140:	24 e1       	ldi	r18, 0x14	; 20
    2142:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    2144:	fc 01       	movw	r30, r24
    2146:	78 97       	sbiw	r30, 0x18	; 24
    2148:	25 e1       	ldi	r18, 0x15	; 21
    214a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    214c:	fc 01       	movw	r30, r24
    214e:	79 97       	sbiw	r30, 0x19	; 25
    2150:	26 e1       	ldi	r18, 0x16	; 22
    2152:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    2154:	fc 01       	movw	r30, r24
    2156:	7a 97       	sbiw	r30, 0x1a	; 26
    2158:	27 e1       	ldi	r18, 0x17	; 23
    215a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    215c:	fc 01       	movw	r30, r24
    215e:	7b 97       	sbiw	r30, 0x1b	; 27
    2160:	28 e1       	ldi	r18, 0x18	; 24
    2162:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    2164:	fc 01       	movw	r30, r24
    2166:	7c 97       	sbiw	r30, 0x1c	; 28
    2168:	29 e1       	ldi	r18, 0x19	; 25
    216a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    216c:	fc 01       	movw	r30, r24
    216e:	7d 97       	sbiw	r30, 0x1d	; 29
    2170:	20 e2       	ldi	r18, 0x20	; 32
    2172:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    2174:	fc 01       	movw	r30, r24
    2176:	7e 97       	sbiw	r30, 0x1e	; 30
    2178:	21 e2       	ldi	r18, 0x21	; 33
    217a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    217c:	fc 01       	movw	r30, r24
    217e:	7f 97       	sbiw	r30, 0x1f	; 31
    2180:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    2182:	fc 01       	movw	r30, r24
    2184:	b0 97       	sbiw	r30, 0x20	; 32
    2186:	23 e2       	ldi	r18, 0x23	; 35
    2188:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    218a:	fc 01       	movw	r30, r24
    218c:	b1 97       	sbiw	r30, 0x21	; 33
    218e:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    2190:	fc 01       	movw	r30, r24
    2192:	b2 97       	sbiw	r30, 0x22	; 34
    2194:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    2196:	fc 01       	movw	r30, r24
    2198:	b3 97       	sbiw	r30, 0x23	; 35
    219a:	26 e2       	ldi	r18, 0x26	; 38
    219c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    219e:	fc 01       	movw	r30, r24
    21a0:	b4 97       	sbiw	r30, 0x24	; 36
    21a2:	27 e2       	ldi	r18, 0x27	; 39
    21a4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    21a6:	fc 01       	movw	r30, r24
    21a8:	b5 97       	sbiw	r30, 0x25	; 37
    21aa:	28 e2       	ldi	r18, 0x28	; 40
    21ac:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    21ae:	fc 01       	movw	r30, r24
    21b0:	b6 97       	sbiw	r30, 0x26	; 38
    21b2:	29 e2       	ldi	r18, 0x29	; 41
    21b4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    21b6:	fc 01       	movw	r30, r24
    21b8:	b7 97       	sbiw	r30, 0x27	; 39
    21ba:	20 e3       	ldi	r18, 0x30	; 48
    21bc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    21be:	fc 01       	movw	r30, r24
    21c0:	b8 97       	sbiw	r30, 0x28	; 40
    21c2:	21 e3       	ldi	r18, 0x31	; 49
    21c4:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    21c6:	89 97       	sbiw	r24, 0x29	; 41
}
    21c8:	08 95       	ret

000021ca <xPortStartScheduler>:
    // the HiByte is only needed, if a 16 Bit counter is being utilized
#ifdef portOCRH

    ulCompareMatch >>= 8;
    ucHighByte = ( unsigned portCHAR ) ( ulCompareMatch & ( unsigned portLONG ) 0xff );
    portOCRH = ucHighByte;
    21ca:	10 92 99 00 	sts	0x0099, r1

#endif

    portOCRL = ucLowByte;
    21ce:	89 ef       	ldi	r24, 0xF9	; 249
    21d0:	80 93 98 00 	sts	0x0098, r24
	portTCCRb = ucLowByte;

#elif defined( portUSE_TIMER3 )
	/* Setup clock source and compare match behaviour. Assuming  640 / 1280 /1281 / 1284p / 2560 / 2561 (with Timer3) */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	portTCCRb = ucLowByte;
    21d4:	8b e0       	ldi	r24, 0x0B	; 11
    21d6:	80 93 91 00 	sts	0x0091, r24
#endif

    /* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
    ucLowByte = portTIMSK;
    21da:	e1 e7       	ldi	r30, 0x71	; 113
    21dc:	f0 e0       	ldi	r31, 0x00	; 0
    21de:	80 81       	ld	r24, Z
    ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    21e0:	82 60       	ori	r24, 0x02	; 2
    portTIMSK = ucLowByte;
    21e2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    21e4:	a0 91 d6 1a 	lds	r26, 0x1AD6
    21e8:	b0 91 d7 1a 	lds	r27, 0x1AD7
    21ec:	cd 91       	ld	r28, X+
    21ee:	cd bf       	out	0x3d, r28	; 61
    21f0:	dd 91       	ld	r29, X+
    21f2:	de bf       	out	0x3e, r29	; 62
    21f4:	ff 91       	pop	r31
    21f6:	ef 91       	pop	r30
    21f8:	df 91       	pop	r29
    21fa:	cf 91       	pop	r28
    21fc:	bf 91       	pop	r27
    21fe:	af 91       	pop	r26
    2200:	9f 91       	pop	r25
    2202:	8f 91       	pop	r24
    2204:	7f 91       	pop	r23
    2206:	6f 91       	pop	r22
    2208:	5f 91       	pop	r21
    220a:	4f 91       	pop	r20
    220c:	3f 91       	pop	r19
    220e:	2f 91       	pop	r18
    2210:	1f 91       	pop	r17
    2212:	0f 91       	pop	r16
    2214:	ff 90       	pop	r15
    2216:	ef 90       	pop	r14
    2218:	df 90       	pop	r13
    221a:	cf 90       	pop	r12
    221c:	bf 90       	pop	r11
    221e:	af 90       	pop	r10
    2220:	9f 90       	pop	r9
    2222:	8f 90       	pop	r8
    2224:	7f 90       	pop	r7
    2226:	6f 90       	pop	r6
    2228:	5f 90       	pop	r5
    222a:	4f 90       	pop	r4
    222c:	3f 90       	pop	r3
    222e:	2f 90       	pop	r2
    2230:	1f 90       	pop	r1
    2232:	0f 90       	pop	r0
    2234:	0c be       	out	0x3c, r0	; 60
    2236:	0f 90       	pop	r0
    2238:	0b be       	out	0x3b, r0	; 59
    223a:	0f 90       	pop	r0
    223c:	0f be       	out	0x3f, r0	; 63
    223e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    2240:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    2242:	81 e0       	ldi	r24, 0x01	; 1
    2244:	08 95       	ret

00002246 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    2246:	08 95       	ret

00002248 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    2248:	0f 92       	push	r0
    224a:	0f b6       	in	r0, 0x3f	; 63
    224c:	f8 94       	cli
    224e:	0f 92       	push	r0
    2250:	0b b6       	in	r0, 0x3b	; 59
    2252:	0f 92       	push	r0
    2254:	0c b6       	in	r0, 0x3c	; 60
    2256:	0f 92       	push	r0
    2258:	1f 92       	push	r1
    225a:	11 24       	eor	r1, r1
    225c:	2f 92       	push	r2
    225e:	3f 92       	push	r3
    2260:	4f 92       	push	r4
    2262:	5f 92       	push	r5
    2264:	6f 92       	push	r6
    2266:	7f 92       	push	r7
    2268:	8f 92       	push	r8
    226a:	9f 92       	push	r9
    226c:	af 92       	push	r10
    226e:	bf 92       	push	r11
    2270:	cf 92       	push	r12
    2272:	df 92       	push	r13
    2274:	ef 92       	push	r14
    2276:	ff 92       	push	r15
    2278:	0f 93       	push	r16
    227a:	1f 93       	push	r17
    227c:	2f 93       	push	r18
    227e:	3f 93       	push	r19
    2280:	4f 93       	push	r20
    2282:	5f 93       	push	r21
    2284:	6f 93       	push	r22
    2286:	7f 93       	push	r23
    2288:	8f 93       	push	r24
    228a:	9f 93       	push	r25
    228c:	af 93       	push	r26
    228e:	bf 93       	push	r27
    2290:	cf 93       	push	r28
    2292:	df 93       	push	r29
    2294:	ef 93       	push	r30
    2296:	ff 93       	push	r31
    2298:	a0 91 d6 1a 	lds	r26, 0x1AD6
    229c:	b0 91 d7 1a 	lds	r27, 0x1AD7
    22a0:	0d b6       	in	r0, 0x3d	; 61
    22a2:	0d 92       	st	X+, r0
    22a4:	0e b6       	in	r0, 0x3e	; 62
    22a6:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    22a8:	0e 94 4d 19 	call	0x329a	; 0x329a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    22ac:	a0 91 d6 1a 	lds	r26, 0x1AD6
    22b0:	b0 91 d7 1a 	lds	r27, 0x1AD7
    22b4:	cd 91       	ld	r28, X+
    22b6:	cd bf       	out	0x3d, r28	; 61
    22b8:	dd 91       	ld	r29, X+
    22ba:	de bf       	out	0x3e, r29	; 62
    22bc:	ff 91       	pop	r31
    22be:	ef 91       	pop	r30
    22c0:	df 91       	pop	r29
    22c2:	cf 91       	pop	r28
    22c4:	bf 91       	pop	r27
    22c6:	af 91       	pop	r26
    22c8:	9f 91       	pop	r25
    22ca:	8f 91       	pop	r24
    22cc:	7f 91       	pop	r23
    22ce:	6f 91       	pop	r22
    22d0:	5f 91       	pop	r21
    22d2:	4f 91       	pop	r20
    22d4:	3f 91       	pop	r19
    22d6:	2f 91       	pop	r18
    22d8:	1f 91       	pop	r17
    22da:	0f 91       	pop	r16
    22dc:	ff 90       	pop	r15
    22de:	ef 90       	pop	r14
    22e0:	df 90       	pop	r13
    22e2:	cf 90       	pop	r12
    22e4:	bf 90       	pop	r11
    22e6:	af 90       	pop	r10
    22e8:	9f 90       	pop	r9
    22ea:	8f 90       	pop	r8
    22ec:	7f 90       	pop	r7
    22ee:	6f 90       	pop	r6
    22f0:	5f 90       	pop	r5
    22f2:	4f 90       	pop	r4
    22f4:	3f 90       	pop	r3
    22f6:	2f 90       	pop	r2
    22f8:	1f 90       	pop	r1
    22fa:	0f 90       	pop	r0
    22fc:	0c be       	out	0x3c, r0	; 60
    22fe:	0f 90       	pop	r0
    2300:	0b be       	out	0x3b, r0	; 59
    2302:	0f 90       	pop	r0
    2304:	0f be       	out	0x3f, r0	; 63
    2306:	0f 90       	pop	r0

	asm volatile ( "ret" );
    2308:	08 95       	ret

0000230a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    230a:	0f 92       	push	r0
    230c:	0f b6       	in	r0, 0x3f	; 63
    230e:	f8 94       	cli
    2310:	0f 92       	push	r0
    2312:	0b b6       	in	r0, 0x3b	; 59
    2314:	0f 92       	push	r0
    2316:	0c b6       	in	r0, 0x3c	; 60
    2318:	0f 92       	push	r0
    231a:	1f 92       	push	r1
    231c:	11 24       	eor	r1, r1
    231e:	2f 92       	push	r2
    2320:	3f 92       	push	r3
    2322:	4f 92       	push	r4
    2324:	5f 92       	push	r5
    2326:	6f 92       	push	r6
    2328:	7f 92       	push	r7
    232a:	8f 92       	push	r8
    232c:	9f 92       	push	r9
    232e:	af 92       	push	r10
    2330:	bf 92       	push	r11
    2332:	cf 92       	push	r12
    2334:	df 92       	push	r13
    2336:	ef 92       	push	r14
    2338:	ff 92       	push	r15
    233a:	0f 93       	push	r16
    233c:	1f 93       	push	r17
    233e:	2f 93       	push	r18
    2340:	3f 93       	push	r19
    2342:	4f 93       	push	r20
    2344:	5f 93       	push	r21
    2346:	6f 93       	push	r22
    2348:	7f 93       	push	r23
    234a:	8f 93       	push	r24
    234c:	9f 93       	push	r25
    234e:	af 93       	push	r26
    2350:	bf 93       	push	r27
    2352:	cf 93       	push	r28
    2354:	df 93       	push	r29
    2356:	ef 93       	push	r30
    2358:	ff 93       	push	r31
    235a:	a0 91 d6 1a 	lds	r26, 0x1AD6
    235e:	b0 91 d7 1a 	lds	r27, 0x1AD7
    2362:	0d b6       	in	r0, 0x3d	; 61
    2364:	0d 92       	st	X+, r0
    2366:	0e b6       	in	r0, 0x3e	; 62
    2368:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    236a:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <vTaskIncrementTick>
	vTaskSwitchContext();
    236e:	0e 94 4d 19 	call	0x329a	; 0x329a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    2372:	a0 91 d6 1a 	lds	r26, 0x1AD6
    2376:	b0 91 d7 1a 	lds	r27, 0x1AD7
    237a:	cd 91       	ld	r28, X+
    237c:	cd bf       	out	0x3d, r28	; 61
    237e:	dd 91       	ld	r29, X+
    2380:	de bf       	out	0x3e, r29	; 62
    2382:	ff 91       	pop	r31
    2384:	ef 91       	pop	r30
    2386:	df 91       	pop	r29
    2388:	cf 91       	pop	r28
    238a:	bf 91       	pop	r27
    238c:	af 91       	pop	r26
    238e:	9f 91       	pop	r25
    2390:	8f 91       	pop	r24
    2392:	7f 91       	pop	r23
    2394:	6f 91       	pop	r22
    2396:	5f 91       	pop	r21
    2398:	4f 91       	pop	r20
    239a:	3f 91       	pop	r19
    239c:	2f 91       	pop	r18
    239e:	1f 91       	pop	r17
    23a0:	0f 91       	pop	r16
    23a2:	ff 90       	pop	r15
    23a4:	ef 90       	pop	r14
    23a6:	df 90       	pop	r13
    23a8:	cf 90       	pop	r12
    23aa:	bf 90       	pop	r11
    23ac:	af 90       	pop	r10
    23ae:	9f 90       	pop	r9
    23b0:	8f 90       	pop	r8
    23b2:	7f 90       	pop	r7
    23b4:	6f 90       	pop	r6
    23b6:	5f 90       	pop	r5
    23b8:	4f 90       	pop	r4
    23ba:	3f 90       	pop	r3
    23bc:	2f 90       	pop	r2
    23be:	1f 90       	pop	r1
    23c0:	0f 90       	pop	r0
    23c2:	0c be       	out	0x3c, r0	; 60
    23c4:	0f 90       	pop	r0
    23c6:	0b be       	out	0x3b, r0	; 59
    23c8:	0f 90       	pop	r0
    23ca:	0f be       	out	0x3f, r0	; 63
    23cc:	0f 90       	pop	r0

	asm volatile ( "ret" );
    23ce:	08 95       	ret

000023d0 <__vector_32>:

	#elif defined( portUSE_TIMER3 )
		#warning "Timer3 used for PRE-EMPTIVE scheduler."
		ISR(TIMER3_COMPA_vect, ISR_NAKED)
		{
			vPortYieldFromTick();
    23d0:	0e 94 85 11 	call	0x230a	; 0x230a <vPortYieldFromTick>
			asm volatile ( "reti" );
    23d4:	18 95       	reti

000023d6 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    23d6:	cf 93       	push	r28
    23d8:	df 93       	push	r29
    23da:	dc 01       	movw	r26, r24
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    23dc:	cd 91       	ld	r28, X+
    23de:	dc 91       	ld	r29, X
    23e0:	11 97       	sbiw	r26, 0x01	; 1
    23e2:	20 97       	sbiw	r28, 0x00	; 0
    23e4:	21 f1       	breq	.+72     	; 0x242e <prvCopyDataFromQueue+0x58>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    23e6:	5c 96       	adiw	r26, 0x1c	; 28
    23e8:	4c 91       	ld	r20, X
    23ea:	5c 97       	sbiw	r26, 0x1c	; 28
    23ec:	16 96       	adiw	r26, 0x06	; 6
    23ee:	2d 91       	ld	r18, X+
    23f0:	3c 91       	ld	r19, X
    23f2:	17 97       	sbiw	r26, 0x07	; 7
    23f4:	24 0f       	add	r18, r20
    23f6:	31 1d       	adc	r19, r1
    23f8:	17 96       	adiw	r26, 0x07	; 7
    23fa:	3c 93       	st	X, r19
    23fc:	2e 93       	st	-X, r18
    23fe:	16 97       	sbiw	r26, 0x06	; 6
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    2400:	12 96       	adiw	r26, 0x02	; 2
    2402:	ed 91       	ld	r30, X+
    2404:	fc 91       	ld	r31, X
    2406:	13 97       	sbiw	r26, 0x03	; 3
    2408:	2e 17       	cp	r18, r30
    240a:	3f 07       	cpc	r19, r31
    240c:	20 f0       	brcs	.+8      	; 0x2416 <prvCopyDataFromQueue+0x40>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    240e:	17 96       	adiw	r26, 0x07	; 7
    2410:	dc 93       	st	X, r29
    2412:	ce 93       	st	-X, r28
    2414:	16 97       	sbiw	r26, 0x06	; 6
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2416:	16 96       	adiw	r26, 0x06	; 6
    2418:	3c 91       	ld	r19, X
    241a:	16 97       	sbiw	r26, 0x06	; 6
    241c:	17 96       	adiw	r26, 0x07	; 7
    241e:	2c 91       	ld	r18, X
    2420:	86 2f       	mov	r24, r22
    2422:	97 2f       	mov	r25, r23
    2424:	63 2f       	mov	r22, r19
    2426:	72 2f       	mov	r23, r18
    2428:	50 e0       	ldi	r21, 0x00	; 0
    242a:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <memcpy>
	}
}
    242e:	df 91       	pop	r29
    2430:	cf 91       	pop	r28
    2432:	08 95       	ret

00002434 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    2434:	0f 93       	push	r16
    2436:	1f 93       	push	r17
    2438:	cf 93       	push	r28
    243a:	df 93       	push	r29
    243c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    243e:	0f b6       	in	r0, 0x3f	; 63
    2440:	f8 94       	cli
    2442:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2444:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2446:	18 16       	cp	r1, r24
    2448:	c4 f4       	brge	.+48     	; 0x247a <prvUnlockQueue+0x46>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    244a:	89 89       	ldd	r24, Y+17	; 0x11
    244c:	88 23       	and	r24, r24
    244e:	29 f4       	brne	.+10     	; 0x245a <prvUnlockQueue+0x26>
    2450:	14 c0       	rjmp	.+40     	; 0x247a <prvUnlockQueue+0x46>
    2452:	89 89       	ldd	r24, Y+17	; 0x11
    2454:	88 23       	and	r24, r24
    2456:	21 f4       	brne	.+8      	; 0x2460 <prvUnlockQueue+0x2c>
    2458:	10 c0       	rjmp	.+32     	; 0x247a <prvUnlockQueue+0x46>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    245a:	8e 01       	movw	r16, r28
    245c:	0f 5e       	subi	r16, 0xEF	; 239
    245e:	1f 4f       	sbci	r17, 0xFF	; 255
    2460:	c8 01       	movw	r24, r16
    2462:	0e 94 26 1a 	call	0x344c	; 0x344c <xTaskRemoveFromEventList>
    2466:	88 23       	and	r24, r24
    2468:	11 f0       	breq	.+4      	; 0x246e <prvUnlockQueue+0x3a>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    246a:	0e 94 b7 1a 	call	0x356e	; 0x356e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    246e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2470:	81 50       	subi	r24, 0x01	; 1
    2472:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2474:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2476:	18 16       	cp	r1, r24
    2478:	64 f3       	brlt	.-40     	; 0x2452 <prvUnlockQueue+0x1e>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    247a:	8f ef       	ldi	r24, 0xFF	; 255
    247c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    247e:	0f 90       	pop	r0
    2480:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2482:	0f b6       	in	r0, 0x3f	; 63
    2484:	f8 94       	cli
    2486:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2488:	8d 8d       	ldd	r24, Y+29	; 0x1d
    248a:	18 16       	cp	r1, r24
    248c:	c4 f4       	brge	.+48     	; 0x24be <prvUnlockQueue+0x8a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    248e:	88 85       	ldd	r24, Y+8	; 0x08
    2490:	88 23       	and	r24, r24
    2492:	29 f4       	brne	.+10     	; 0x249e <prvUnlockQueue+0x6a>
    2494:	14 c0       	rjmp	.+40     	; 0x24be <prvUnlockQueue+0x8a>
    2496:	88 85       	ldd	r24, Y+8	; 0x08
    2498:	88 23       	and	r24, r24
    249a:	21 f4       	brne	.+8      	; 0x24a4 <prvUnlockQueue+0x70>
    249c:	10 c0       	rjmp	.+32     	; 0x24be <prvUnlockQueue+0x8a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    249e:	8e 01       	movw	r16, r28
    24a0:	08 5f       	subi	r16, 0xF8	; 248
    24a2:	1f 4f       	sbci	r17, 0xFF	; 255
    24a4:	c8 01       	movw	r24, r16
    24a6:	0e 94 26 1a 	call	0x344c	; 0x344c <xTaskRemoveFromEventList>
    24aa:	88 23       	and	r24, r24
    24ac:	11 f0       	breq	.+4      	; 0x24b2 <prvUnlockQueue+0x7e>
				{
					vTaskMissedYield();
    24ae:	0e 94 b7 1a 	call	0x356e	; 0x356e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    24b2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    24b4:	81 50       	subi	r24, 0x01	; 1
    24b6:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    24b8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    24ba:	18 16       	cp	r1, r24
    24bc:	64 f3       	brlt	.-40     	; 0x2496 <prvUnlockQueue+0x62>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    24be:	8f ef       	ldi	r24, 0xFF	; 255
    24c0:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    24c2:	0f 90       	pop	r0
    24c4:	0f be       	out	0x3f, r0	; 63
}
    24c6:	df 91       	pop	r29
    24c8:	cf 91       	pop	r28
    24ca:	1f 91       	pop	r17
    24cc:	0f 91       	pop	r16
    24ce:	08 95       	ret

000024d0 <prvCopyDataToQueue>:

#endif
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    24d0:	cf 93       	push	r28
    24d2:	df 93       	push	r29
    24d4:	ec 01       	movw	r28, r24
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    24d6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    24d8:	22 23       	and	r18, r18
    24da:	59 f4       	brne	.+22     	; 0x24f2 <prvCopyDataToQueue+0x22>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    24dc:	88 81       	ld	r24, Y
    24de:	99 81       	ldd	r25, Y+1	; 0x01
    24e0:	00 97       	sbiw	r24, 0x00	; 0
    24e2:	e1 f5       	brne	.+120    	; 0x255c <prvCopyDataToQueue+0x8c>
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
    24e4:	8a 81       	ldd	r24, Y+2	; 0x02
    24e6:	9b 81       	ldd	r25, Y+3	; 0x03
    24e8:	0e 94 33 1b 	call	0x3666	; 0x3666 <vTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
    24ec:	1b 82       	std	Y+3, r1	; 0x03
    24ee:	1a 82       	std	Y+2, r1	; 0x02
    24f0:	35 c0       	rjmp	.+106    	; 0x255c <prvCopyDataToQueue+0x8c>
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    24f2:	44 23       	and	r20, r20
    24f4:	b9 f4       	brne	.+46     	; 0x2524 <prvCopyDataToQueue+0x54>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    24f6:	8c 81       	ldd	r24, Y+4	; 0x04
    24f8:	9d 81       	ldd	r25, Y+5	; 0x05
    24fa:	42 2f       	mov	r20, r18
    24fc:	50 e0       	ldi	r21, 0x00	; 0
    24fe:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    2502:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2504:	8c 81       	ldd	r24, Y+4	; 0x04
    2506:	9d 81       	ldd	r25, Y+5	; 0x05
    2508:	82 0f       	add	r24, r18
    250a:	91 1d       	adc	r25, r1
    250c:	9d 83       	std	Y+5, r25	; 0x05
    250e:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    2510:	2a 81       	ldd	r18, Y+2	; 0x02
    2512:	3b 81       	ldd	r19, Y+3	; 0x03
    2514:	82 17       	cp	r24, r18
    2516:	93 07       	cpc	r25, r19
    2518:	08 f1       	brcs	.+66     	; 0x255c <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    251a:	88 81       	ld	r24, Y
    251c:	99 81       	ldd	r25, Y+1	; 0x01
    251e:	9d 83       	std	Y+5, r25	; 0x05
    2520:	8c 83       	std	Y+4, r24	; 0x04
    2522:	1c c0       	rjmp	.+56     	; 0x255c <prvCopyDataToQueue+0x8c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2524:	8e 81       	ldd	r24, Y+6	; 0x06
    2526:	9f 81       	ldd	r25, Y+7	; 0x07
    2528:	42 2f       	mov	r20, r18
    252a:	50 e0       	ldi	r21, 0x00	; 0
    252c:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2530:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2532:	50 e0       	ldi	r21, 0x00	; 0
    2534:	50 95       	com	r21
    2536:	41 95       	neg	r20
    2538:	5f 4f       	sbci	r21, 0xFF	; 255
    253a:	8e 81       	ldd	r24, Y+6	; 0x06
    253c:	9f 81       	ldd	r25, Y+7	; 0x07
    253e:	84 0f       	add	r24, r20
    2540:	95 1f       	adc	r25, r21
    2542:	9f 83       	std	Y+7, r25	; 0x07
    2544:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    2546:	28 81       	ld	r18, Y
    2548:	39 81       	ldd	r19, Y+1	; 0x01
    254a:	82 17       	cp	r24, r18
    254c:	93 07       	cpc	r25, r19
    254e:	30 f4       	brcc	.+12     	; 0x255c <prvCopyDataToQueue+0x8c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    2550:	8a 81       	ldd	r24, Y+2	; 0x02
    2552:	9b 81       	ldd	r25, Y+3	; 0x03
    2554:	48 0f       	add	r20, r24
    2556:	59 1f       	adc	r21, r25
    2558:	5f 83       	std	Y+7, r21	; 0x07
    255a:	4e 83       	std	Y+6, r20	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    255c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    255e:	8f 5f       	subi	r24, 0xFF	; 255
    2560:	8a 8f       	std	Y+26, r24	; 0x1a
}
    2562:	df 91       	pop	r29
    2564:	cf 91       	pop	r28
    2566:	08 95       	ret

00002568 <xQueueGenericReset>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle pxQueue, portBASE_TYPE xNewQueue )
{
    2568:	cf 93       	push	r28
    256a:	df 93       	push	r29
    256c:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    256e:	0f b6       	in	r0, 0x3f	; 63
    2570:	f8 94       	cli
    2572:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    2574:	48 81       	ld	r20, Y
    2576:	59 81       	ldd	r21, Y+1	; 0x01
    2578:	2b 8d       	ldd	r18, Y+27	; 0x1b
    257a:	30 e0       	ldi	r19, 0x00	; 0
    257c:	ec 8d       	ldd	r30, Y+28	; 0x1c
    257e:	f0 e0       	ldi	r31, 0x00	; 0
    2580:	2e 9f       	mul	r18, r30
    2582:	c0 01       	movw	r24, r0
    2584:	2f 9f       	mul	r18, r31
    2586:	90 0d       	add	r25, r0
    2588:	3e 9f       	mul	r19, r30
    258a:	90 0d       	add	r25, r0
    258c:	11 24       	eor	r1, r1
    258e:	84 0f       	add	r24, r20
    2590:	95 1f       	adc	r25, r21
    2592:	9b 83       	std	Y+3, r25	; 0x03
    2594:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    2596:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    2598:	5d 83       	std	Y+5, r21	; 0x05
    259a:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    259c:	c9 01       	movw	r24, r18
    259e:	01 97       	sbiw	r24, 0x01	; 1
    25a0:	e8 9f       	mul	r30, r24
    25a2:	90 01       	movw	r18, r0
    25a4:	e9 9f       	mul	r30, r25
    25a6:	30 0d       	add	r19, r0
    25a8:	f8 9f       	mul	r31, r24
    25aa:	30 0d       	add	r19, r0
    25ac:	11 24       	eor	r1, r1
    25ae:	24 0f       	add	r18, r20
    25b0:	35 1f       	adc	r19, r21
    25b2:	3f 83       	std	Y+7, r19	; 0x07
    25b4:	2e 83       	std	Y+6, r18	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    25b6:	8f ef       	ldi	r24, 0xFF	; 255
    25b8:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    25ba:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    25bc:	66 23       	and	r22, r22
    25be:	61 f4       	brne	.+24     	; 0x25d8 <xQueueGenericReset+0x70>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    25c0:	88 85       	ldd	r24, Y+8	; 0x08
    25c2:	88 23       	and	r24, r24
    25c4:	89 f0       	breq	.+34     	; 0x25e8 <xQueueGenericReset+0x80>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    25c6:	ce 01       	movw	r24, r28
    25c8:	08 96       	adiw	r24, 0x08	; 8
    25ca:	0e 94 26 1a 	call	0x344c	; 0x344c <xTaskRemoveFromEventList>
    25ce:	81 30       	cpi	r24, 0x01	; 1
    25d0:	59 f4       	brne	.+22     	; 0x25e8 <xQueueGenericReset+0x80>
				{
					portYIELD_WITHIN_API();
    25d2:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
    25d6:	08 c0       	rjmp	.+16     	; 0x25e8 <xQueueGenericReset+0x80>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    25d8:	ce 01       	movw	r24, r28
    25da:	08 96       	adiw	r24, 0x08	; 8
    25dc:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    25e0:	ce 01       	movw	r24, r28
    25e2:	41 96       	adiw	r24, 0x11	; 17
    25e4:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    25e8:	0f 90       	pop	r0
    25ea:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    25ec:	81 e0       	ldi	r24, 0x01	; 1
    25ee:	df 91       	pop	r29
    25f0:	cf 91       	pop	r28
    25f2:	08 95       	ret

000025f4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    25f4:	0f 93       	push	r16
    25f6:	1f 93       	push	r17
    25f8:	cf 93       	push	r28
    25fa:	df 93       	push	r29
    25fc:	18 2f       	mov	r17, r24
    25fe:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    2600:	88 23       	and	r24, r24
    2602:	f9 f0       	breq	.+62     	; 0x2642 <xQueueGenericCreate+0x4e>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2604:	8f e1       	ldi	r24, 0x1F	; 31
    2606:	90 e0       	ldi	r25, 0x00	; 0
    2608:	0e 94 af 0c 	call	0x195e	; 0x195e <pvPortMalloc>
    260c:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    260e:	00 97       	sbiw	r24, 0x00	; 0
    2610:	d9 f0       	breq	.+54     	; 0x2648 <xQueueGenericCreate+0x54>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    2612:	01 9f       	mul	r16, r17
    2614:	c0 01       	movw	r24, r0
    2616:	11 24       	eor	r1, r1

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    2618:	01 96       	adiw	r24, 0x01	; 1
    261a:	0e 94 af 0c 	call	0x195e	; 0x195e <pvPortMalloc>
    261e:	99 83       	std	Y+1, r25	; 0x01
    2620:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    2622:	00 97       	sbiw	r24, 0x00	; 0
    2624:	41 f0       	breq	.+16     	; 0x2636 <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    2626:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    2628:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    262a:	ce 01       	movw	r24, r28
    262c:	61 e0       	ldi	r22, 0x01	; 1
    262e:	0e 94 b4 12 	call	0x2568	; 0x2568 <xQueueGenericReset>
					pxNewQueue->ucQueueType = ucQueueType;
				}
				#endif /* configUSE_TRACE_FACILITY */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    2632:	ce 01       	movw	r24, r28
    2634:	0b c0       	rjmp	.+22     	; 0x264c <xQueueGenericCreate+0x58>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    2636:	ce 01       	movw	r24, r28
    2638:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    263c:	80 e0       	ldi	r24, 0x00	; 0
    263e:	90 e0       	ldi	r25, 0x00	; 0
    2640:	05 c0       	rjmp	.+10     	; 0x264c <xQueueGenericCreate+0x58>
    2642:	80 e0       	ldi	r24, 0x00	; 0
    2644:	90 e0       	ldi	r25, 0x00	; 0
    2646:	02 c0       	rjmp	.+4      	; 0x264c <xQueueGenericCreate+0x58>
    2648:	80 e0       	ldi	r24, 0x00	; 0
    264a:	90 e0       	ldi	r25, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    264c:	df 91       	pop	r29
    264e:	cf 91       	pop	r28
    2650:	1f 91       	pop	r17
    2652:	0f 91       	pop	r16
    2654:	08 95       	ret

00002656 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    2656:	8f 92       	push	r8
    2658:	9f 92       	push	r9
    265a:	bf 92       	push	r11
    265c:	cf 92       	push	r12
    265e:	df 92       	push	r13
    2660:	ef 92       	push	r14
    2662:	ff 92       	push	r15
    2664:	0f 93       	push	r16
    2666:	1f 93       	push	r17
    2668:	cf 93       	push	r28
    266a:	df 93       	push	r29
    266c:	00 d0       	rcall	.+0      	; 0x266e <xQueueGenericSend+0x18>
    266e:	0f 92       	push	r0
    2670:	0f 92       	push	r0
    2672:	cd b7       	in	r28, 0x3d	; 61
    2674:	de b7       	in	r29, 0x3e	; 62
    2676:	8c 01       	movw	r16, r24
    2678:	4b 01       	movw	r8, r22
    267a:	5d 83       	std	Y+5, r21	; 0x05
    267c:	4c 83       	std	Y+4, r20	; 0x04
    267e:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2680:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2682:	ee 24       	eor	r14, r14
    2684:	e3 94       	inc	r14
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2686:	cc 24       	eor	r12, r12
    2688:	dd 24       	eor	r13, r13
    268a:	68 94       	set
    268c:	c3 f8       	bld	r12, 3
    268e:	c8 0e       	add	r12, r24
    2690:	d9 1e       	adc	r13, r25
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2692:	0f b6       	in	r0, 0x3f	; 63
    2694:	f8 94       	cli
    2696:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2698:	f8 01       	movw	r30, r16
    269a:	92 8d       	ldd	r25, Z+26	; 0x1a
    269c:	83 8d       	ldd	r24, Z+27	; 0x1b
    269e:	98 17       	cp	r25, r24
    26a0:	a8 f4       	brcc	.+42     	; 0x26cc <xQueueGenericSend+0x76>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    26a2:	c8 01       	movw	r24, r16
    26a4:	b4 01       	movw	r22, r8
    26a6:	4b 2d       	mov	r20, r11
    26a8:	0e 94 68 12 	call	0x24d0	; 0x24d0 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    26ac:	f8 01       	movw	r30, r16
    26ae:	81 89       	ldd	r24, Z+17	; 0x11
    26b0:	88 23       	and	r24, r24
    26b2:	41 f0       	breq	.+16     	; 0x26c4 <xQueueGenericSend+0x6e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    26b4:	c8 01       	movw	r24, r16
    26b6:	41 96       	adiw	r24, 0x11	; 17
    26b8:	0e 94 26 1a 	call	0x344c	; 0x344c <xTaskRemoveFromEventList>
    26bc:	81 30       	cpi	r24, 0x01	; 1
    26be:	11 f4       	brne	.+4      	; 0x26c4 <xQueueGenericSend+0x6e>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    26c0:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    26c4:	0f 90       	pop	r0
    26c6:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    26c8:	81 e0       	ldi	r24, 0x01	; 1
    26ca:	52 c0       	rjmp	.+164    	; 0x2770 <xQueueGenericSend+0x11a>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    26cc:	8c 81       	ldd	r24, Y+4	; 0x04
    26ce:	9d 81       	ldd	r25, Y+5	; 0x05
    26d0:	00 97       	sbiw	r24, 0x00	; 0
    26d2:	21 f4       	brne	.+8      	; 0x26dc <xQueueGenericSend+0x86>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    26d4:	0f 90       	pop	r0
    26d6:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    26d8:	80 e0       	ldi	r24, 0x00	; 0
    26da:	4a c0       	rjmp	.+148    	; 0x2770 <xQueueGenericSend+0x11a>
				}
				else if( xEntryTimeSet == pdFALSE )
    26dc:	ff 20       	and	r15, r15
    26de:	29 f4       	brne	.+10     	; 0x26ea <xQueueGenericSend+0x94>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    26e0:	ce 01       	movw	r24, r28
    26e2:	01 96       	adiw	r24, 0x01	; 1
    26e4:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    26e8:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    26ea:	0f 90       	pop	r0
    26ec:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    26ee:	0e 94 75 17 	call	0x2eea	; 0x2eea <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    26f2:	0f b6       	in	r0, 0x3f	; 63
    26f4:	f8 94       	cli
    26f6:	0f 92       	push	r0
    26f8:	f8 01       	movw	r30, r16
    26fa:	85 8d       	ldd	r24, Z+29	; 0x1d
    26fc:	8f 3f       	cpi	r24, 0xFF	; 255
    26fe:	09 f4       	brne	.+2      	; 0x2702 <xQueueGenericSend+0xac>
    2700:	15 8e       	std	Z+29, r1	; 0x1d
    2702:	f8 01       	movw	r30, r16
    2704:	86 8d       	ldd	r24, Z+30	; 0x1e
    2706:	8f 3f       	cpi	r24, 0xFF	; 255
    2708:	09 f4       	brne	.+2      	; 0x270c <xQueueGenericSend+0xb6>
    270a:	16 8e       	std	Z+30, r1	; 0x1e
    270c:	0f 90       	pop	r0
    270e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2710:	ce 01       	movw	r24, r28
    2712:	01 96       	adiw	r24, 0x01	; 1
    2714:	be 01       	movw	r22, r28
    2716:	6c 5f       	subi	r22, 0xFC	; 252
    2718:	7f 4f       	sbci	r23, 0xFF	; 255
    271a:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <xTaskCheckForTimeOut>
    271e:	88 23       	and	r24, r24
    2720:	09 f5       	brne	.+66     	; 0x2764 <xQueueGenericSend+0x10e>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2722:	0f b6       	in	r0, 0x3f	; 63
    2724:	f8 94       	cli
    2726:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2728:	f8 01       	movw	r30, r16
    272a:	92 8d       	ldd	r25, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    272c:	0f 90       	pop	r0
    272e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    2730:	f8 01       	movw	r30, r16
    2732:	83 8d       	ldd	r24, Z+27	; 0x1b
    2734:	98 17       	cp	r25, r24
    2736:	81 f4       	brne	.+32     	; 0x2758 <xQueueGenericSend+0x102>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2738:	6c 81       	ldd	r22, Y+4	; 0x04
    273a:	7d 81       	ldd	r23, Y+5	; 0x05
    273c:	c6 01       	movw	r24, r12
    273e:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2742:	c8 01       	movw	r24, r16
    2744:	0e 94 1a 12 	call	0x2434	; 0x2434 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2748:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>
    274c:	88 23       	and	r24, r24
    274e:	09 f0       	breq	.+2      	; 0x2752 <xQueueGenericSend+0xfc>
    2750:	a0 cf       	rjmp	.-192    	; 0x2692 <xQueueGenericSend+0x3c>
				{
					portYIELD_WITHIN_API();
    2752:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
    2756:	9d cf       	rjmp	.-198    	; 0x2692 <xQueueGenericSend+0x3c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2758:	c8 01       	movw	r24, r16
    275a:	0e 94 1a 12 	call	0x2434	; 0x2434 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    275e:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>
    2762:	97 cf       	rjmp	.-210    	; 0x2692 <xQueueGenericSend+0x3c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2764:	c8 01       	movw	r24, r16
    2766:	0e 94 1a 12 	call	0x2434	; 0x2434 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    276a:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    276e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2770:	0f 90       	pop	r0
    2772:	0f 90       	pop	r0
    2774:	0f 90       	pop	r0
    2776:	0f 90       	pop	r0
    2778:	0f 90       	pop	r0
    277a:	df 91       	pop	r29
    277c:	cf 91       	pop	r28
    277e:	1f 91       	pop	r17
    2780:	0f 91       	pop	r16
    2782:	ff 90       	pop	r15
    2784:	ef 90       	pop	r14
    2786:	df 90       	pop	r13
    2788:	cf 90       	pop	r12
    278a:	bf 90       	pop	r11
    278c:	9f 90       	pop	r9
    278e:	8f 90       	pop	r8
    2790:	08 95       	ret

00002792 <xQueueCreateMutex>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	xQueueHandle xQueueCreateMutex( unsigned char ucQueueType )
	{
    2792:	cf 93       	push	r28
    2794:	df 93       	push	r29
		/* Prevent compiler warnings about unused parameters if
		configUSE_TRACE_FACILITY does not equal 1. */
		( void ) ucQueueType;

		/* Allocate the new queue structure. */
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    2796:	8f e1       	ldi	r24, 0x1F	; 31
    2798:	90 e0       	ldi	r25, 0x00	; 0
    279a:	0e 94 af 0c 	call	0x195e	; 0x195e <pvPortMalloc>
    279e:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    27a0:	00 97       	sbiw	r24, 0x00	; 0
    27a2:	f9 f0       	breq	.+62     	; 0x27e2 <xQueueCreateMutex+0x50>
		{
			/* Information required for priority inheritance. */
			pxNewQueue->pxMutexHolder = NULL;
    27a4:	1b 82       	std	Y+3, r1	; 0x03
    27a6:	1a 82       	std	Y+2, r1	; 0x02
			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
    27a8:	19 82       	std	Y+1, r1	; 0x01
    27aa:	18 82       	st	Y, r1

			/* Queues used as a mutex no data is actually copied into or out
			of the queue. */
			pxNewQueue->pcWriteTo = NULL;
    27ac:	1d 82       	std	Y+5, r1	; 0x05
    27ae:	1c 82       	std	Y+4, r1	; 0x04
			pxNewQueue->pcReadFrom = NULL;
    27b0:	1f 82       	std	Y+7, r1	; 0x07
    27b2:	1e 82       	std	Y+6, r1	; 0x06

			/* Each mutex has a length of 1 (like a binary semaphore) and
			an item size of 0 as nothing is actually copied into or out
			of the mutex. */
			pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    27b4:	1a 8e       	std	Y+26, r1	; 0x1a
			pxNewQueue->uxLength = ( unsigned portBASE_TYPE ) 1U;
    27b6:	81 e0       	ldi	r24, 0x01	; 1
    27b8:	8b 8f       	std	Y+27, r24	; 0x1b
			pxNewQueue->uxItemSize = ( unsigned portBASE_TYPE ) 0U;
    27ba:	1c 8e       	std	Y+28, r1	; 0x1c
			pxNewQueue->xRxLock = queueUNLOCKED;
    27bc:	8f ef       	ldi	r24, 0xFF	; 255
    27be:	8d 8f       	std	Y+29, r24	; 0x1d
			pxNewQueue->xTxLock = queueUNLOCKED;
    27c0:	8e 8f       	std	Y+30, r24	; 0x1e
				pxNewQueue->ucQueueType = ucQueueType;
			}
			#endif

			/* Ensure the event queues start with the correct state. */
			vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    27c2:	ce 01       	movw	r24, r28
    27c4:	08 96       	adiw	r24, 0x08	; 8
    27c6:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
			vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    27ca:	ce 01       	movw	r24, r28
    27cc:	41 96       	adiw	r24, 0x11	; 17
    27ce:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>

			traceCREATE_MUTEX( pxNewQueue );

			/* Start with the semaphore in the expected state. */
			xQueueGenericSend( pxNewQueue, NULL, ( portTickType ) 0U, queueSEND_TO_BACK );
    27d2:	ce 01       	movw	r24, r28
    27d4:	60 e0       	ldi	r22, 0x00	; 0
    27d6:	70 e0       	ldi	r23, 0x00	; 0
    27d8:	40 e0       	ldi	r20, 0x00	; 0
    27da:	50 e0       	ldi	r21, 0x00	; 0
    27dc:	20 e0       	ldi	r18, 0x00	; 0
    27de:	0e 94 2b 13 	call	0x2656	; 0x2656 <xQueueGenericSend>
			traceCREATE_MUTEX_FAILED();
		}

		configASSERT( pxNewQueue );
		return pxNewQueue;
	}
    27e2:	8c 2f       	mov	r24, r28
    27e4:	9d 2f       	mov	r25, r29
    27e6:	df 91       	pop	r29
    27e8:	cf 91       	pop	r28
    27ea:	08 95       	ret

000027ec <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    27ec:	0f 93       	push	r16
    27ee:	1f 93       	push	r17
    27f0:	cf 93       	push	r28
    27f2:	df 93       	push	r29
    27f4:	ec 01       	movw	r28, r24
    27f6:	8a 01       	movw	r16, r20
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    27f8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    27fa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    27fc:	98 17       	cp	r25, r24
    27fe:	e0 f4       	brcc	.+56     	; 0x2838 <xQueueGenericSendFromISR+0x4c>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    2800:	ce 01       	movw	r24, r28
    2802:	42 2f       	mov	r20, r18
    2804:	0e 94 68 12 	call	0x24d0	; 0x24d0 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2808:	8e 8d       	ldd	r24, Y+30	; 0x1e
    280a:	8f 3f       	cpi	r24, 0xFF	; 255
    280c:	81 f4       	brne	.+32     	; 0x282e <xQueueGenericSendFromISR+0x42>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    280e:	89 89       	ldd	r24, Y+17	; 0x11
    2810:	88 23       	and	r24, r24
    2812:	a1 f0       	breq	.+40     	; 0x283c <xQueueGenericSendFromISR+0x50>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2814:	ce 01       	movw	r24, r28
    2816:	41 96       	adiw	r24, 0x11	; 17
    2818:	0e 94 26 1a 	call	0x344c	; 0x344c <xTaskRemoveFromEventList>
    281c:	88 23       	and	r24, r24
    281e:	81 f0       	breq	.+32     	; 0x2840 <xQueueGenericSendFromISR+0x54>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						if( pxHigherPriorityTaskWoken != NULL )
    2820:	01 15       	cp	r16, r1
    2822:	11 05       	cpc	r17, r1
    2824:	79 f0       	breq	.+30     	; 0x2844 <xQueueGenericSendFromISR+0x58>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2826:	81 e0       	ldi	r24, 0x01	; 1
    2828:	f8 01       	movw	r30, r16
    282a:	80 83       	st	Z, r24
    282c:	0c c0       	rjmp	.+24     	; 0x2846 <xQueueGenericSendFromISR+0x5a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    282e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2830:	8f 5f       	subi	r24, 0xFF	; 255
    2832:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2834:	81 e0       	ldi	r24, 0x01	; 1
    2836:	07 c0       	rjmp	.+14     	; 0x2846 <xQueueGenericSendFromISR+0x5a>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2838:	80 e0       	ldi	r24, 0x00	; 0
    283a:	05 c0       	rjmp	.+10     	; 0x2846 <xQueueGenericSendFromISR+0x5a>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    283c:	81 e0       	ldi	r24, 0x01	; 1
    283e:	03 c0       	rjmp	.+6      	; 0x2846 <xQueueGenericSendFromISR+0x5a>
    2840:	81 e0       	ldi	r24, 0x01	; 1
    2842:	01 c0       	rjmp	.+2      	; 0x2846 <xQueueGenericSendFromISR+0x5a>
    2844:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2846:	df 91       	pop	r29
    2848:	cf 91       	pop	r28
    284a:	1f 91       	pop	r17
    284c:	0f 91       	pop	r16
    284e:	08 95       	ret

00002850 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2850:	8f 92       	push	r8
    2852:	9f 92       	push	r9
    2854:	bf 92       	push	r11
    2856:	cf 92       	push	r12
    2858:	df 92       	push	r13
    285a:	ef 92       	push	r14
    285c:	ff 92       	push	r15
    285e:	0f 93       	push	r16
    2860:	1f 93       	push	r17
    2862:	cf 93       	push	r28
    2864:	df 93       	push	r29
    2866:	00 d0       	rcall	.+0      	; 0x2868 <xQueueGenericReceive+0x18>
    2868:	0f 92       	push	r0
    286a:	0f 92       	push	r0
    286c:	cd b7       	in	r28, 0x3d	; 61
    286e:	de b7       	in	r29, 0x3e	; 62
    2870:	8c 01       	movw	r16, r24
    2872:	4b 01       	movw	r8, r22
    2874:	5d 83       	std	Y+5, r21	; 0x05
    2876:	4c 83       	std	Y+4, r20	; 0x04
    2878:	b2 2e       	mov	r11, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    287a:	ff 24       	eor	r15, r15
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    287c:	ee 24       	eor	r14, r14
    287e:	e3 94       	inc	r14
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2880:	0f 2e       	mov	r0, r31
    2882:	f1 e1       	ldi	r31, 0x11	; 17
    2884:	cf 2e       	mov	r12, r31
    2886:	dd 24       	eor	r13, r13
    2888:	f0 2d       	mov	r31, r0
    288a:	c8 0e       	add	r12, r24
    288c:	d9 1e       	adc	r13, r25
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    288e:	0f b6       	in	r0, 0x3f	; 63
    2890:	f8 94       	cli
    2892:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2894:	f8 01       	movw	r30, r16
    2896:	82 8d       	ldd	r24, Z+26	; 0x1a
    2898:	88 23       	and	r24, r24
    289a:	a1 f1       	breq	.+104    	; 0x2904 <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    289c:	e6 80       	ldd	r14, Z+6	; 0x06
    289e:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    28a0:	c8 01       	movw	r24, r16
    28a2:	b4 01       	movw	r22, r8
    28a4:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    28a8:	bb 20       	and	r11, r11
    28aa:	d1 f4       	brne	.+52     	; 0x28e0 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    28ac:	f8 01       	movw	r30, r16
    28ae:	82 8d       	ldd	r24, Z+26	; 0x1a
    28b0:	81 50       	subi	r24, 0x01	; 1
    28b2:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    28b4:	80 81       	ld	r24, Z
    28b6:	91 81       	ldd	r25, Z+1	; 0x01
    28b8:	00 97       	sbiw	r24, 0x00	; 0
    28ba:	29 f4       	brne	.+10     	; 0x28c6 <xQueueGenericReceive+0x76>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
    28bc:	0e 94 d4 1a 	call	0x35a8	; 0x35a8 <xTaskGetCurrentTaskHandle>
    28c0:	f8 01       	movw	r30, r16
    28c2:	93 83       	std	Z+3, r25	; 0x03
    28c4:	82 83       	std	Z+2, r24	; 0x02
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    28c6:	f8 01       	movw	r30, r16
    28c8:	80 85       	ldd	r24, Z+8	; 0x08
    28ca:	88 23       	and	r24, r24
    28cc:	b9 f0       	breq	.+46     	; 0x28fc <xQueueGenericReceive+0xac>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    28ce:	c8 01       	movw	r24, r16
    28d0:	08 96       	adiw	r24, 0x08	; 8
    28d2:	0e 94 26 1a 	call	0x344c	; 0x344c <xTaskRemoveFromEventList>
    28d6:	81 30       	cpi	r24, 0x01	; 1
    28d8:	89 f4       	brne	.+34     	; 0x28fc <xQueueGenericReceive+0xac>
						{
							portYIELD_WITHIN_API();
    28da:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
    28de:	0e c0       	rjmp	.+28     	; 0x28fc <xQueueGenericReceive+0xac>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    28e0:	f8 01       	movw	r30, r16
    28e2:	f7 82       	std	Z+7, r15	; 0x07
    28e4:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    28e6:	81 89       	ldd	r24, Z+17	; 0x11
    28e8:	88 23       	and	r24, r24
    28ea:	41 f0       	breq	.+16     	; 0x28fc <xQueueGenericReceive+0xac>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    28ec:	c8 01       	movw	r24, r16
    28ee:	41 96       	adiw	r24, 0x11	; 17
    28f0:	0e 94 26 1a 	call	0x344c	; 0x344c <xTaskRemoveFromEventList>
    28f4:	88 23       	and	r24, r24
    28f6:	11 f0       	breq	.+4      	; 0x28fc <xQueueGenericReceive+0xac>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    28f8:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    28fc:	0f 90       	pop	r0
    28fe:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2900:	81 e0       	ldi	r24, 0x01	; 1
    2902:	5f c0       	rjmp	.+190    	; 0x29c2 <xQueueGenericReceive+0x172>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    2904:	8c 81       	ldd	r24, Y+4	; 0x04
    2906:	9d 81       	ldd	r25, Y+5	; 0x05
    2908:	00 97       	sbiw	r24, 0x00	; 0
    290a:	21 f4       	brne	.+8      	; 0x2914 <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    290c:	0f 90       	pop	r0
    290e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2910:	80 e0       	ldi	r24, 0x00	; 0
    2912:	57 c0       	rjmp	.+174    	; 0x29c2 <xQueueGenericReceive+0x172>
				}
				else if( xEntryTimeSet == pdFALSE )
    2914:	ff 20       	and	r15, r15
    2916:	29 f4       	brne	.+10     	; 0x2922 <xQueueGenericReceive+0xd2>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2918:	ce 01       	movw	r24, r28
    291a:	01 96       	adiw	r24, 0x01	; 1
    291c:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2920:	fe 2c       	mov	r15, r14
				}
			}
		}
		taskEXIT_CRITICAL();
    2922:	0f 90       	pop	r0
    2924:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2926:	0e 94 75 17 	call	0x2eea	; 0x2eea <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    292a:	0f b6       	in	r0, 0x3f	; 63
    292c:	f8 94       	cli
    292e:	0f 92       	push	r0
    2930:	f8 01       	movw	r30, r16
    2932:	85 8d       	ldd	r24, Z+29	; 0x1d
    2934:	8f 3f       	cpi	r24, 0xFF	; 255
    2936:	09 f4       	brne	.+2      	; 0x293a <xQueueGenericReceive+0xea>
    2938:	15 8e       	std	Z+29, r1	; 0x1d
    293a:	f8 01       	movw	r30, r16
    293c:	86 8d       	ldd	r24, Z+30	; 0x1e
    293e:	8f 3f       	cpi	r24, 0xFF	; 255
    2940:	09 f4       	brne	.+2      	; 0x2944 <xQueueGenericReceive+0xf4>
    2942:	16 8e       	std	Z+30, r1	; 0x1e
    2944:	0f 90       	pop	r0
    2946:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2948:	ce 01       	movw	r24, r28
    294a:	01 96       	adiw	r24, 0x01	; 1
    294c:	be 01       	movw	r22, r28
    294e:	6c 5f       	subi	r22, 0xFC	; 252
    2950:	7f 4f       	sbci	r23, 0xFF	; 255
    2952:	0e 94 79 1a 	call	0x34f2	; 0x34f2 <xTaskCheckForTimeOut>
    2956:	88 23       	and	r24, r24
    2958:	71 f5       	brne	.+92     	; 0x29b6 <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    295a:	0f b6       	in	r0, 0x3f	; 63
    295c:	f8 94       	cli
    295e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2960:	f8 01       	movw	r30, r16
    2962:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2964:	0f 90       	pop	r0
    2966:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2968:	88 23       	and	r24, r24
    296a:	f9 f4       	brne	.+62     	; 0x29aa <xQueueGenericReceive+0x15a>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    296c:	f8 01       	movw	r30, r16
    296e:	80 81       	ld	r24, Z
    2970:	91 81       	ldd	r25, Z+1	; 0x01
    2972:	00 97       	sbiw	r24, 0x00	; 0
    2974:	51 f4       	brne	.+20     	; 0x298a <xQueueGenericReceive+0x13a>
					{
						portENTER_CRITICAL();
    2976:	0f b6       	in	r0, 0x3f	; 63
    2978:	f8 94       	cli
    297a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    297c:	f8 01       	movw	r30, r16
    297e:	82 81       	ldd	r24, Z+2	; 0x02
    2980:	93 81       	ldd	r25, Z+3	; 0x03
    2982:	0e 94 d9 1a 	call	0x35b2	; 0x35b2 <vTaskPriorityInherit>
						}
						portEXIT_CRITICAL();
    2986:	0f 90       	pop	r0
    2988:	0f be       	out	0x3f, r0	; 63
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    298a:	6c 81       	ldd	r22, Y+4	; 0x04
    298c:	7d 81       	ldd	r23, Y+5	; 0x05
    298e:	c6 01       	movw	r24, r12
    2990:	0e 94 fa 19 	call	0x33f4	; 0x33f4 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    2994:	c8 01       	movw	r24, r16
    2996:	0e 94 1a 12 	call	0x2434	; 0x2434 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    299a:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>
    299e:	88 23       	and	r24, r24
    29a0:	09 f0       	breq	.+2      	; 0x29a4 <xQueueGenericReceive+0x154>
    29a2:	75 cf       	rjmp	.-278    	; 0x288e <xQueueGenericReceive+0x3e>
				{
					portYIELD_WITHIN_API();
    29a4:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
    29a8:	72 cf       	rjmp	.-284    	; 0x288e <xQueueGenericReceive+0x3e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    29aa:	c8 01       	movw	r24, r16
    29ac:	0e 94 1a 12 	call	0x2434	; 0x2434 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    29b0:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>
    29b4:	6c cf       	rjmp	.-296    	; 0x288e <xQueueGenericReceive+0x3e>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    29b6:	c8 01       	movw	r24, r16
    29b8:	0e 94 1a 12 	call	0x2434	; 0x2434 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    29bc:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    29c0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    29c2:	0f 90       	pop	r0
    29c4:	0f 90       	pop	r0
    29c6:	0f 90       	pop	r0
    29c8:	0f 90       	pop	r0
    29ca:	0f 90       	pop	r0
    29cc:	df 91       	pop	r29
    29ce:	cf 91       	pop	r28
    29d0:	1f 91       	pop	r17
    29d2:	0f 91       	pop	r16
    29d4:	ff 90       	pop	r15
    29d6:	ef 90       	pop	r14
    29d8:	df 90       	pop	r13
    29da:	cf 90       	pop	r12
    29dc:	bf 90       	pop	r11
    29de:	9f 90       	pop	r9
    29e0:	8f 90       	pop	r8
    29e2:	08 95       	ret

000029e4 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    29e4:	0f 93       	push	r16
    29e6:	1f 93       	push	r17
    29e8:	cf 93       	push	r28
    29ea:	df 93       	push	r29
    29ec:	ec 01       	movw	r28, r24
    29ee:	8a 01       	movw	r16, r20
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    29f0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    29f2:	88 23       	and	r24, r24
    29f4:	f1 f0       	breq	.+60     	; 0x2a32 <xQueueReceiveFromISR+0x4e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    29f6:	ce 01       	movw	r24, r28
    29f8:	0e 94 eb 11 	call	0x23d6	; 0x23d6 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    29fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    29fe:	81 50       	subi	r24, 0x01	; 1
    2a00:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    2a02:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2a04:	8f 3f       	cpi	r24, 0xFF	; 255
    2a06:	81 f4       	brne	.+32     	; 0x2a28 <xQueueReceiveFromISR+0x44>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2a08:	88 85       	ldd	r24, Y+8	; 0x08
    2a0a:	88 23       	and	r24, r24
    2a0c:	a1 f0       	breq	.+40     	; 0x2a36 <xQueueReceiveFromISR+0x52>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2a0e:	ce 01       	movw	r24, r28
    2a10:	08 96       	adiw	r24, 0x08	; 8
    2a12:	0e 94 26 1a 	call	0x344c	; 0x344c <xTaskRemoveFromEventList>
    2a16:	88 23       	and	r24, r24
    2a18:	81 f0       	breq	.+32     	; 0x2a3a <xQueueReceiveFromISR+0x56>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2a1a:	01 15       	cp	r16, r1
    2a1c:	11 05       	cpc	r17, r1
    2a1e:	79 f0       	breq	.+30     	; 0x2a3e <xQueueReceiveFromISR+0x5a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    2a20:	81 e0       	ldi	r24, 0x01	; 1
    2a22:	f8 01       	movw	r30, r16
    2a24:	80 83       	st	Z, r24
    2a26:	0c c0       	rjmp	.+24     	; 0x2a40 <xQueueReceiveFromISR+0x5c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    2a28:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2a2a:	8f 5f       	subi	r24, 0xFF	; 255
    2a2c:	8d 8f       	std	Y+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2a2e:	81 e0       	ldi	r24, 0x01	; 1
    2a30:	07 c0       	rjmp	.+14     	; 0x2a40 <xQueueReceiveFromISR+0x5c>
		}
		else
		{
			xReturn = pdFAIL;
    2a32:	80 e0       	ldi	r24, 0x00	; 0
    2a34:	05 c0       	rjmp	.+10     	; 0x2a40 <xQueueReceiveFromISR+0x5c>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
			}

			xReturn = pdPASS;
    2a36:	81 e0       	ldi	r24, 0x01	; 1
    2a38:	03 c0       	rjmp	.+6      	; 0x2a40 <xQueueReceiveFromISR+0x5c>
    2a3a:	81 e0       	ldi	r24, 0x01	; 1
    2a3c:	01 c0       	rjmp	.+2      	; 0x2a40 <xQueueReceiveFromISR+0x5c>
    2a3e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2a40:	df 91       	pop	r29
    2a42:	cf 91       	pop	r28
    2a44:	1f 91       	pop	r17
    2a46:	0f 91       	pop	r16
    2a48:	08 95       	ret

00002a4a <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2a4a:	0f b6       	in	r0, 0x3f	; 63
    2a4c:	f8 94       	cli
    2a4e:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    2a50:	fc 01       	movw	r30, r24
    2a52:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    2a54:	0f 90       	pop	r0
    2a56:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    2a58:	08 95       	ret

00002a5a <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    2a5a:	fc 01       	movw	r30, r24
    2a5c:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    2a5e:	08 95       	ret

00002a60 <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    2a60:	cf 93       	push	r28
    2a62:	df 93       	push	r29
    2a64:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    2a66:	88 81       	ld	r24, Y
    2a68:	99 81       	ldd	r25, Y+1	; 0x01
    2a6a:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
	vPortFree( pxQueue );
    2a6e:	ce 01       	movw	r24, r28
    2a70:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
}
    2a74:	df 91       	pop	r29
    2a76:	cf 91       	pop	r28
    2a78:	08 95       	ret

00002a7a <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	92 8d       	ldd	r25, Z+26	; 0x1a
    2a7e:	81 e0       	ldi	r24, 0x01	; 1
    2a80:	91 11       	cpse	r25, r1
    2a82:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    2a84:	08 95       	ret

00002a86 <xQueueIsQueueFullFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    2a86:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    2a88:	22 8d       	ldd	r18, Z+26	; 0x1a
    2a8a:	81 e0       	ldi	r24, 0x01	; 1
    2a8c:	93 8d       	ldd	r25, Z+27	; 0x1b
    2a8e:	29 13       	cpse	r18, r25
    2a90:	80 e0       	ldi	r24, 0x00	; 0

	return xReturn;
}
    2a92:	08 95       	ret

00002a94 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    2a94:	cf 93       	push	r28
    2a96:	df 93       	push	r29
    2a98:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    2a9a:	e0 91 d6 1a 	lds	r30, 0x1AD6
    2a9e:	f0 91 d7 1a 	lds	r31, 0x1AD7
    2aa2:	93 83       	std	Z+3, r25	; 0x03
    2aa4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    2aa6:	80 91 de 1a 	lds	r24, 0x1ADE
    2aaa:	90 91 df 1a 	lds	r25, 0x1ADF
    2aae:	c8 17       	cp	r28, r24
    2ab0:	d9 07       	cpc	r29, r25
    2ab2:	68 f4       	brcc	.+26     	; 0x2ace <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ab4:	80 91 e1 1a 	lds	r24, 0x1AE1
    2ab8:	90 91 e2 1a 	lds	r25, 0x1AE2
    2abc:	60 91 d6 1a 	lds	r22, 0x1AD6
    2ac0:	70 91 d7 1a 	lds	r23, 0x1AD7
    2ac4:	6e 5f       	subi	r22, 0xFE	; 254
    2ac6:	7f 4f       	sbci	r23, 0xFF	; 255
    2ac8:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <vListInsert>
    2acc:	17 c0       	rjmp	.+46     	; 0x2afc <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2ace:	80 91 e3 1a 	lds	r24, 0x1AE3
    2ad2:	90 91 e4 1a 	lds	r25, 0x1AE4
    2ad6:	60 91 d6 1a 	lds	r22, 0x1AD6
    2ada:	70 91 d7 1a 	lds	r23, 0x1AD7
    2ade:	6e 5f       	subi	r22, 0xFE	; 254
    2ae0:	7f 4f       	sbci	r23, 0xFF	; 255
    2ae2:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    2ae6:	80 91 61 02 	lds	r24, 0x0261
    2aea:	90 91 62 02 	lds	r25, 0x0262
    2aee:	c8 17       	cp	r28, r24
    2af0:	d9 07       	cpc	r29, r25
    2af2:	20 f4       	brcc	.+8      	; 0x2afc <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
    2af4:	d0 93 62 02 	sts	0x0262, r29
    2af8:	c0 93 61 02 	sts	0x0261, r28
		}
	}
}
    2afc:	df 91       	pop	r29
    2afe:	cf 91       	pop	r28
    2b00:	08 95       	ret

00002b02 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    2b02:	c7 ee       	ldi	r28, 0xE7	; 231
    2b04:	da e1       	ldi	r29, 0x1A	; 26
    2b06:	88 81       	ld	r24, Y
    2b08:	82 30       	cpi	r24, 0x02	; 2
    2b0a:	e8 f3       	brcs	.-6      	; 0x2b06 <prvIdleTask+0x4>
			{
				taskYIELD();
    2b0c:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
    2b10:	fa cf       	rjmp	.-12     	; 0x2b06 <prvIdleTask+0x4>

00002b12 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    2b12:	4f 92       	push	r4
    2b14:	5f 92       	push	r5
    2b16:	6f 92       	push	r6
    2b18:	7f 92       	push	r7
    2b1a:	8f 92       	push	r8
    2b1c:	9f 92       	push	r9
    2b1e:	bf 92       	push	r11
    2b20:	cf 92       	push	r12
    2b22:	df 92       	push	r13
    2b24:	ef 92       	push	r14
    2b26:	ff 92       	push	r15
    2b28:	0f 93       	push	r16
    2b2a:	1f 93       	push	r17
    2b2c:	cf 93       	push	r28
    2b2e:	df 93       	push	r29
    2b30:	2c 01       	movw	r4, r24
    2b32:	4b 01       	movw	r8, r22
    2b34:	ea 01       	movw	r28, r20
    2b36:	39 01       	movw	r6, r18
    2b38:	b0 2e       	mov	r11, r16
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    2b3a:	8a e2       	ldi	r24, 0x2A	; 42
    2b3c:	90 e0       	ldi	r25, 0x00	; 0
    2b3e:	0e 94 af 0c 	call	0x195e	; 0x195e <pvPortMalloc>
    2b42:	8c 01       	movw	r16, r24

	if( pxNewTCB != NULL )
    2b44:	00 97       	sbiw	r24, 0x00	; 0
    2b46:	09 f4       	brne	.+2      	; 0x2b4a <xTaskGenericCreate+0x38>
    2b48:	e3 c0       	rjmp	.+454    	; 0x2d10 <xTaskGenericCreate+0x1fe>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2b4a:	c1 14       	cp	r12, r1
    2b4c:	d1 04       	cpc	r13, r1
    2b4e:	09 f0       	breq	.+2      	; 0x2b52 <xTaskGenericCreate+0x40>
    2b50:	f4 c0       	rjmp	.+488    	; 0x2d3a <xTaskGenericCreate+0x228>
    2b52:	ce 01       	movw	r24, r28
    2b54:	0e 94 af 0c 	call	0x195e	; 0x195e <pvPortMalloc>
    2b58:	6c 01       	movw	r12, r24
    2b5a:	f8 01       	movw	r30, r16
    2b5c:	90 8f       	std	Z+24, r25	; 0x18
    2b5e:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    2b60:	00 97       	sbiw	r24, 0x00	; 0
    2b62:	29 f4       	brne	.+10     	; 0x2b6e <xTaskGenericCreate+0x5c>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    2b64:	c8 01       	movw	r24, r16
    2b66:	0e 94 4f 0d 	call	0x1a9e	; 0x1a9e <vPortFree>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2b6a:	8f ef       	ldi	r24, 0xFF	; 255
    2b6c:	d6 c0       	rjmp	.+428    	; 0x2d1a <xTaskGenericCreate+0x208>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    2b6e:	c6 01       	movw	r24, r12
    2b70:	65 ea       	ldi	r22, 0xA5	; 165
    2b72:	70 e0       	ldi	r23, 0x00	; 0
    2b74:	ae 01       	movw	r20, r28
    2b76:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    2b7a:	9e 01       	movw	r18, r28
    2b7c:	21 50       	subi	r18, 0x01	; 1
    2b7e:	30 40       	sbci	r19, 0x00	; 0
    2b80:	f8 01       	movw	r30, r16
    2b82:	87 89       	ldd	r24, Z+23	; 0x17
    2b84:	90 8d       	ldd	r25, Z+24	; 0x18
    2b86:	6c 01       	movw	r12, r24
    2b88:	c2 0e       	add	r12, r18
    2b8a:	d3 1e       	adc	r13, r19
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    2b8c:	c8 01       	movw	r24, r16
    2b8e:	49 96       	adiw	r24, 0x19	; 25
    2b90:	b4 01       	movw	r22, r8
    2b92:	40 e1       	ldi	r20, 0x10	; 16
    2b94:	50 e0       	ldi	r21, 0x00	; 0
    2b96:	0e 94 3d 1f 	call	0x3e7a	; 0x3e7a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    2b9a:	f8 01       	movw	r30, r16
    2b9c:	10 a6       	lds	r17, 0xb0
    2b9e:	cb 2d       	mov	r28, r11
    2ba0:	f3 e0       	ldi	r31, 0x03	; 3
    2ba2:	fb 15       	cp	r31, r11
    2ba4:	08 f4       	brcc	.+2      	; 0x2ba8 <xTaskGenericCreate+0x96>
    2ba6:	c3 e0       	ldi	r28, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
    2ba8:	f8 01       	movw	r30, r16
    2baa:	c6 8b       	std	Z+22, r28	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
    2bac:	c1 a7       	lds	r28, 0x71
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    2bae:	88 24       	eor	r8, r8
    2bb0:	99 24       	eor	r9, r9
    2bb2:	68 94       	set
    2bb4:	81 f8       	bld	r8, 1
    2bb6:	80 0e       	add	r8, r16
    2bb8:	91 1e       	adc	r9, r17
    2bba:	c4 01       	movw	r24, r8
    2bbc:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    2bc0:	c8 01       	movw	r24, r16
    2bc2:	0c 96       	adiw	r24, 0x0c	; 12
    2bc4:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    2bc8:	f8 01       	movw	r30, r16
    2bca:	11 87       	std	Z+9, r17	; 0x09
    2bcc:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    2bce:	84 e0       	ldi	r24, 0x04	; 4
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	8c 1b       	sub	r24, r28
    2bd4:	91 09       	sbc	r25, r1
    2bd6:	95 87       	std	Z+13, r25	; 0x0d
    2bd8:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    2bda:	13 8b       	std	Z+19, r17	; 0x13
    2bdc:	02 8b       	std	Z+18, r16	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2bde:	c6 01       	movw	r24, r12
    2be0:	b2 01       	movw	r22, r4
    2be2:	a3 01       	movw	r20, r6
    2be4:	0e 94 4c 10 	call	0x2098	; 0x2098 <pxPortInitialiseStack>
    2be8:	f8 01       	movw	r30, r16
    2bea:	91 83       	std	Z+1, r25	; 0x01
    2bec:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2bee:	e1 14       	cp	r14, r1
    2bf0:	f1 04       	cpc	r15, r1
    2bf2:	19 f0       	breq	.+6      	; 0x2bfa <xTaskGenericCreate+0xe8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2bf4:	f7 01       	movw	r30, r14
    2bf6:	11 83       	std	Z+1, r17	; 0x01
    2bf8:	00 83       	st	Z, r16
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    2bfa:	0f b6       	in	r0, 0x3f	; 63
    2bfc:	f8 94       	cli
    2bfe:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2c00:	80 91 e0 1a 	lds	r24, 0x1AE0
    2c04:	8f 5f       	subi	r24, 0xFF	; 255
    2c06:	80 93 e0 1a 	sts	0x1AE0, r24
			if( pxCurrentTCB == NULL )
    2c0a:	80 91 d6 1a 	lds	r24, 0x1AD6
    2c0e:	90 91 d7 1a 	lds	r25, 0x1AD7
    2c12:	00 97       	sbiw	r24, 0x00	; 0
    2c14:	d9 f5       	brne	.+118    	; 0x2c8c <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2c16:	10 93 d7 1a 	sts	0x1AD7, r17
    2c1a:	00 93 d6 1a 	sts	0x1AD6, r16

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2c1e:	80 91 e0 1a 	lds	r24, 0x1AE0
    2c22:	81 30       	cpi	r24, 0x01	; 1
    2c24:	09 f0       	breq	.+2      	; 0x2c28 <xTaskGenericCreate+0x116>
    2c26:	41 c0       	rjmp	.+130    	; 0x2caa <xTaskGenericCreate+0x198>
    2c28:	c0 e0       	ldi	r28, 0x00	; 0
    2c2a:	d0 e0       	ldi	r29, 0x00	; 0
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    2c2c:	ce 01       	movw	r24, r28
    2c2e:	88 0f       	add	r24, r24
    2c30:	99 1f       	adc	r25, r25
    2c32:	88 0f       	add	r24, r24
    2c34:	99 1f       	adc	r25, r25
    2c36:	88 0f       	add	r24, r24
    2c38:	99 1f       	adc	r25, r25
    2c3a:	8c 0f       	add	r24, r28
    2c3c:	9d 1f       	adc	r25, r29
    2c3e:	89 51       	subi	r24, 0x19	; 25
    2c40:	95 4e       	sbci	r25, 0xE5	; 229
    2c42:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
    2c46:	21 96       	adiw	r28, 0x01	; 1

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    2c48:	c4 30       	cpi	r28, 0x04	; 4
    2c4a:	d1 05       	cpc	r29, r1
    2c4c:	79 f7       	brne	.-34     	; 0x2c2c <xTaskGenericCreate+0x11a>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    2c4e:	cb e0       	ldi	r28, 0x0B	; 11
    2c50:	db e1       	ldi	r29, 0x1B	; 27
    2c52:	ce 01       	movw	r24, r28
    2c54:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    2c58:	0f 2e       	mov	r0, r31
    2c5a:	f4 e1       	ldi	r31, 0x14	; 20
    2c5c:	ef 2e       	mov	r14, r31
    2c5e:	fb e1       	ldi	r31, 0x1B	; 27
    2c60:	ff 2e       	mov	r15, r31
    2c62:	f0 2d       	mov	r31, r0
    2c64:	c7 01       	movw	r24, r14
    2c66:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    2c6a:	8d e1       	ldi	r24, 0x1D	; 29
    2c6c:	9b e1       	ldi	r25, 0x1B	; 27
    2c6e:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    2c72:	86 e2       	ldi	r24, 0x26	; 38
    2c74:	9b e1       	ldi	r25, 0x1B	; 27
    2c76:	0e 94 ad 0f 	call	0x1f5a	; 0x1f5a <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    2c7a:	d0 93 e4 1a 	sts	0x1AE4, r29
    2c7e:	c0 93 e3 1a 	sts	0x1AE3, r28
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    2c82:	f0 92 e2 1a 	sts	0x1AE2, r15
    2c86:	e0 92 e1 1a 	sts	0x1AE1, r14
    2c8a:	0f c0       	rjmp	.+30     	; 0x2caa <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2c8c:	80 91 dc 1a 	lds	r24, 0x1ADC
    2c90:	88 23       	and	r24, r24
    2c92:	59 f4       	brne	.+22     	; 0x2caa <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    2c94:	e0 91 d6 1a 	lds	r30, 0x1AD6
    2c98:	f0 91 d7 1a 	lds	r31, 0x1AD7
    2c9c:	86 89       	ldd	r24, Z+22	; 0x16
    2c9e:	b8 16       	cp	r11, r24
    2ca0:	20 f0       	brcs	.+8      	; 0x2caa <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
    2ca2:	10 93 d7 1a 	sts	0x1AD7, r17
    2ca6:	00 93 d6 1a 	sts	0x1AD6, r16
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    2caa:	f8 01       	movw	r30, r16
    2cac:	86 89       	ldd	r24, Z+22	; 0x16
    2cae:	90 91 e5 1a 	lds	r25, 0x1AE5
    2cb2:	98 17       	cp	r25, r24
    2cb4:	10 f4       	brcc	.+4      	; 0x2cba <xTaskGenericCreate+0x1a8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    2cb6:	80 93 e5 1a 	sts	0x1AE5, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    2cba:	90 91 e6 1a 	lds	r25, 0x1AE6
    2cbe:	9f 5f       	subi	r25, 0xFF	; 255
    2cc0:	90 93 e6 1a 	sts	0x1AE6, r25

			prvAddTaskToReadyQueue( pxNewTCB );
    2cc4:	90 91 dd 1a 	lds	r25, 0x1ADD
    2cc8:	98 17       	cp	r25, r24
    2cca:	10 f4       	brcc	.+4      	; 0x2cd0 <xTaskGenericCreate+0x1be>
    2ccc:	80 93 dd 1a 	sts	0x1ADD, r24
    2cd0:	90 e0       	ldi	r25, 0x00	; 0
    2cd2:	9c 01       	movw	r18, r24
    2cd4:	22 0f       	add	r18, r18
    2cd6:	33 1f       	adc	r19, r19
    2cd8:	22 0f       	add	r18, r18
    2cda:	33 1f       	adc	r19, r19
    2cdc:	22 0f       	add	r18, r18
    2cde:	33 1f       	adc	r19, r19
    2ce0:	82 0f       	add	r24, r18
    2ce2:	93 1f       	adc	r25, r19
    2ce4:	89 51       	subi	r24, 0x19	; 25
    2ce6:	95 4e       	sbci	r25, 0xE5	; 229
    2ce8:	b4 01       	movw	r22, r8
    2cea:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2cee:	0f 90       	pop	r0
    2cf0:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    2cf2:	80 91 dc 1a 	lds	r24, 0x1ADC
    2cf6:	88 23       	and	r24, r24
    2cf8:	69 f0       	breq	.+26     	; 0x2d14 <xTaskGenericCreate+0x202>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2cfa:	e0 91 d6 1a 	lds	r30, 0x1AD6
    2cfe:	f0 91 d7 1a 	lds	r31, 0x1AD7
    2d02:	86 89       	ldd	r24, Z+22	; 0x16
    2d04:	8b 15       	cp	r24, r11
    2d06:	40 f4       	brcc	.+16     	; 0x2d18 <xTaskGenericCreate+0x206>
			{
				portYIELD_WITHIN_API();
    2d08:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    2d0c:	81 e0       	ldi	r24, 0x01	; 1
    2d0e:	05 c0       	rjmp	.+10     	; 0x2d1a <xTaskGenericCreate+0x208>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2d10:	8f ef       	ldi	r24, 0xFF	; 255
    2d12:	03 c0       	rjmp	.+6      	; 0x2d1a <xTaskGenericCreate+0x208>
			#endif
			uxTaskNumber++;

			prvAddTaskToReadyQueue( pxNewTCB );

			xReturn = pdPASS;
    2d14:	81 e0       	ldi	r24, 0x01	; 1
    2d16:	01 c0       	rjmp	.+2      	; 0x2d1a <xTaskGenericCreate+0x208>
    2d18:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
    2d1a:	df 91       	pop	r29
    2d1c:	cf 91       	pop	r28
    2d1e:	1f 91       	pop	r17
    2d20:	0f 91       	pop	r16
    2d22:	ff 90       	pop	r15
    2d24:	ef 90       	pop	r14
    2d26:	df 90       	pop	r13
    2d28:	cf 90       	pop	r12
    2d2a:	bf 90       	pop	r11
    2d2c:	9f 90       	pop	r9
    2d2e:	8f 90       	pop	r8
    2d30:	7f 90       	pop	r7
    2d32:	6f 90       	pop	r6
    2d34:	5f 90       	pop	r5
    2d36:	4f 90       	pop	r4
    2d38:	08 95       	ret
	if( pxNewTCB != NULL )
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    2d3a:	fc 01       	movw	r30, r24
    2d3c:	d0 8e       	std	Z+24, r13	; 0x18
    2d3e:	c7 8a       	std	Z+23, r12	; 0x17
    2d40:	16 cf       	rjmp	.-468    	; 0x2b6e <xTaskGenericCreate+0x5c>

00002d42 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    2d42:	fc 01       	movw	r30, r24
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2d44:	82 85       	ldd	r24, Z+10	; 0x0a
    2d46:	93 85       	ldd	r25, Z+11	; 0x0b
    2d48:	2b e1       	ldi	r18, 0x1B	; 27
    2d4a:	86 32       	cpi	r24, 0x26	; 38
    2d4c:	92 07       	cpc	r25, r18
    2d4e:	61 f4       	brne	.+24     	; 0x2d68 <xTaskIsTaskSuspended+0x26>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    2d50:	24 89       	ldd	r18, Z+20	; 0x14
    2d52:	35 89       	ldd	r19, Z+21	; 0x15
    2d54:	8b e1       	ldi	r24, 0x1B	; 27
    2d56:	2d 31       	cpi	r18, 0x1D	; 29
    2d58:	38 07       	cpc	r19, r24
    2d5a:	41 f0       	breq	.+16     	; 0x2d6c <xTaskIsTaskSuspended+0x2a>

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
	portBASE_TYPE xReturn = pdFALSE;
    2d5c:	81 e0       	ldi	r24, 0x01	; 1
    2d5e:	21 15       	cp	r18, r1
    2d60:	31 05       	cpc	r19, r1
    2d62:	29 f0       	breq	.+10     	; 0x2d6e <xTaskIsTaskSuspended+0x2c>
    2d64:	80 e0       	ldi	r24, 0x00	; 0
    2d66:	08 95       	ret
    2d68:	80 e0       	ldi	r24, 0x00	; 0
    2d6a:	08 95       	ret
    2d6c:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}

		return xReturn;
	}
    2d6e:	08 95       	ret

00002d70 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    2d70:	0f 93       	push	r16
    2d72:	1f 93       	push	r17
    2d74:	cf 93       	push	r28
    2d76:	df 93       	push	r29
    2d78:	ec 01       	movw	r28, r24
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    2d7a:	00 97       	sbiw	r24, 0x00	; 0
    2d7c:	b9 f1       	breq	.+110    	; 0x2dec <vTaskResume+0x7c>
    2d7e:	80 91 d6 1a 	lds	r24, 0x1AD6
    2d82:	90 91 d7 1a 	lds	r25, 0x1AD7
    2d86:	c8 17       	cp	r28, r24
    2d88:	d9 07       	cpc	r29, r25
    2d8a:	81 f1       	breq	.+96     	; 0x2dec <vTaskResume+0x7c>
		{
			taskENTER_CRITICAL();
    2d8c:	0f b6       	in	r0, 0x3f	; 63
    2d8e:	f8 94       	cli
    2d90:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2d92:	ce 01       	movw	r24, r28
    2d94:	0e 94 a1 16 	call	0x2d42	; 0x2d42 <xTaskIsTaskSuspended>
    2d98:	81 30       	cpi	r24, 0x01	; 1
    2d9a:	31 f5       	brne	.+76     	; 0x2de8 <vTaskResume+0x78>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    2d9c:	8e 01       	movw	r16, r28
    2d9e:	0e 5f       	subi	r16, 0xFE	; 254
    2da0:	1f 4f       	sbci	r17, 0xFF	; 255
    2da2:	c8 01       	movw	r24, r16
    2da4:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2da8:	8e 89       	ldd	r24, Y+22	; 0x16
    2daa:	90 91 dd 1a 	lds	r25, 0x1ADD
    2dae:	98 17       	cp	r25, r24
    2db0:	10 f4       	brcc	.+4      	; 0x2db6 <vTaskResume+0x46>
    2db2:	80 93 dd 1a 	sts	0x1ADD, r24
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	9c 01       	movw	r18, r24
    2dba:	22 0f       	add	r18, r18
    2dbc:	33 1f       	adc	r19, r19
    2dbe:	22 0f       	add	r18, r18
    2dc0:	33 1f       	adc	r19, r19
    2dc2:	22 0f       	add	r18, r18
    2dc4:	33 1f       	adc	r19, r19
    2dc6:	82 0f       	add	r24, r18
    2dc8:	93 1f       	adc	r25, r19
    2dca:	89 51       	subi	r24, 0x19	; 25
    2dcc:	95 4e       	sbci	r25, 0xE5	; 229
    2dce:	b8 01       	movw	r22, r16
    2dd0:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2dd4:	e0 91 d6 1a 	lds	r30, 0x1AD6
    2dd8:	f0 91 d7 1a 	lds	r31, 0x1AD7
    2ddc:	9e 89       	ldd	r25, Y+22	; 0x16
    2dde:	86 89       	ldd	r24, Z+22	; 0x16
    2de0:	98 17       	cp	r25, r24
    2de2:	10 f0       	brcs	.+4      	; 0x2de8 <vTaskResume+0x78>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    2de4:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    2de8:	0f 90       	pop	r0
    2dea:	0f be       	out	0x3f, r0	; 63
		}
	}
    2dec:	df 91       	pop	r29
    2dee:	cf 91       	pop	r28
    2df0:	1f 91       	pop	r17
    2df2:	0f 91       	pop	r16
    2df4:	08 95       	ret

00002df6 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    2df6:	ef 92       	push	r14
    2df8:	ff 92       	push	r15
    2dfa:	1f 93       	push	r17
    2dfc:	cf 93       	push	r28
    2dfe:	df 93       	push	r29
    2e00:	ec 01       	movw	r28, r24

		pxTCB = ( tskTCB * ) pxTaskToResume;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2e02:	0e 94 a1 16 	call	0x2d42	; 0x2d42 <xTaskIsTaskSuspended>
    2e06:	81 30       	cpi	r24, 0x01	; 1
    2e08:	b9 f5       	brne	.+110    	; 0x2e78 <xTaskResumeFromISR+0x82>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2e0a:	80 91 db 1a 	lds	r24, 0x1ADB
    2e0e:	88 23       	and	r24, r24
    2e10:	51 f5       	brne	.+84     	; 0x2e66 <xTaskResumeFromISR+0x70>
				{
					xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    2e12:	e0 91 d6 1a 	lds	r30, 0x1AD6
    2e16:	f0 91 d7 1a 	lds	r31, 0x1AD7
    2e1a:	11 e0       	ldi	r17, 0x01	; 1
    2e1c:	9e 89       	ldd	r25, Y+22	; 0x16
    2e1e:	86 89       	ldd	r24, Z+22	; 0x16
    2e20:	98 17       	cp	r25, r24
    2e22:	08 f4       	brcc	.+2      	; 0x2e26 <xTaskResumeFromISR+0x30>
    2e24:	10 e0       	ldi	r17, 0x00	; 0
					uxListRemove(  &( pxTCB->xGenericListItem ) );
    2e26:	ee 24       	eor	r14, r14
    2e28:	ff 24       	eor	r15, r15
    2e2a:	68 94       	set
    2e2c:	e1 f8       	bld	r14, 1
    2e2e:	ec 0e       	add	r14, r28
    2e30:	fd 1e       	adc	r15, r29
    2e32:	c7 01       	movw	r24, r14
    2e34:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2e38:	8e 89       	ldd	r24, Y+22	; 0x16
    2e3a:	90 91 dd 1a 	lds	r25, 0x1ADD
    2e3e:	98 17       	cp	r25, r24
    2e40:	10 f4       	brcc	.+4      	; 0x2e46 <xTaskResumeFromISR+0x50>
    2e42:	80 93 dd 1a 	sts	0x1ADD, r24
    2e46:	90 e0       	ldi	r25, 0x00	; 0
    2e48:	9c 01       	movw	r18, r24
    2e4a:	22 0f       	add	r18, r18
    2e4c:	33 1f       	adc	r19, r19
    2e4e:	22 0f       	add	r18, r18
    2e50:	33 1f       	adc	r19, r19
    2e52:	22 0f       	add	r18, r18
    2e54:	33 1f       	adc	r19, r19
    2e56:	82 0f       	add	r24, r18
    2e58:	93 1f       	adc	r25, r19
    2e5a:	89 51       	subi	r24, 0x19	; 25
    2e5c:	95 4e       	sbci	r25, 0xE5	; 229
    2e5e:	b7 01       	movw	r22, r14
    2e60:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
    2e64:	0a c0       	rjmp	.+20     	; 0x2e7a <xTaskResumeFromISR+0x84>
				else
				{
					/* We cannot access the delayed or ready lists, so will hold this
					task pending until the scheduler is resumed, at which point a
					yield will be performed if necessary. */
					vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2e66:	be 01       	movw	r22, r28
    2e68:	64 5f       	subi	r22, 0xF4	; 244
    2e6a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e6c:	8d e1       	ldi	r24, 0x1D	; 29
    2e6e:	9b e1       	ldi	r25, 0x1B	; 27
    2e70:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
	portBASE_TYPE xYieldRequired = pdFALSE;
    2e74:	10 e0       	ldi	r17, 0x00	; 0
    2e76:	01 c0       	rjmp	.+2      	; 0x2e7a <xTaskResumeFromISR+0x84>
    2e78:	10 e0       	ldi	r17, 0x00	; 0
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
	}
    2e7a:	81 2f       	mov	r24, r17
    2e7c:	df 91       	pop	r29
    2e7e:	cf 91       	pop	r28
    2e80:	1f 91       	pop	r17
    2e82:	ff 90       	pop	r15
    2e84:	ef 90       	pop	r14
    2e86:	08 95       	ret

00002e88 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2e88:	af 92       	push	r10
    2e8a:	bf 92       	push	r11
    2e8c:	cf 92       	push	r12
    2e8e:	df 92       	push	r13
    2e90:	ef 92       	push	r14
    2e92:	ff 92       	push	r15
    2e94:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2e96:	81 e8       	ldi	r24, 0x81	; 129
    2e98:	95 e1       	ldi	r25, 0x15	; 21
    2e9a:	6c e5       	ldi	r22, 0x5C	; 92
    2e9c:	72 e0       	ldi	r23, 0x02	; 2
    2e9e:	45 e5       	ldi	r20, 0x55	; 85
    2ea0:	50 e0       	ldi	r21, 0x00	; 0
    2ea2:	20 e0       	ldi	r18, 0x00	; 0
    2ea4:	30 e0       	ldi	r19, 0x00	; 0
    2ea6:	00 e0       	ldi	r16, 0x00	; 0
    2ea8:	ee 24       	eor	r14, r14
    2eaa:	ff 24       	eor	r15, r15
    2eac:	cc 24       	eor	r12, r12
    2eae:	dd 24       	eor	r13, r13
    2eb0:	aa 24       	eor	r10, r10
    2eb2:	bb 24       	eor	r11, r11
    2eb4:	0e 94 89 15 	call	0x2b12	; 0x2b12 <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    2eb8:	81 30       	cpi	r24, 0x01	; 1
    2eba:	49 f4       	brne	.+18     	; 0x2ece <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2ebc:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2ebe:	80 93 dc 1a 	sts	0x1ADC, r24
		xTickCount = ( portTickType ) 0U;
    2ec2:	10 92 df 1a 	sts	0x1ADF, r1
    2ec6:	10 92 de 1a 	sts	0x1ADE, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2eca:	0e 94 e5 10 	call	0x21ca	; 0x21ca <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2ece:	0f 91       	pop	r16
    2ed0:	ff 90       	pop	r15
    2ed2:	ef 90       	pop	r14
    2ed4:	df 90       	pop	r13
    2ed6:	cf 90       	pop	r12
    2ed8:	bf 90       	pop	r11
    2eda:	af 90       	pop	r10
    2edc:	08 95       	ret

00002ede <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2ede:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2ee0:	10 92 dc 1a 	sts	0x1ADC, r1
	vPortEndScheduler();
    2ee4:	0e 94 23 11 	call	0x2246	; 0x2246 <vPortEndScheduler>
}
    2ee8:	08 95       	ret

00002eea <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2eea:	80 91 db 1a 	lds	r24, 0x1ADB
    2eee:	8f 5f       	subi	r24, 0xFF	; 255
    2ef0:	80 93 db 1a 	sts	0x1ADB, r24
}
    2ef4:	08 95       	ret

00002ef6 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2ef6:	0f b6       	in	r0, 0x3f	; 63
    2ef8:	f8 94       	cli
    2efa:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2efc:	80 91 de 1a 	lds	r24, 0x1ADE
    2f00:	90 91 df 1a 	lds	r25, 0x1ADF
	}
	taskEXIT_CRITICAL();
    2f04:	0f 90       	pop	r0
    2f06:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    2f08:	08 95       	ret

00002f0a <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
    2f0a:	80 91 de 1a 	lds	r24, 0x1ADE
    2f0e:	90 91 df 1a 	lds	r25, 0x1ADF
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2f12:	08 95       	ret

00002f14 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2f14:	80 91 e0 1a 	lds	r24, 0x1AE0
}
    2f18:	08 95       	ret

00002f1a <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2f1a:	0f 93       	push	r16
    2f1c:	1f 93       	push	r17
    2f1e:	cf 93       	push	r28
    2f20:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2f22:	80 91 db 1a 	lds	r24, 0x1ADB
    2f26:	88 23       	and	r24, r24
    2f28:	09 f0       	breq	.+2      	; 0x2f2c <vTaskIncrementTick+0x12>
    2f2a:	b3 c0       	rjmp	.+358    	; 0x3092 <vTaskIncrementTick+0x178>
	{
		++xTickCount;
    2f2c:	80 91 de 1a 	lds	r24, 0x1ADE
    2f30:	90 91 df 1a 	lds	r25, 0x1ADF
    2f34:	01 96       	adiw	r24, 0x01	; 1
    2f36:	90 93 df 1a 	sts	0x1ADF, r25
    2f3a:	80 93 de 1a 	sts	0x1ADE, r24
		if( xTickCount == ( portTickType ) 0U )
    2f3e:	80 91 de 1a 	lds	r24, 0x1ADE
    2f42:	90 91 df 1a 	lds	r25, 0x1ADF
    2f46:	00 97       	sbiw	r24, 0x00	; 0
    2f48:	99 f5       	brne	.+102    	; 0x2fb0 <vTaskIncrementTick+0x96>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
    2f4a:	80 91 e3 1a 	lds	r24, 0x1AE3
    2f4e:	90 91 e4 1a 	lds	r25, 0x1AE4
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    2f52:	20 91 e1 1a 	lds	r18, 0x1AE1
    2f56:	30 91 e2 1a 	lds	r19, 0x1AE2
    2f5a:	30 93 e4 1a 	sts	0x1AE4, r19
    2f5e:	20 93 e3 1a 	sts	0x1AE3, r18
			pxOverflowDelayedTaskList = pxTemp;
    2f62:	90 93 e2 1a 	sts	0x1AE2, r25
    2f66:	80 93 e1 1a 	sts	0x1AE1, r24
			xNumOfOverflows++;
    2f6a:	80 91 d8 1a 	lds	r24, 0x1AD8
    2f6e:	8f 5f       	subi	r24, 0xFF	; 255
    2f70:	80 93 d8 1a 	sts	0x1AD8, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    2f74:	e0 91 e3 1a 	lds	r30, 0x1AE3
    2f78:	f0 91 e4 1a 	lds	r31, 0x1AE4
    2f7c:	80 81       	ld	r24, Z
    2f7e:	88 23       	and	r24, r24
    2f80:	39 f4       	brne	.+14     	; 0x2f90 <vTaskIncrementTick+0x76>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    2f82:	8f ef       	ldi	r24, 0xFF	; 255
    2f84:	9f ef       	ldi	r25, 0xFF	; 255
    2f86:	90 93 62 02 	sts	0x0262, r25
    2f8a:	80 93 61 02 	sts	0x0261, r24
    2f8e:	10 c0       	rjmp	.+32     	; 0x2fb0 <vTaskIncrementTick+0x96>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    2f90:	e0 91 e3 1a 	lds	r30, 0x1AE3
    2f94:	f0 91 e4 1a 	lds	r31, 0x1AE4
    2f98:	05 80       	ldd	r0, Z+5	; 0x05
    2f9a:	f6 81       	ldd	r31, Z+6	; 0x06
    2f9c:	e0 2d       	mov	r30, r0
    2f9e:	06 80       	ldd	r0, Z+6	; 0x06
    2fa0:	f7 81       	ldd	r31, Z+7	; 0x07
    2fa2:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    2fa4:	82 81       	ldd	r24, Z+2	; 0x02
    2fa6:	93 81       	ldd	r25, Z+3	; 0x03
    2fa8:	90 93 62 02 	sts	0x0262, r25
    2fac:	80 93 61 02 	sts	0x0261, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    2fb0:	20 91 de 1a 	lds	r18, 0x1ADE
    2fb4:	30 91 df 1a 	lds	r19, 0x1ADF
    2fb8:	80 91 61 02 	lds	r24, 0x0261
    2fbc:	90 91 62 02 	lds	r25, 0x0262
    2fc0:	28 17       	cp	r18, r24
    2fc2:	39 07       	cpc	r19, r25
    2fc4:	08 f4       	brcc	.+2      	; 0x2fc8 <vTaskIncrementTick+0xae>
    2fc6:	6a c0       	rjmp	.+212    	; 0x309c <vTaskIncrementTick+0x182>
    2fc8:	e0 91 e3 1a 	lds	r30, 0x1AE3
    2fcc:	f0 91 e4 1a 	lds	r31, 0x1AE4
    2fd0:	80 81       	ld	r24, Z
    2fd2:	88 23       	and	r24, r24
    2fd4:	99 f0       	breq	.+38     	; 0x2ffc <vTaskIncrementTick+0xe2>
    2fd6:	e0 91 e3 1a 	lds	r30, 0x1AE3
    2fda:	f0 91 e4 1a 	lds	r31, 0x1AE4
    2fde:	05 80       	ldd	r0, Z+5	; 0x05
    2fe0:	f6 81       	ldd	r31, Z+6	; 0x06
    2fe2:	e0 2d       	mov	r30, r0
    2fe4:	c6 81       	ldd	r28, Z+6	; 0x06
    2fe6:	d7 81       	ldd	r29, Z+7	; 0x07
    2fe8:	8a 81       	ldd	r24, Y+2	; 0x02
    2fea:	9b 81       	ldd	r25, Y+3	; 0x03
    2fec:	20 91 de 1a 	lds	r18, 0x1ADE
    2ff0:	30 91 df 1a 	lds	r19, 0x1ADF
    2ff4:	28 17       	cp	r18, r24
    2ff6:	39 07       	cpc	r19, r25
    2ff8:	f8 f4       	brcc	.+62     	; 0x3038 <vTaskIncrementTick+0x11e>
    2ffa:	19 c0       	rjmp	.+50     	; 0x302e <vTaskIncrementTick+0x114>
    2ffc:	8f ef       	ldi	r24, 0xFF	; 255
    2ffe:	9f ef       	ldi	r25, 0xFF	; 255
    3000:	90 93 62 02 	sts	0x0262, r25
    3004:	80 93 61 02 	sts	0x0261, r24
    3008:	49 c0       	rjmp	.+146    	; 0x309c <vTaskIncrementTick+0x182>
    300a:	e0 91 e3 1a 	lds	r30, 0x1AE3
    300e:	f0 91 e4 1a 	lds	r31, 0x1AE4
    3012:	05 80       	ldd	r0, Z+5	; 0x05
    3014:	f6 81       	ldd	r31, Z+6	; 0x06
    3016:	e0 2d       	mov	r30, r0
    3018:	c6 81       	ldd	r28, Z+6	; 0x06
    301a:	d7 81       	ldd	r29, Z+7	; 0x07
    301c:	8a 81       	ldd	r24, Y+2	; 0x02
    301e:	9b 81       	ldd	r25, Y+3	; 0x03
    3020:	20 91 de 1a 	lds	r18, 0x1ADE
    3024:	30 91 df 1a 	lds	r19, 0x1ADF
    3028:	28 17       	cp	r18, r24
    302a:	39 07       	cpc	r19, r25
    302c:	28 f4       	brcc	.+10     	; 0x3038 <vTaskIncrementTick+0x11e>
    302e:	90 93 62 02 	sts	0x0262, r25
    3032:	80 93 61 02 	sts	0x0261, r24
    3036:	32 c0       	rjmp	.+100    	; 0x309c <vTaskIncrementTick+0x182>
    3038:	8e 01       	movw	r16, r28
    303a:	0e 5f       	subi	r16, 0xFE	; 254
    303c:	1f 4f       	sbci	r17, 0xFF	; 255
    303e:	c8 01       	movw	r24, r16
    3040:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
    3044:	8c 89       	ldd	r24, Y+20	; 0x14
    3046:	9d 89       	ldd	r25, Y+21	; 0x15
    3048:	00 97       	sbiw	r24, 0x00	; 0
    304a:	21 f0       	breq	.+8      	; 0x3054 <vTaskIncrementTick+0x13a>
    304c:	ce 01       	movw	r24, r28
    304e:	0c 96       	adiw	r24, 0x0c	; 12
    3050:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
    3054:	8e 89       	ldd	r24, Y+22	; 0x16
    3056:	90 91 dd 1a 	lds	r25, 0x1ADD
    305a:	98 17       	cp	r25, r24
    305c:	10 f4       	brcc	.+4      	; 0x3062 <vTaskIncrementTick+0x148>
    305e:	80 93 dd 1a 	sts	0x1ADD, r24
    3062:	90 e0       	ldi	r25, 0x00	; 0
    3064:	9c 01       	movw	r18, r24
    3066:	22 0f       	add	r18, r18
    3068:	33 1f       	adc	r19, r19
    306a:	22 0f       	add	r18, r18
    306c:	33 1f       	adc	r19, r19
    306e:	22 0f       	add	r18, r18
    3070:	33 1f       	adc	r19, r19
    3072:	82 0f       	add	r24, r18
    3074:	93 1f       	adc	r25, r19
    3076:	89 51       	subi	r24, 0x19	; 25
    3078:	95 4e       	sbci	r25, 0xE5	; 229
    307a:	b8 01       	movw	r22, r16
    307c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
    3080:	e0 91 e3 1a 	lds	r30, 0x1AE3
    3084:	f0 91 e4 1a 	lds	r31, 0x1AE4
    3088:	80 81       	ld	r24, Z
    308a:	88 23       	and	r24, r24
    308c:	09 f0       	breq	.+2      	; 0x3090 <vTaskIncrementTick+0x176>
    308e:	bd cf       	rjmp	.-134    	; 0x300a <vTaskIncrementTick+0xf0>
    3090:	b5 cf       	rjmp	.-150    	; 0x2ffc <vTaskIncrementTick+0xe2>
	}
	else
	{
		++uxMissedTicks;
    3092:	80 91 da 1a 	lds	r24, 0x1ADA
    3096:	8f 5f       	subi	r24, 0xFF	; 255
    3098:	80 93 da 1a 	sts	0x1ADA, r24
		{
			vApplicationTickHook();
		}
	}
	#endif
}
    309c:	df 91       	pop	r29
    309e:	cf 91       	pop	r28
    30a0:	1f 91       	pop	r17
    30a2:	0f 91       	pop	r16
    30a4:	08 95       	ret

000030a6 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE != 0  */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    30a6:	af 92       	push	r10
    30a8:	bf 92       	push	r11
    30aa:	cf 92       	push	r12
    30ac:	df 92       	push	r13
    30ae:	ef 92       	push	r14
    30b0:	ff 92       	push	r15
    30b2:	0f 93       	push	r16
    30b4:	1f 93       	push	r17
    30b6:	cf 93       	push	r28
    30b8:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    30ba:	0f b6       	in	r0, 0x3f	; 63
    30bc:	f8 94       	cli
    30be:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    30c0:	80 91 db 1a 	lds	r24, 0x1ADB
    30c4:	81 50       	subi	r24, 0x01	; 1
    30c6:	80 93 db 1a 	sts	0x1ADB, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    30ca:	80 91 db 1a 	lds	r24, 0x1ADB
    30ce:	88 23       	and	r24, r24
    30d0:	09 f0       	breq	.+2      	; 0x30d4 <xTaskResumeAll+0x2e>
    30d2:	69 c0       	rjmp	.+210    	; 0x31a6 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    30d4:	80 91 e0 1a 	lds	r24, 0x1AE0
    30d8:	88 23       	and	r24, r24
    30da:	81 f5       	brne	.+96     	; 0x313c <xTaskResumeAll+0x96>
    30dc:	67 c0       	rjmp	.+206    	; 0x31ac <xTaskResumeAll+0x106>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    30de:	d6 01       	movw	r26, r12
    30e0:	ed 91       	ld	r30, X+
    30e2:	fc 91       	ld	r31, X
    30e4:	c6 81       	ldd	r28, Z+6	; 0x06
    30e6:	d7 81       	ldd	r29, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
    30e8:	ce 01       	movw	r24, r28
    30ea:	0c 96       	adiw	r24, 0x0c	; 12
    30ec:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
    30f0:	8e 01       	movw	r16, r28
    30f2:	0e 5f       	subi	r16, 0xFE	; 254
    30f4:	1f 4f       	sbci	r17, 0xFF	; 255
    30f6:	c8 01       	movw	r24, r16
    30f8:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    30fc:	8e 89       	ldd	r24, Y+22	; 0x16
    30fe:	90 91 dd 1a 	lds	r25, 0x1ADD
    3102:	98 17       	cp	r25, r24
    3104:	10 f4       	brcc	.+4      	; 0x310a <xTaskResumeAll+0x64>
    3106:	80 93 dd 1a 	sts	0x1ADD, r24
    310a:	90 e0       	ldi	r25, 0x00	; 0
    310c:	9c 01       	movw	r18, r24
    310e:	22 0f       	add	r18, r18
    3110:	33 1f       	adc	r19, r19
    3112:	22 0f       	add	r18, r18
    3114:	33 1f       	adc	r19, r19
    3116:	22 0f       	add	r18, r18
    3118:	33 1f       	adc	r19, r19
    311a:	82 0f       	add	r24, r18
    311c:	93 1f       	adc	r25, r19
    311e:	89 51       	subi	r24, 0x19	; 25
    3120:	95 4e       	sbci	r25, 0xE5	; 229
    3122:	b8 01       	movw	r22, r16
    3124:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    3128:	e0 91 d6 1a 	lds	r30, 0x1AD6
    312c:	f0 91 d7 1a 	lds	r31, 0x1AD7
    3130:	9e 89       	ldd	r25, Y+22	; 0x16
    3132:	86 89       	ldd	r24, Z+22	; 0x16
    3134:	98 17       	cp	r25, r24
    3136:	88 f0       	brcs	.+34     	; 0x315a <xTaskResumeAll+0xb4>
					{
						xYieldRequired = pdTRUE;
    3138:	ba 2c       	mov	r11, r10
    313a:	0f c0       	rjmp	.+30     	; 0x315a <xTaskResumeAll+0xb4>
	{
		--uxSchedulerSuspended;

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    313c:	bb 24       	eor	r11, r11
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    313e:	0f 2e       	mov	r0, r31
    3140:	fd e1       	ldi	r31, 0x1D	; 29
    3142:	ef 2e       	mov	r14, r31
    3144:	fb e1       	ldi	r31, 0x1B	; 27
    3146:	ff 2e       	mov	r15, r31
    3148:	f0 2d       	mov	r31, r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    314a:	0f 2e       	mov	r0, r31
    314c:	f2 e2       	ldi	r31, 0x22	; 34
    314e:	cf 2e       	mov	r12, r31
    3150:	fb e1       	ldi	r31, 0x1B	; 27
    3152:	df 2e       	mov	r13, r31
    3154:	f0 2d       	mov	r31, r0

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldRequired = pdTRUE;
    3156:	aa 24       	eor	r10, r10
    3158:	a3 94       	inc	r10
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    315a:	f7 01       	movw	r30, r14
    315c:	80 81       	ld	r24, Z
    315e:	88 23       	and	r24, r24
    3160:	09 f0       	breq	.+2      	; 0x3164 <xTaskResumeAll+0xbe>
    3162:	bd cf       	rjmp	.-134    	; 0x30de <xTaskResumeAll+0x38>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3164:	80 91 da 1a 	lds	r24, 0x1ADA
    3168:	88 23       	and	r24, r24
    316a:	81 f0       	breq	.+32     	; 0x318c <xTaskResumeAll+0xe6>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    316c:	80 91 da 1a 	lds	r24, 0x1ADA
    3170:	88 23       	and	r24, r24
    3172:	99 f0       	breq	.+38     	; 0x319a <xTaskResumeAll+0xf4>
					{
						vTaskIncrementTick();
    3174:	0e 94 8d 17 	call	0x2f1a	; 0x2f1a <vTaskIncrementTick>
						--uxMissedTicks;
    3178:	80 91 da 1a 	lds	r24, 0x1ADA
    317c:	81 50       	subi	r24, 0x01	; 1
    317e:	80 93 da 1a 	sts	0x1ADA, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    3182:	80 91 da 1a 	lds	r24, 0x1ADA
    3186:	88 23       	and	r24, r24
    3188:	a9 f7       	brne	.-22     	; 0x3174 <xTaskResumeAll+0xce>
    318a:	07 c0       	rjmp	.+14     	; 0x319a <xTaskResumeAll+0xf4>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    318c:	f1 e0       	ldi	r31, 0x01	; 1
    318e:	bf 16       	cp	r11, r31
    3190:	21 f0       	breq	.+8      	; 0x319a <xTaskResumeAll+0xf4>
    3192:	80 91 d9 1a 	lds	r24, 0x1AD9
    3196:	81 30       	cpi	r24, 0x01	; 1
    3198:	41 f4       	brne	.+16     	; 0x31aa <xTaskResumeAll+0x104>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
    319a:	10 92 d9 1a 	sts	0x1AD9, r1
					portYIELD_WITHIN_API();
    319e:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
    31a2:	81 e0       	ldi	r24, 0x01	; 1
    31a4:	03 c0       	rjmp	.+6      	; 0x31ac <xTaskResumeAll+0x106>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    31a6:	80 e0       	ldi	r24, 0x00	; 0
    31a8:	01 c0       	rjmp	.+2      	; 0x31ac <xTaskResumeAll+0x106>
    31aa:	80 e0       	ldi	r24, 0x00	; 0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    31ac:	0f 90       	pop	r0
    31ae:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    31b0:	df 91       	pop	r29
    31b2:	cf 91       	pop	r28
    31b4:	1f 91       	pop	r17
    31b6:	0f 91       	pop	r16
    31b8:	ff 90       	pop	r15
    31ba:	ef 90       	pop	r14
    31bc:	df 90       	pop	r13
    31be:	cf 90       	pop	r12
    31c0:	bf 90       	pop	r11
    31c2:	af 90       	pop	r10
    31c4:	08 95       	ret

000031c6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    31c6:	cf 93       	push	r28
    31c8:	df 93       	push	r29
    31ca:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    31cc:	00 97       	sbiw	r24, 0x00	; 0
    31ce:	b1 f0       	breq	.+44     	; 0x31fc <vTaskDelay+0x36>
		{
			vTaskSuspendAll();
    31d0:	0e 94 75 17 	call	0x2eea	; 0x2eea <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    31d4:	80 91 de 1a 	lds	r24, 0x1ADE
    31d8:	90 91 df 1a 	lds	r25, 0x1ADF
    31dc:	c8 0f       	add	r28, r24
    31de:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    31e0:	80 91 d6 1a 	lds	r24, 0x1AD6
    31e4:	90 91 d7 1a 	lds	r25, 0x1AD7
    31e8:	02 96       	adiw	r24, 0x02	; 2
    31ea:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    31ee:	ce 01       	movw	r24, r28
    31f0:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    31f4:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    31f8:	88 23       	and	r24, r24
    31fa:	11 f4       	brne	.+4      	; 0x3200 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    31fc:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
		}
	}
    3200:	df 91       	pop	r29
    3202:	cf 91       	pop	r28
    3204:	08 95       	ret

00003206 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    3206:	0f 93       	push	r16
    3208:	1f 93       	push	r17
    320a:	cf 93       	push	r28
    320c:	df 93       	push	r29
    320e:	8c 01       	movw	r16, r24
    3210:	eb 01       	movw	r28, r22
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    3212:	0e 94 75 17 	call	0x2eea	; 0x2eea <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    3216:	f8 01       	movw	r30, r16
    3218:	80 81       	ld	r24, Z
    321a:	91 81       	ldd	r25, Z+1	; 0x01
    321c:	c8 0f       	add	r28, r24
    321e:	d9 1f       	adc	r29, r25

			if( xTickCount < *pxPreviousWakeTime )
    3220:	20 91 de 1a 	lds	r18, 0x1ADE
    3224:	30 91 df 1a 	lds	r19, 0x1ADF
    3228:	28 17       	cp	r18, r24
    322a:	39 07       	cpc	r19, r25
    322c:	68 f4       	brcc	.+26     	; 0x3248 <vTaskDelayUntil+0x42>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    322e:	c8 17       	cp	r28, r24
    3230:	d9 07       	cpc	r29, r25
    3232:	50 f5       	brcc	.+84     	; 0x3288 <vTaskDelayUntil+0x82>
    3234:	80 91 de 1a 	lds	r24, 0x1ADE
    3238:	90 91 df 1a 	lds	r25, 0x1ADF
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    323c:	d1 83       	std	Z+1, r29	; 0x01
    323e:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    3240:	8c 17       	cp	r24, r28
    3242:	9d 07       	cpc	r25, r29
    3244:	b0 f4       	brcc	.+44     	; 0x3272 <vTaskDelayUntil+0x6c>
    3246:	0b c0       	rjmp	.+22     	; 0x325e <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    3248:	c8 17       	cp	r28, r24
    324a:	d9 07       	cpc	r29, r25
    324c:	c8 f0       	brcs	.+50     	; 0x3280 <vTaskDelayUntil+0x7a>
    324e:	80 91 de 1a 	lds	r24, 0x1ADE
    3252:	90 91 df 1a 	lds	r25, 0x1ADF
    3256:	8c 17       	cp	r24, r28
    3258:	9d 07       	cpc	r25, r29
    325a:	90 f0       	brcs	.+36     	; 0x3280 <vTaskDelayUntil+0x7a>
    325c:	15 c0       	rjmp	.+42     	; 0x3288 <vTaskDelayUntil+0x82>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    325e:	80 91 d6 1a 	lds	r24, 0x1AD6
    3262:	90 91 d7 1a 	lds	r25, 0x1AD7
    3266:	02 96       	adiw	r24, 0x02	; 2
    3268:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    326c:	ce 01       	movw	r24, r28
    326e:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3272:	0e 94 53 18 	call	0x30a6	; 0x30a6 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3276:	88 23       	and	r24, r24
    3278:	59 f4       	brne	.+22     	; 0x3290 <vTaskDelayUntil+0x8a>
		{
			portYIELD_WITHIN_API();
    327a:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
    327e:	08 c0       	rjmp	.+16     	; 0x3290 <vTaskDelayUntil+0x8a>
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3280:	f8 01       	movw	r30, r16
    3282:	d1 83       	std	Z+1, r29	; 0x01
    3284:	c0 83       	st	Z, r28
    3286:	eb cf       	rjmp	.-42     	; 0x325e <vTaskDelayUntil+0x58>
    3288:	f8 01       	movw	r30, r16
    328a:	d1 83       	std	Z+1, r29	; 0x01
    328c:	c0 83       	st	Z, r28
    328e:	f1 cf       	rjmp	.-30     	; 0x3272 <vTaskDelayUntil+0x6c>
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
    3290:	df 91       	pop	r29
    3292:	cf 91       	pop	r28
    3294:	1f 91       	pop	r17
    3296:	0f 91       	pop	r16
    3298:	08 95       	ret

0000329a <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    329a:	80 91 db 1a 	lds	r24, 0x1ADB
    329e:	88 23       	and	r24, r24
    32a0:	99 f4       	brne	.+38     	; 0x32c8 <vTaskSwitchContext+0x2e>

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    32a2:	80 91 dd 1a 	lds	r24, 0x1ADD
    32a6:	90 e0       	ldi	r25, 0x00	; 0
    32a8:	fc 01       	movw	r30, r24
    32aa:	ee 0f       	add	r30, r30
    32ac:	ff 1f       	adc	r31, r31
    32ae:	ee 0f       	add	r30, r30
    32b0:	ff 1f       	adc	r31, r31
    32b2:	ee 0f       	add	r30, r30
    32b4:	ff 1f       	adc	r31, r31
    32b6:	8e 0f       	add	r24, r30
    32b8:	9f 1f       	adc	r25, r31
    32ba:	fc 01       	movw	r30, r24
    32bc:	e9 51       	subi	r30, 0x19	; 25
    32be:	f5 4e       	sbci	r31, 0xE5	; 229
    32c0:	80 81       	ld	r24, Z
    32c2:	88 23       	and	r24, r24
    32c4:	29 f0       	breq	.+10     	; 0x32d0 <vTaskSwitchContext+0x36>
    32c6:	1b c0       	rjmp	.+54     	; 0x32fe <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    32c8:	81 e0       	ldi	r24, 0x01	; 1
    32ca:	80 93 d9 1a 	sts	0x1AD9, r24
    32ce:	08 95       	ret

//BB Commented out...
//		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
    32d0:	80 91 dd 1a 	lds	r24, 0x1ADD
    32d4:	81 50       	subi	r24, 0x01	; 1
    32d6:	80 93 dd 1a 	sts	0x1ADD, r24
    32da:	80 91 dd 1a 	lds	r24, 0x1ADD
    32de:	90 e0       	ldi	r25, 0x00	; 0
    32e0:	fc 01       	movw	r30, r24
    32e2:	ee 0f       	add	r30, r30
    32e4:	ff 1f       	adc	r31, r31
    32e6:	ee 0f       	add	r30, r30
    32e8:	ff 1f       	adc	r31, r31
    32ea:	ee 0f       	add	r30, r30
    32ec:	ff 1f       	adc	r31, r31
    32ee:	8e 0f       	add	r24, r30
    32f0:	9f 1f       	adc	r25, r31
    32f2:	fc 01       	movw	r30, r24
    32f4:	e9 51       	subi	r30, 0x19	; 25
    32f6:	f5 4e       	sbci	r31, 0xE5	; 229
    32f8:	80 81       	ld	r24, Z
    32fa:	88 23       	and	r24, r24
    32fc:	49 f3       	breq	.-46     	; 0x32d0 <vTaskSwitchContext+0x36>
    32fe:	80 91 dd 1a 	lds	r24, 0x1ADD
    3302:	90 e0       	ldi	r25, 0x00	; 0
    3304:	fc 01       	movw	r30, r24
    3306:	ee 0f       	add	r30, r30
    3308:	ff 1f       	adc	r31, r31
    330a:	ee 0f       	add	r30, r30
    330c:	ff 1f       	adc	r31, r31
    330e:	ee 0f       	add	r30, r30
    3310:	ff 1f       	adc	r31, r31
    3312:	e8 0f       	add	r30, r24
    3314:	f9 1f       	adc	r31, r25
    3316:	e9 51       	subi	r30, 0x19	; 25
    3318:	f5 4e       	sbci	r31, 0xE5	; 229
    331a:	a1 81       	ldd	r26, Z+1	; 0x01
    331c:	b2 81       	ldd	r27, Z+2	; 0x02
    331e:	12 96       	adiw	r26, 0x02	; 2
    3320:	0d 90       	ld	r0, X+
    3322:	bc 91       	ld	r27, X
    3324:	a0 2d       	mov	r26, r0
    3326:	b2 83       	std	Z+2, r27	; 0x02
    3328:	a1 83       	std	Z+1, r26	; 0x01
    332a:	cf 01       	movw	r24, r30
    332c:	03 96       	adiw	r24, 0x03	; 3
    332e:	a8 17       	cp	r26, r24
    3330:	b9 07       	cpc	r27, r25
    3332:	31 f4       	brne	.+12     	; 0x3340 <vTaskSwitchContext+0xa6>
    3334:	12 96       	adiw	r26, 0x02	; 2
    3336:	8d 91       	ld	r24, X+
    3338:	9c 91       	ld	r25, X
    333a:	13 97       	sbiw	r26, 0x03	; 3
    333c:	92 83       	std	Z+2, r25	; 0x02
    333e:	81 83       	std	Z+1, r24	; 0x01
    3340:	01 80       	ldd	r0, Z+1	; 0x01
    3342:	f2 81       	ldd	r31, Z+2	; 0x02
    3344:	e0 2d       	mov	r30, r0
    3346:	86 81       	ldd	r24, Z+6	; 0x06
    3348:	97 81       	ldd	r25, Z+7	; 0x07
    334a:	90 93 d7 1a 	sts	0x1AD7, r25
    334e:	80 93 d6 1a 	sts	0x1AD6, r24
    3352:	08 95       	ret

00003354 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    3354:	ef 92       	push	r14
    3356:	ff 92       	push	r15
    3358:	0f 93       	push	r16
    335a:	1f 93       	push	r17
    335c:	cf 93       	push	r28
    335e:	df 93       	push	r29
    3360:	7c 01       	movw	r14, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    3362:	0f b6       	in	r0, 0x3f	; 63
    3364:	f8 94       	cli
    3366:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    3368:	80 91 d6 1a 	lds	r24, 0x1AD6
    336c:	90 91 d7 1a 	lds	r25, 0x1AD7
    3370:	e8 16       	cp	r14, r24
    3372:	f9 06       	cpc	r15, r25
    3374:	21 f0       	breq	.+8      	; 0x337e <vTaskSuspend+0x2a>
			{
				pxTaskToSuspend = NULL;
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    3376:	e1 14       	cp	r14, r1
    3378:	f1 04       	cpc	r15, r1
    337a:	41 f4       	brne	.+16     	; 0x338c <vTaskSuspend+0x38>
    337c:	02 c0       	rjmp	.+4      	; 0x3382 <vTaskSuspend+0x2e>
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
			{
				pxTaskToSuspend = NULL;
    337e:	ee 24       	eor	r14, r14
    3380:	ff 24       	eor	r15, r15
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    3382:	c0 91 d6 1a 	lds	r28, 0x1AD6
    3386:	d0 91 d7 1a 	lds	r29, 0x1AD7
    338a:	01 c0       	rjmp	.+2      	; 0x338e <vTaskSuspend+0x3a>
    338c:	e7 01       	movw	r28, r14

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    338e:	8e 01       	movw	r16, r28
    3390:	0e 5f       	subi	r16, 0xFE	; 254
    3392:	1f 4f       	sbci	r17, 0xFF	; 255
    3394:	c8 01       	movw	r24, r16
    3396:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    339a:	8c 89       	ldd	r24, Y+20	; 0x14
    339c:	9d 89       	ldd	r25, Y+21	; 0x15
    339e:	00 97       	sbiw	r24, 0x00	; 0
    33a0:	21 f0       	breq	.+8      	; 0x33aa <vTaskSuspend+0x56>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
    33a2:	ce 01       	movw	r24, r28
    33a4:	0c 96       	adiw	r24, 0x0c	; 12
    33a6:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    33aa:	86 e2       	ldi	r24, 0x26	; 38
    33ac:	9b e1       	ldi	r25, 0x1B	; 27
    33ae:	b8 01       	movw	r22, r16
    33b0:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    33b4:	0f 90       	pop	r0
    33b6:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    33b8:	e1 14       	cp	r14, r1
    33ba:	f1 04       	cpc	r15, r1
    33bc:	a1 f4       	brne	.+40     	; 0x33e6 <vTaskSuspend+0x92>
		{
			if( xSchedulerRunning != pdFALSE )
    33be:	80 91 dc 1a 	lds	r24, 0x1ADC
    33c2:	88 23       	and	r24, r24
    33c4:	19 f0       	breq	.+6      	; 0x33cc <vTaskSuspend+0x78>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    33c6:	0e 94 24 11 	call	0x2248	; 0x2248 <vPortYield>
    33ca:	0d c0       	rjmp	.+26     	; 0x33e6 <vTaskSuspend+0x92>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    33cc:	90 91 26 1b 	lds	r25, 0x1B26
    33d0:	80 91 e0 1a 	lds	r24, 0x1AE0
    33d4:	98 17       	cp	r25, r24
    33d6:	29 f4       	brne	.+10     	; 0x33e2 <vTaskSuspend+0x8e>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    33d8:	10 92 d7 1a 	sts	0x1AD7, r1
    33dc:	10 92 d6 1a 	sts	0x1AD6, r1
    33e0:	02 c0       	rjmp	.+4      	; 0x33e6 <vTaskSuspend+0x92>
				}
				else
				{
					vTaskSwitchContext();
    33e2:	0e 94 4d 19 	call	0x329a	; 0x329a <vTaskSwitchContext>
				}
			}
		}
	}
    33e6:	df 91       	pop	r29
    33e8:	cf 91       	pop	r28
    33ea:	1f 91       	pop	r17
    33ec:	0f 91       	pop	r16
    33ee:	ff 90       	pop	r15
    33f0:	ef 90       	pop	r14
    33f2:	08 95       	ret

000033f4 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    33f4:	cf 93       	push	r28
    33f6:	df 93       	push	r29
    33f8:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    33fa:	60 91 d6 1a 	lds	r22, 0x1AD6
    33fe:	70 91 d7 1a 	lds	r23, 0x1AD7
    3402:	64 5f       	subi	r22, 0xF4	; 244
    3404:	7f 4f       	sbci	r23, 0xFF	; 255
    3406:	0e 94 e8 0f 	call	0x1fd0	; 0x1fd0 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
    340a:	80 91 d6 1a 	lds	r24, 0x1AD6
    340e:	90 91 d7 1a 	lds	r25, 0x1AD7
    3412:	02 96       	adiw	r24, 0x02	; 2
    3414:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    3418:	8f ef       	ldi	r24, 0xFF	; 255
    341a:	cf 3f       	cpi	r28, 0xFF	; 255
    341c:	d8 07       	cpc	r29, r24
    341e:	59 f4       	brne	.+22     	; 0x3436 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    3420:	60 91 d6 1a 	lds	r22, 0x1AD6
    3424:	70 91 d7 1a 	lds	r23, 0x1AD7
    3428:	6e 5f       	subi	r22, 0xFE	; 254
    342a:	7f 4f       	sbci	r23, 0xFF	; 255
    342c:	86 e2       	ldi	r24, 0x26	; 38
    342e:	9b e1       	ldi	r25, 0x1B	; 27
    3430:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
    3434:	08 c0       	rjmp	.+16     	; 0x3446 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    3436:	80 91 de 1a 	lds	r24, 0x1ADE
    343a:	90 91 df 1a 	lds	r25, 0x1ADF
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    343e:	8c 0f       	add	r24, r28
    3440:	9d 1f       	adc	r25, r29
    3442:	0e 94 4a 15 	call	0x2a94	; 0x2a94 <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    3446:	df 91       	pop	r29
    3448:	cf 91       	pop	r28
    344a:	08 95       	ret

0000344c <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    344c:	0f 93       	push	r16
    344e:	1f 93       	push	r17
    3450:	cf 93       	push	r28
    3452:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    3454:	dc 01       	movw	r26, r24
    3456:	15 96       	adiw	r26, 0x05	; 5
    3458:	ed 91       	ld	r30, X+
    345a:	fc 91       	ld	r31, X
    345c:	16 97       	sbiw	r26, 0x06	; 6
    345e:	06 81       	ldd	r16, Z+6	; 0x06
    3460:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3462:	e8 01       	movw	r28, r16
    3464:	2c 96       	adiw	r28, 0x0c	; 12
    3466:	ce 01       	movw	r24, r28
    3468:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    346c:	80 91 db 1a 	lds	r24, 0x1ADB
    3470:	88 23       	and	r24, r24
    3472:	e9 f4       	brne	.+58     	; 0x34ae <xTaskRemoveFromEventList+0x62>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    3474:	e8 01       	movw	r28, r16
    3476:	22 96       	adiw	r28, 0x02	; 2
    3478:	ce 01       	movw	r24, r28
    347a:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    347e:	f8 01       	movw	r30, r16
    3480:	86 89       	ldd	r24, Z+22	; 0x16
    3482:	90 91 dd 1a 	lds	r25, 0x1ADD
    3486:	98 17       	cp	r25, r24
    3488:	10 f4       	brcc	.+4      	; 0x348e <xTaskRemoveFromEventList+0x42>
    348a:	80 93 dd 1a 	sts	0x1ADD, r24
    348e:	90 e0       	ldi	r25, 0x00	; 0
    3490:	9c 01       	movw	r18, r24
    3492:	22 0f       	add	r18, r18
    3494:	33 1f       	adc	r19, r19
    3496:	22 0f       	add	r18, r18
    3498:	33 1f       	adc	r19, r19
    349a:	22 0f       	add	r18, r18
    349c:	33 1f       	adc	r19, r19
    349e:	82 0f       	add	r24, r18
    34a0:	93 1f       	adc	r25, r19
    34a2:	89 51       	subi	r24, 0x19	; 25
    34a4:	95 4e       	sbci	r25, 0xE5	; 229
    34a6:	be 01       	movw	r22, r28
    34a8:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
    34ac:	05 c0       	rjmp	.+10     	; 0x34b8 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    34ae:	8d e1       	ldi	r24, 0x1D	; 29
    34b0:	9b e1       	ldi	r25, 0x1B	; 27
    34b2:	be 01       	movw	r22, r28
    34b4:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    34b8:	e0 91 d6 1a 	lds	r30, 0x1AD6
    34bc:	f0 91 d7 1a 	lds	r31, 0x1AD7
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    34c0:	81 e0       	ldi	r24, 0x01	; 1
    34c2:	d8 01       	movw	r26, r16
    34c4:	56 96       	adiw	r26, 0x16	; 22
    34c6:	2c 91       	ld	r18, X
    34c8:	56 97       	sbiw	r26, 0x16	; 22
    34ca:	96 89       	ldd	r25, Z+22	; 0x16
    34cc:	29 17       	cp	r18, r25
    34ce:	08 f4       	brcc	.+2      	; 0x34d2 <xTaskRemoveFromEventList+0x86>
    34d0:	80 e0       	ldi	r24, 0x00	; 0
}
    34d2:	df 91       	pop	r29
    34d4:	cf 91       	pop	r28
    34d6:	1f 91       	pop	r17
    34d8:	0f 91       	pop	r16
    34da:	08 95       	ret

000034dc <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    34dc:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    34de:	80 91 d8 1a 	lds	r24, 0x1AD8
    34e2:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    34e4:	80 91 de 1a 	lds	r24, 0x1ADE
    34e8:	90 91 df 1a 	lds	r25, 0x1ADF
    34ec:	92 83       	std	Z+2, r25	; 0x02
    34ee:	81 83       	std	Z+1, r24	; 0x01
}
    34f0:	08 95       	ret

000034f2 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    34f2:	fc 01       	movw	r30, r24
    34f4:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    34f6:	0f b6       	in	r0, 0x3f	; 63
    34f8:	f8 94       	cli
    34fa:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    34fc:	4d 91       	ld	r20, X+
    34fe:	5c 91       	ld	r21, X
    3500:	11 97       	sbiw	r26, 0x01	; 1
    3502:	6f ef       	ldi	r22, 0xFF	; 255
    3504:	4f 3f       	cpi	r20, 0xFF	; 255
    3506:	56 07       	cpc	r21, r22
    3508:	51 f1       	breq	.+84     	; 0x355e <xTaskCheckForTimeOut+0x6c>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    350a:	80 91 d8 1a 	lds	r24, 0x1AD8
    350e:	90 81       	ld	r25, Z
    3510:	98 17       	cp	r25, r24
    3512:	49 f0       	breq	.+18     	; 0x3526 <xTaskCheckForTimeOut+0x34>
    3514:	20 91 de 1a 	lds	r18, 0x1ADE
    3518:	30 91 df 1a 	lds	r19, 0x1ADF
    351c:	81 81       	ldd	r24, Z+1	; 0x01
    351e:	92 81       	ldd	r25, Z+2	; 0x02
    3520:	28 17       	cp	r18, r24
    3522:	39 07       	cpc	r19, r25
    3524:	f0 f4       	brcc	.+60     	; 0x3562 <xTaskCheckForTimeOut+0x70>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    3526:	80 91 de 1a 	lds	r24, 0x1ADE
    352a:	90 91 df 1a 	lds	r25, 0x1ADF
    352e:	21 81       	ldd	r18, Z+1	; 0x01
    3530:	32 81       	ldd	r19, Z+2	; 0x02
    3532:	82 1b       	sub	r24, r18
    3534:	93 0b       	sbc	r25, r19
    3536:	84 17       	cp	r24, r20
    3538:	95 07       	cpc	r25, r21
    353a:	a8 f4       	brcc	.+42     	; 0x3566 <xTaskCheckForTimeOut+0x74>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    353c:	80 91 de 1a 	lds	r24, 0x1ADE
    3540:	90 91 df 1a 	lds	r25, 0x1ADF
    3544:	b9 01       	movw	r22, r18
    3546:	68 1b       	sub	r22, r24
    3548:	79 0b       	sbc	r23, r25
    354a:	cb 01       	movw	r24, r22
    354c:	84 0f       	add	r24, r20
    354e:	95 1f       	adc	r25, r21
    3550:	8d 93       	st	X+, r24
    3552:	9c 93       	st	X, r25
			vTaskSetTimeOutState( pxTimeOut );
    3554:	cf 01       	movw	r24, r30
    3556:	0e 94 6e 1a 	call	0x34dc	; 0x34dc <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    355a:	80 e0       	ldi	r24, 0x00	; 0
    355c:	05 c0       	rjmp	.+10     	; 0x3568 <xTaskCheckForTimeOut+0x76>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    355e:	80 e0       	ldi	r24, 0x00	; 0
    3560:	03 c0       	rjmp	.+6      	; 0x3568 <xTaskCheckForTimeOut+0x76>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    3562:	81 e0       	ldi	r24, 0x01	; 1
    3564:	01 c0       	rjmp	.+2      	; 0x3568 <xTaskCheckForTimeOut+0x76>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    3566:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    3568:	0f 90       	pop	r0
    356a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    356c:	08 95       	ret

0000356e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    356e:	81 e0       	ldi	r24, 0x01	; 1
    3570:	80 93 d9 1a 	sts	0x1AD9, r24
}
    3574:	08 95       	ret

00003576 <uxTaskGetStackHighWaterMark>:
	{
	tskTCB *pxTCB;
	unsigned char *pcEndOfStack;
	unsigned portBASE_TYPE uxReturn;

		pxTCB = prvGetTCBFromHandle( xTask );
    3576:	00 97       	sbiw	r24, 0x00	; 0
    3578:	29 f4       	brne	.+10     	; 0x3584 <uxTaskGetStackHighWaterMark+0xe>
    357a:	e0 91 d6 1a 	lds	r30, 0x1AD6
    357e:	f0 91 d7 1a 	lds	r31, 0x1AD7
    3582:	01 c0       	rjmp	.+2      	; 0x3586 <uxTaskGetStackHighWaterMark+0x10>
    3584:	fc 01       	movw	r30, r24

		#if portSTACK_GROWTH < 0
		{
			pcEndOfStack = ( unsigned char * ) pxTCB->pxStack;
    3586:	07 88       	ldd	r0, Z+23	; 0x17
    3588:	f0 8d       	ldd	r31, Z+24	; 0x18
    358a:	e0 2d       	mov	r30, r0

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    358c:	80 81       	ld	r24, Z
    358e:	85 3a       	cpi	r24, 0xA5	; 165
    3590:	41 f4       	brne	.+16     	; 0x35a2 <uxTaskGetStackHighWaterMark+0x2c>
#endif
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskGetStackHighWaterMark == 1 )

	unsigned portBASE_TYPE uxTaskGetStackHighWaterMark( xTaskHandle xTask )
    3592:	31 96       	adiw	r30, 0x01	; 1

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    3594:	80 e0       	ldi	r24, 0x00	; 0
    3596:	90 e0       	ldi	r25, 0x00	; 0

		while( *pucStackByte == tskSTACK_FILL_BYTE )
		{
			pucStackByte -= portSTACK_GROWTH;
			usCount++;
    3598:	01 96       	adiw	r24, 0x01	; 1

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;

		while( *pucStackByte == tskSTACK_FILL_BYTE )
    359a:	21 91       	ld	r18, Z+
    359c:	25 3a       	cpi	r18, 0xA5	; 165
    359e:	e1 f3       	breq	.-8      	; 0x3598 <uxTaskGetStackHighWaterMark+0x22>
    35a0:	08 95       	ret

#if ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )

	static unsigned short usTaskCheckFreeStackSpace( const unsigned char * pucStackByte )
	{
	register unsigned short usCount = 0U;
    35a2:	80 e0       	ldi	r24, 0x00	; 0
    35a4:	90 e0       	ldi	r25, 0x00	; 0
		#endif

		uxReturn = ( unsigned portBASE_TYPE ) usTaskCheckFreeStackSpace( pcEndOfStack );

		return uxReturn;
	}
    35a6:	08 95       	ret

000035a8 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
    35a8:	80 91 d6 1a 	lds	r24, 0x1AD6
    35ac:	90 91 d7 1a 	lds	r25, 0x1AD7

		return xReturn;
	}
    35b0:	08 95       	ret

000035b2 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
    35b2:	0f 93       	push	r16
    35b4:	1f 93       	push	r17
    35b6:	cf 93       	push	r28
    35b8:	df 93       	push	r29
    35ba:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    35bc:	00 97       	sbiw	r24, 0x00	; 0
    35be:	09 f4       	brne	.+2      	; 0x35c2 <vTaskPriorityInherit+0x10>
    35c0:	4d c0       	rjmp	.+154    	; 0x365c <vTaskPriorityInherit+0xaa>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    35c2:	8e 89       	ldd	r24, Y+22	; 0x16
    35c4:	e0 91 d6 1a 	lds	r30, 0x1AD6
    35c8:	f0 91 d7 1a 	lds	r31, 0x1AD7
    35cc:	96 89       	ldd	r25, Z+22	; 0x16
    35ce:	89 17       	cp	r24, r25
    35d0:	08 f0       	brcs	.+2      	; 0x35d4 <vTaskPriorityInherit+0x22>
    35d2:	44 c0       	rjmp	.+136    	; 0x365c <vTaskPriorityInherit+0xaa>
			{
				/* Adjust the mutex holder state to account for its new priority. */
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
    35d4:	e0 91 d6 1a 	lds	r30, 0x1AD6
    35d8:	f0 91 d7 1a 	lds	r31, 0x1AD7
    35dc:	96 89       	ldd	r25, Z+22	; 0x16
    35de:	24 e0       	ldi	r18, 0x04	; 4
    35e0:	30 e0       	ldi	r19, 0x00	; 0
    35e2:	29 1b       	sub	r18, r25
    35e4:	31 09       	sbc	r19, r1
    35e6:	3d 87       	std	Y+13, r19	; 0x0d
    35e8:	2c 87       	std	Y+12, r18	; 0x0c

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    35ea:	90 e0       	ldi	r25, 0x00	; 0
    35ec:	9c 01       	movw	r18, r24
    35ee:	22 0f       	add	r18, r18
    35f0:	33 1f       	adc	r19, r19
    35f2:	22 0f       	add	r18, r18
    35f4:	33 1f       	adc	r19, r19
    35f6:	22 0f       	add	r18, r18
    35f8:	33 1f       	adc	r19, r19
    35fa:	82 0f       	add	r24, r18
    35fc:	93 1f       	adc	r25, r19
    35fe:	89 51       	subi	r24, 0x19	; 25
    3600:	95 4e       	sbci	r25, 0xE5	; 229
    3602:	2a 85       	ldd	r18, Y+10	; 0x0a
    3604:	3b 85       	ldd	r19, Y+11	; 0x0b
    3606:	28 17       	cp	r18, r24
    3608:	39 07       	cpc	r19, r25
    360a:	11 f5       	brne	.+68     	; 0x3650 <vTaskPriorityInherit+0x9e>
				{
					if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    360c:	8e 01       	movw	r16, r28
    360e:	0e 5f       	subi	r16, 0xFE	; 254
    3610:	1f 4f       	sbci	r17, 0xFF	; 255
    3612:	c8 01       	movw	r24, r16
    3614:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3618:	e0 91 d6 1a 	lds	r30, 0x1AD6
    361c:	f0 91 d7 1a 	lds	r31, 0x1AD7
    3620:	86 89       	ldd	r24, Z+22	; 0x16
    3622:	8e 8b       	std	Y+22, r24	; 0x16
					prvAddTaskToReadyQueue( pxTCB );
    3624:	90 91 dd 1a 	lds	r25, 0x1ADD
    3628:	98 17       	cp	r25, r24
    362a:	10 f4       	brcc	.+4      	; 0x3630 <vTaskPriorityInherit+0x7e>
    362c:	80 93 dd 1a 	sts	0x1ADD, r24
    3630:	90 e0       	ldi	r25, 0x00	; 0
    3632:	9c 01       	movw	r18, r24
    3634:	22 0f       	add	r18, r18
    3636:	33 1f       	adc	r19, r19
    3638:	22 0f       	add	r18, r18
    363a:	33 1f       	adc	r19, r19
    363c:	22 0f       	add	r18, r18
    363e:	33 1f       	adc	r19, r19
    3640:	82 0f       	add	r24, r18
    3642:	93 1f       	adc	r25, r19
    3644:	89 51       	subi	r24, 0x19	; 25
    3646:	95 4e       	sbci	r25, 0xE5	; 229
    3648:	b8 01       	movw	r22, r16
    364a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
    364e:	06 c0       	rjmp	.+12     	; 0x365c <vTaskPriorityInherit+0xaa>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    3650:	e0 91 d6 1a 	lds	r30, 0x1AD6
    3654:	f0 91 d7 1a 	lds	r31, 0x1AD7
    3658:	86 89       	ldd	r24, Z+22	; 0x16
    365a:	8e 8b       	std	Y+22, r24	; 0x16
				}

				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
			}
		}
	}
    365c:	df 91       	pop	r29
    365e:	cf 91       	pop	r28
    3660:	1f 91       	pop	r17
    3662:	0f 91       	pop	r16
    3664:	08 95       	ret

00003666 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
    3666:	0f 93       	push	r16
    3668:	1f 93       	push	r17
    366a:	cf 93       	push	r28
    366c:	df 93       	push	r29
    366e:	ec 01       	movw	r28, r24
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
    3670:	00 97       	sbiw	r24, 0x00	; 0
    3672:	49 f1       	breq	.+82     	; 0x36c6 <vTaskPriorityDisinherit+0x60>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    3674:	9e 89       	ldd	r25, Y+22	; 0x16
    3676:	89 a5       	lds	r24, 0x69
    3678:	98 17       	cp	r25, r24
    367a:	29 f1       	breq	.+74     	; 0x36c6 <vTaskPriorityDisinherit+0x60>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
    367c:	8e 01       	movw	r16, r28
    367e:	0e 5f       	subi	r16, 0xFE	; 254
    3680:	1f 4f       	sbci	r17, 0xFF	; 255
    3682:	c8 01       	movw	r24, r16
    3684:	0e 94 25 10 	call	0x204a	; 0x204a <uxListRemove>
				}

				/* Disinherit the priority before adding the task into the new
				ready list. */
				traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
				pxTCB->uxPriority = pxTCB->uxBasePriority;
    3688:	49 a5       	lds	r20, 0x69
    368a:	4e 8b       	std	Y+22, r20	; 0x16
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
    368c:	24 2f       	mov	r18, r20
    368e:	30 e0       	ldi	r19, 0x00	; 0
    3690:	84 e0       	ldi	r24, 0x04	; 4
    3692:	90 e0       	ldi	r25, 0x00	; 0
    3694:	82 1b       	sub	r24, r18
    3696:	93 0b       	sbc	r25, r19
    3698:	9d 87       	std	Y+13, r25	; 0x0d
    369a:	8c 87       	std	Y+12, r24	; 0x0c
				prvAddTaskToReadyQueue( pxTCB );
    369c:	80 91 dd 1a 	lds	r24, 0x1ADD
    36a0:	84 17       	cp	r24, r20
    36a2:	10 f4       	brcc	.+4      	; 0x36a8 <vTaskPriorityDisinherit+0x42>
    36a4:	40 93 dd 1a 	sts	0x1ADD, r20
    36a8:	c9 01       	movw	r24, r18
    36aa:	88 0f       	add	r24, r24
    36ac:	99 1f       	adc	r25, r25
    36ae:	88 0f       	add	r24, r24
    36b0:	99 1f       	adc	r25, r25
    36b2:	88 0f       	add	r24, r24
    36b4:	99 1f       	adc	r25, r25
    36b6:	28 0f       	add	r18, r24
    36b8:	39 1f       	adc	r19, r25
    36ba:	c9 01       	movw	r24, r18
    36bc:	89 51       	subi	r24, 0x19	; 25
    36be:	95 4e       	sbci	r25, 0xE5	; 229
    36c0:	b8 01       	movw	r22, r16
    36c2:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <vListInsertEnd>
			}
		}
	}
    36c6:	df 91       	pop	r29
    36c8:	cf 91       	pop	r28
    36ca:	1f 91       	pop	r17
    36cc:	0f 91       	pop	r16
    36ce:	08 95       	ret

000036d0 <USART_Init>:
*  the specified baud rate and clk speed.
*
* Param buadin: The desired Baud rate.
* Param clk_seedin: The clk speed of the ATmega328p
************************************/
void USART_Init(uint16_t baudin, uint32_t clk_speedin) {
    36d0:	cf 92       	push	r12
    36d2:	df 92       	push	r13
    36d4:	ef 92       	push	r14
    36d6:	ff 92       	push	r15
    uint32_t ubrr = clk_speedin/(16UL)/baudin-1;
    36d8:	6a 01       	movw	r12, r20
    36da:	7b 01       	movw	r14, r22
    36dc:	68 94       	set
    36de:	13 f8       	bld	r1, 3
    36e0:	f6 94       	lsr	r15
    36e2:	e7 94       	ror	r14
    36e4:	d7 94       	ror	r13
    36e6:	c7 94       	ror	r12
    36e8:	16 94       	lsr	r1
    36ea:	d1 f7       	brne	.-12     	; 0x36e0 <USART_Init+0x10>
    36ec:	9c 01       	movw	r18, r24
    36ee:	40 e0       	ldi	r20, 0x00	; 0
    36f0:	50 e0       	ldi	r21, 0x00	; 0
    36f2:	c7 01       	movw	r24, r14
    36f4:	b6 01       	movw	r22, r12
    36f6:	0e 94 92 1e 	call	0x3d24	; 0x3d24 <__udivmodsi4>
    36fa:	da 01       	movw	r26, r20
    36fc:	c9 01       	movw	r24, r18
    36fe:	01 97       	sbiw	r24, 0x01	; 1
    3700:	a1 09       	sbc	r26, r1
    3702:	b1 09       	sbc	r27, r1
    UBRR0H = (unsigned char)(ubrr>>8) ;// & 0x7F;
    3704:	49 2f       	mov	r20, r25
    3706:	5a 2f       	mov	r21, r26
    3708:	6b 2f       	mov	r22, r27
    370a:	77 27       	eor	r23, r23
    370c:	40 93 c5 00 	sts	0x00C5, r20
    UBRR0L = (unsigned char)ubrr;
    3710:	80 93 c4 00 	sts	0x00C4, r24
    /* Enable receiver and transmitter */
    UCSR0B = (1<<RXEN0)|(1<<TXEN0);
    3714:	88 e1       	ldi	r24, 0x18	; 24
    3716:	80 93 c1 00 	sts	0x00C1, r24
    /* Set frame format: 8data, 1stop bit */
    UCSR0C = (1<<UCSZ01)|(1<<UCSZ00);
    371a:	86 e0       	ldi	r24, 0x06	; 6
    371c:	80 93 c2 00 	sts	0x00C2, r24
	// clear U2X0 for Synchronous operation
    UCSR0A &= ~(1<<U2X0);
    3720:	e0 ec       	ldi	r30, 0xC0	; 192
    3722:	f0 e0       	ldi	r31, 0x00	; 0
    3724:	80 81       	ld	r24, Z
    3726:	8d 7f       	andi	r24, 0xFD	; 253
    3728:	80 83       	st	Z, r24
	
	xUsartQueue = xQueueCreate( 150, sizeof( uint8_t ));
    372a:	86 e9       	ldi	r24, 0x96	; 150
    372c:	61 e0       	ldi	r22, 0x01	; 1
    372e:	40 e0       	ldi	r20, 0x00	; 0
    3730:	0e 94 fa 12 	call	0x25f4	; 0x25f4 <xQueueGenericCreate>
    3734:	90 93 30 1b 	sts	0x1B30, r25
    3738:	80 93 2f 1b 	sts	0x1B2F, r24
}
    373c:	ff 90       	pop	r15
    373e:	ef 90       	pop	r14
    3740:	df 90       	pop	r13
    3742:	cf 90       	pop	r12
    3744:	08 95       	ret

00003746 <USART_Write>:
* Description: Adds a byte of data to 
*			   the back of a queue.
*
* Param data: 8bit data value
************************************/
void USART_Write(uint8_t data) {
    3746:	cf 93       	push	r28
    3748:	df 93       	push	r29
    374a:	0f 92       	push	r0
    374c:	cd b7       	in	r28, 0x3d	; 61
    374e:	de b7       	in	r29, 0x3e	; 62
    3750:	89 83       	std	Y+1, r24	; 0x01
	xQueueSendToBack( xUsartQueue, &data, 0);
    3752:	80 91 2f 1b 	lds	r24, 0x1B2F
    3756:	90 91 30 1b 	lds	r25, 0x1B30
    375a:	be 01       	movw	r22, r28
    375c:	6f 5f       	subi	r22, 0xFF	; 255
    375e:	7f 4f       	sbci	r23, 0xFF	; 255
    3760:	40 e0       	ldi	r20, 0x00	; 0
    3762:	50 e0       	ldi	r21, 0x00	; 0
    3764:	20 e0       	ldi	r18, 0x00	; 0
    3766:	0e 94 2b 13 	call	0x2656	; 0x2656 <xQueueGenericSend>
}
    376a:	0f 90       	pop	r0
    376c:	df 91       	pop	r29
    376e:	cf 91       	pop	r28
    3770:	08 95       	ret

00003772 <USART_Write_Unprotected>:
*
* Param data: 8bit data value
************************************/
void USART_Write_Unprotected(uint8_t data) {
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) );
    3772:	e0 ec       	ldi	r30, 0xC0	; 192
    3774:	f0 e0       	ldi	r31, 0x00	; 0
    3776:	90 81       	ld	r25, Z
    3778:	95 ff       	sbrs	r25, 5
    377a:	fd cf       	rjmp	.-6      	; 0x3776 <USART_Write_Unprotected+0x4>
	/* Put data into buffer, sends the data */
	UDR0 = data;
    377c:	80 93 c6 00 	sts	0x00C6, r24
}
    3780:	08 95       	ret

00003782 <USART_Read>:
*
* Return UDR0: Received data
************************************/
uint8_t USART_Read(void) {
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) );
    3782:	e0 ec       	ldi	r30, 0xC0	; 192
    3784:	f0 e0       	ldi	r31, 0x00	; 0
    3786:	80 81       	ld	r24, Z
    3788:	88 23       	and	r24, r24
    378a:	ec f7       	brge	.-6      	; 0x3786 <USART_Read+0x4>
    /* Get and return received data from buffer */
    return UDR0;
    378c:	80 91 c6 00 	lds	r24, 0x00C6
}
    3790:	08 95       	ret

00003792 <USART_Write_Task>:
*
* Description: Sends queued data over UART
*
* Param vParam: This parameter is not used.
************************************/
void USART_Write_Task(void *vParam) {
    3792:	cf 93       	push	r28
    3794:	df 93       	push	r29
    3796:	0f 92       	push	r0
    3798:	cd b7       	in	r28, 0x3d	; 61
    379a:	de b7       	in	r29, 0x3e	; 62
	uint8_t uart_data;
    while (1) {
		xQueueReceive( xUsartQueue, &uart_data, portMAX_DELAY);
    379c:	80 91 2f 1b 	lds	r24, 0x1B2F
    37a0:	90 91 30 1b 	lds	r25, 0x1B30
    37a4:	be 01       	movw	r22, r28
    37a6:	6f 5f       	subi	r22, 0xFF	; 255
    37a8:	7f 4f       	sbci	r23, 0xFF	; 255
    37aa:	4f ef       	ldi	r20, 0xFF	; 255
    37ac:	5f ef       	ldi	r21, 0xFF	; 255
    37ae:	20 e0       	ldi	r18, 0x00	; 0
    37b0:	0e 94 28 14 	call	0x2850	; 0x2850 <xQueueGenericReceive>
		USART_Write_Unprotected(uart_data);
    37b4:	89 81       	ldd	r24, Y+1	; 0x01
    37b6:	0e 94 b9 1b 	call	0x3772	; 0x3772 <USART_Write_Unprotected>
    37ba:	f0 cf       	rjmp	.-32     	; 0x379c <USART_Write_Task+0xa>

000037bc <__subsf3>:
    37bc:	50 58       	subi	r21, 0x80	; 128

000037be <__addsf3>:
    37be:	bb 27       	eor	r27, r27
    37c0:	aa 27       	eor	r26, r26
    37c2:	0e d0       	rcall	.+28     	; 0x37e0 <__addsf3x>
    37c4:	a0 c1       	rjmp	.+832    	; 0x3b06 <__fp_round>
    37c6:	69 d1       	rcall	.+722    	; 0x3a9a <__fp_pscA>
    37c8:	30 f0       	brcs	.+12     	; 0x37d6 <__addsf3+0x18>
    37ca:	6e d1       	rcall	.+732    	; 0x3aa8 <__fp_pscB>
    37cc:	20 f0       	brcs	.+8      	; 0x37d6 <__addsf3+0x18>
    37ce:	31 f4       	brne	.+12     	; 0x37dc <__addsf3+0x1e>
    37d0:	9f 3f       	cpi	r25, 0xFF	; 255
    37d2:	11 f4       	brne	.+4      	; 0x37d8 <__addsf3+0x1a>
    37d4:	1e f4       	brtc	.+6      	; 0x37dc <__addsf3+0x1e>
    37d6:	5e c1       	rjmp	.+700    	; 0x3a94 <__fp_nan>
    37d8:	0e f4       	brtc	.+2      	; 0x37dc <__addsf3+0x1e>
    37da:	e0 95       	com	r30
    37dc:	e7 fb       	bst	r30, 7
    37de:	54 c1       	rjmp	.+680    	; 0x3a88 <__fp_inf>

000037e0 <__addsf3x>:
    37e0:	e9 2f       	mov	r30, r25
    37e2:	b3 d1       	rcall	.+870    	; 0x3b4a <__fp_split3>
    37e4:	80 f3       	brcs	.-32     	; 0x37c6 <__addsf3+0x8>
    37e6:	ba 17       	cp	r27, r26
    37e8:	62 07       	cpc	r22, r18
    37ea:	73 07       	cpc	r23, r19
    37ec:	84 07       	cpc	r24, r20
    37ee:	95 07       	cpc	r25, r21
    37f0:	18 f0       	brcs	.+6      	; 0x37f8 <__addsf3x+0x18>
    37f2:	71 f4       	brne	.+28     	; 0x3810 <__addsf3x+0x30>
    37f4:	9e f5       	brtc	.+102    	; 0x385c <__addsf3x+0x7c>
    37f6:	cb c1       	rjmp	.+918    	; 0x3b8e <__fp_zero>
    37f8:	0e f4       	brtc	.+2      	; 0x37fc <__addsf3x+0x1c>
    37fa:	e0 95       	com	r30
    37fc:	0b 2e       	mov	r0, r27
    37fe:	ba 2f       	mov	r27, r26
    3800:	a0 2d       	mov	r26, r0
    3802:	0b 01       	movw	r0, r22
    3804:	b9 01       	movw	r22, r18
    3806:	90 01       	movw	r18, r0
    3808:	0c 01       	movw	r0, r24
    380a:	ca 01       	movw	r24, r20
    380c:	a0 01       	movw	r20, r0
    380e:	11 24       	eor	r1, r1
    3810:	ff 27       	eor	r31, r31
    3812:	59 1b       	sub	r21, r25
    3814:	99 f0       	breq	.+38     	; 0x383c <__addsf3x+0x5c>
    3816:	59 3f       	cpi	r21, 0xF9	; 249
    3818:	50 f4       	brcc	.+20     	; 0x382e <__addsf3x+0x4e>
    381a:	50 3e       	cpi	r21, 0xE0	; 224
    381c:	68 f1       	brcs	.+90     	; 0x3878 <__addsf3x+0x98>
    381e:	1a 16       	cp	r1, r26
    3820:	f0 40       	sbci	r31, 0x00	; 0
    3822:	a2 2f       	mov	r26, r18
    3824:	23 2f       	mov	r18, r19
    3826:	34 2f       	mov	r19, r20
    3828:	44 27       	eor	r20, r20
    382a:	58 5f       	subi	r21, 0xF8	; 248
    382c:	f3 cf       	rjmp	.-26     	; 0x3814 <__addsf3x+0x34>
    382e:	46 95       	lsr	r20
    3830:	37 95       	ror	r19
    3832:	27 95       	ror	r18
    3834:	a7 95       	ror	r26
    3836:	f0 40       	sbci	r31, 0x00	; 0
    3838:	53 95       	inc	r21
    383a:	c9 f7       	brne	.-14     	; 0x382e <__addsf3x+0x4e>
    383c:	7e f4       	brtc	.+30     	; 0x385c <__addsf3x+0x7c>
    383e:	1f 16       	cp	r1, r31
    3840:	ba 0b       	sbc	r27, r26
    3842:	62 0b       	sbc	r22, r18
    3844:	73 0b       	sbc	r23, r19
    3846:	84 0b       	sbc	r24, r20
    3848:	ba f0       	brmi	.+46     	; 0x3878 <__addsf3x+0x98>
    384a:	91 50       	subi	r25, 0x01	; 1
    384c:	a1 f0       	breq	.+40     	; 0x3876 <__addsf3x+0x96>
    384e:	ff 0f       	add	r31, r31
    3850:	bb 1f       	adc	r27, r27
    3852:	66 1f       	adc	r22, r22
    3854:	77 1f       	adc	r23, r23
    3856:	88 1f       	adc	r24, r24
    3858:	c2 f7       	brpl	.-16     	; 0x384a <__addsf3x+0x6a>
    385a:	0e c0       	rjmp	.+28     	; 0x3878 <__addsf3x+0x98>
    385c:	ba 0f       	add	r27, r26
    385e:	62 1f       	adc	r22, r18
    3860:	73 1f       	adc	r23, r19
    3862:	84 1f       	adc	r24, r20
    3864:	48 f4       	brcc	.+18     	; 0x3878 <__addsf3x+0x98>
    3866:	87 95       	ror	r24
    3868:	77 95       	ror	r23
    386a:	67 95       	ror	r22
    386c:	b7 95       	ror	r27
    386e:	f7 95       	ror	r31
    3870:	9e 3f       	cpi	r25, 0xFE	; 254
    3872:	08 f0       	brcs	.+2      	; 0x3876 <__addsf3x+0x96>
    3874:	b3 cf       	rjmp	.-154    	; 0x37dc <__addsf3+0x1e>
    3876:	93 95       	inc	r25
    3878:	88 0f       	add	r24, r24
    387a:	08 f0       	brcs	.+2      	; 0x387e <__addsf3x+0x9e>
    387c:	99 27       	eor	r25, r25
    387e:	ee 0f       	add	r30, r30
    3880:	97 95       	ror	r25
    3882:	87 95       	ror	r24
    3884:	08 95       	ret

00003886 <__cmpsf2>:
    3886:	dc d0       	rcall	.+440    	; 0x3a40 <__fp_cmp>
    3888:	08 f4       	brcc	.+2      	; 0x388c <__cmpsf2+0x6>
    388a:	81 e0       	ldi	r24, 0x01	; 1
    388c:	08 95       	ret

0000388e <cos>:
    388e:	14 d1       	rcall	.+552    	; 0x3ab8 <__fp_rempio2>
    3890:	e3 95       	inc	r30
    3892:	4a c1       	rjmp	.+660    	; 0x3b28 <__fp_sinus>

00003894 <__divsf3>:
    3894:	0c d0       	rcall	.+24     	; 0x38ae <__divsf3x>
    3896:	37 c1       	rjmp	.+622    	; 0x3b06 <__fp_round>
    3898:	07 d1       	rcall	.+526    	; 0x3aa8 <__fp_pscB>
    389a:	40 f0       	brcs	.+16     	; 0x38ac <__divsf3+0x18>
    389c:	fe d0       	rcall	.+508    	; 0x3a9a <__fp_pscA>
    389e:	30 f0       	brcs	.+12     	; 0x38ac <__divsf3+0x18>
    38a0:	21 f4       	brne	.+8      	; 0x38aa <__divsf3+0x16>
    38a2:	5f 3f       	cpi	r21, 0xFF	; 255
    38a4:	19 f0       	breq	.+6      	; 0x38ac <__divsf3+0x18>
    38a6:	f0 c0       	rjmp	.+480    	; 0x3a88 <__fp_inf>
    38a8:	51 11       	cpse	r21, r1
    38aa:	72 c1       	rjmp	.+740    	; 0x3b90 <__fp_szero>
    38ac:	f3 c0       	rjmp	.+486    	; 0x3a94 <__fp_nan>

000038ae <__divsf3x>:
    38ae:	4d d1       	rcall	.+666    	; 0x3b4a <__fp_split3>
    38b0:	98 f3       	brcs	.-26     	; 0x3898 <__divsf3+0x4>

000038b2 <__divsf3_pse>:
    38b2:	99 23       	and	r25, r25
    38b4:	c9 f3       	breq	.-14     	; 0x38a8 <__divsf3+0x14>
    38b6:	55 23       	and	r21, r21
    38b8:	b1 f3       	breq	.-20     	; 0x38a6 <__divsf3+0x12>
    38ba:	95 1b       	sub	r25, r21
    38bc:	55 0b       	sbc	r21, r21
    38be:	bb 27       	eor	r27, r27
    38c0:	aa 27       	eor	r26, r26
    38c2:	62 17       	cp	r22, r18
    38c4:	73 07       	cpc	r23, r19
    38c6:	84 07       	cpc	r24, r20
    38c8:	38 f0       	brcs	.+14     	; 0x38d8 <__divsf3_pse+0x26>
    38ca:	9f 5f       	subi	r25, 0xFF	; 255
    38cc:	5f 4f       	sbci	r21, 0xFF	; 255
    38ce:	22 0f       	add	r18, r18
    38d0:	33 1f       	adc	r19, r19
    38d2:	44 1f       	adc	r20, r20
    38d4:	aa 1f       	adc	r26, r26
    38d6:	a9 f3       	breq	.-22     	; 0x38c2 <__divsf3_pse+0x10>
    38d8:	33 d0       	rcall	.+102    	; 0x3940 <__divsf3_pse+0x8e>
    38da:	0e 2e       	mov	r0, r30
    38dc:	3a f0       	brmi	.+14     	; 0x38ec <__divsf3_pse+0x3a>
    38de:	e0 e8       	ldi	r30, 0x80	; 128
    38e0:	30 d0       	rcall	.+96     	; 0x3942 <__divsf3_pse+0x90>
    38e2:	91 50       	subi	r25, 0x01	; 1
    38e4:	50 40       	sbci	r21, 0x00	; 0
    38e6:	e6 95       	lsr	r30
    38e8:	00 1c       	adc	r0, r0
    38ea:	ca f7       	brpl	.-14     	; 0x38de <__divsf3_pse+0x2c>
    38ec:	29 d0       	rcall	.+82     	; 0x3940 <__divsf3_pse+0x8e>
    38ee:	fe 2f       	mov	r31, r30
    38f0:	27 d0       	rcall	.+78     	; 0x3940 <__divsf3_pse+0x8e>
    38f2:	66 0f       	add	r22, r22
    38f4:	77 1f       	adc	r23, r23
    38f6:	88 1f       	adc	r24, r24
    38f8:	bb 1f       	adc	r27, r27
    38fa:	26 17       	cp	r18, r22
    38fc:	37 07       	cpc	r19, r23
    38fe:	48 07       	cpc	r20, r24
    3900:	ab 07       	cpc	r26, r27
    3902:	b0 e8       	ldi	r27, 0x80	; 128
    3904:	09 f0       	breq	.+2      	; 0x3908 <__divsf3_pse+0x56>
    3906:	bb 0b       	sbc	r27, r27
    3908:	80 2d       	mov	r24, r0
    390a:	bf 01       	movw	r22, r30
    390c:	ff 27       	eor	r31, r31
    390e:	93 58       	subi	r25, 0x83	; 131
    3910:	5f 4f       	sbci	r21, 0xFF	; 255
    3912:	2a f0       	brmi	.+10     	; 0x391e <__divsf3_pse+0x6c>
    3914:	9e 3f       	cpi	r25, 0xFE	; 254
    3916:	51 05       	cpc	r21, r1
    3918:	68 f0       	brcs	.+26     	; 0x3934 <__divsf3_pse+0x82>
    391a:	b6 c0       	rjmp	.+364    	; 0x3a88 <__fp_inf>
    391c:	39 c1       	rjmp	.+626    	; 0x3b90 <__fp_szero>
    391e:	5f 3f       	cpi	r21, 0xFF	; 255
    3920:	ec f3       	brlt	.-6      	; 0x391c <__divsf3_pse+0x6a>
    3922:	98 3e       	cpi	r25, 0xE8	; 232
    3924:	dc f3       	brlt	.-10     	; 0x391c <__divsf3_pse+0x6a>
    3926:	86 95       	lsr	r24
    3928:	77 95       	ror	r23
    392a:	67 95       	ror	r22
    392c:	b7 95       	ror	r27
    392e:	f7 95       	ror	r31
    3930:	9f 5f       	subi	r25, 0xFF	; 255
    3932:	c9 f7       	brne	.-14     	; 0x3926 <__divsf3_pse+0x74>
    3934:	88 0f       	add	r24, r24
    3936:	91 1d       	adc	r25, r1
    3938:	96 95       	lsr	r25
    393a:	87 95       	ror	r24
    393c:	97 f9       	bld	r25, 7
    393e:	08 95       	ret
    3940:	e1 e0       	ldi	r30, 0x01	; 1
    3942:	66 0f       	add	r22, r22
    3944:	77 1f       	adc	r23, r23
    3946:	88 1f       	adc	r24, r24
    3948:	bb 1f       	adc	r27, r27
    394a:	62 17       	cp	r22, r18
    394c:	73 07       	cpc	r23, r19
    394e:	84 07       	cpc	r24, r20
    3950:	ba 07       	cpc	r27, r26
    3952:	20 f0       	brcs	.+8      	; 0x395c <__divsf3_pse+0xaa>
    3954:	62 1b       	sub	r22, r18
    3956:	73 0b       	sbc	r23, r19
    3958:	84 0b       	sbc	r24, r20
    395a:	ba 0b       	sbc	r27, r26
    395c:	ee 1f       	adc	r30, r30
    395e:	88 f7       	brcc	.-30     	; 0x3942 <__divsf3_pse+0x90>
    3960:	e0 95       	com	r30
    3962:	08 95       	ret

00003964 <__fixsfsi>:
    3964:	04 d0       	rcall	.+8      	; 0x396e <__fixunssfsi>
    3966:	68 94       	set
    3968:	b1 11       	cpse	r27, r1
    396a:	12 c1       	rjmp	.+548    	; 0x3b90 <__fp_szero>
    396c:	08 95       	ret

0000396e <__fixunssfsi>:
    396e:	f5 d0       	rcall	.+490    	; 0x3b5a <__fp_splitA>
    3970:	88 f0       	brcs	.+34     	; 0x3994 <__fixunssfsi+0x26>
    3972:	9f 57       	subi	r25, 0x7F	; 127
    3974:	90 f0       	brcs	.+36     	; 0x399a <__fixunssfsi+0x2c>
    3976:	b9 2f       	mov	r27, r25
    3978:	99 27       	eor	r25, r25
    397a:	b7 51       	subi	r27, 0x17	; 23
    397c:	a0 f0       	brcs	.+40     	; 0x39a6 <__fixunssfsi+0x38>
    397e:	d1 f0       	breq	.+52     	; 0x39b4 <__fixunssfsi+0x46>
    3980:	66 0f       	add	r22, r22
    3982:	77 1f       	adc	r23, r23
    3984:	88 1f       	adc	r24, r24
    3986:	99 1f       	adc	r25, r25
    3988:	1a f0       	brmi	.+6      	; 0x3990 <__fixunssfsi+0x22>
    398a:	ba 95       	dec	r27
    398c:	c9 f7       	brne	.-14     	; 0x3980 <__fixunssfsi+0x12>
    398e:	12 c0       	rjmp	.+36     	; 0x39b4 <__fixunssfsi+0x46>
    3990:	b1 30       	cpi	r27, 0x01	; 1
    3992:	81 f0       	breq	.+32     	; 0x39b4 <__fixunssfsi+0x46>
    3994:	fc d0       	rcall	.+504    	; 0x3b8e <__fp_zero>
    3996:	b1 e0       	ldi	r27, 0x01	; 1
    3998:	08 95       	ret
    399a:	f9 c0       	rjmp	.+498    	; 0x3b8e <__fp_zero>
    399c:	67 2f       	mov	r22, r23
    399e:	78 2f       	mov	r23, r24
    39a0:	88 27       	eor	r24, r24
    39a2:	b8 5f       	subi	r27, 0xF8	; 248
    39a4:	39 f0       	breq	.+14     	; 0x39b4 <__fixunssfsi+0x46>
    39a6:	b9 3f       	cpi	r27, 0xF9	; 249
    39a8:	cc f3       	brlt	.-14     	; 0x399c <__fixunssfsi+0x2e>
    39aa:	86 95       	lsr	r24
    39ac:	77 95       	ror	r23
    39ae:	67 95       	ror	r22
    39b0:	b3 95       	inc	r27
    39b2:	d9 f7       	brne	.-10     	; 0x39aa <__fixunssfsi+0x3c>
    39b4:	3e f4       	brtc	.+14     	; 0x39c4 <__fixunssfsi+0x56>
    39b6:	90 95       	com	r25
    39b8:	80 95       	com	r24
    39ba:	70 95       	com	r23
    39bc:	61 95       	neg	r22
    39be:	7f 4f       	sbci	r23, 0xFF	; 255
    39c0:	8f 4f       	sbci	r24, 0xFF	; 255
    39c2:	9f 4f       	sbci	r25, 0xFF	; 255
    39c4:	08 95       	ret

000039c6 <__floatunsisf>:
    39c6:	e8 94       	clt
    39c8:	09 c0       	rjmp	.+18     	; 0x39dc <__floatsisf+0x12>

000039ca <__floatsisf>:
    39ca:	97 fb       	bst	r25, 7
    39cc:	3e f4       	brtc	.+14     	; 0x39dc <__floatsisf+0x12>
    39ce:	90 95       	com	r25
    39d0:	80 95       	com	r24
    39d2:	70 95       	com	r23
    39d4:	61 95       	neg	r22
    39d6:	7f 4f       	sbci	r23, 0xFF	; 255
    39d8:	8f 4f       	sbci	r24, 0xFF	; 255
    39da:	9f 4f       	sbci	r25, 0xFF	; 255
    39dc:	99 23       	and	r25, r25
    39de:	a9 f0       	breq	.+42     	; 0x3a0a <__floatsisf+0x40>
    39e0:	f9 2f       	mov	r31, r25
    39e2:	96 e9       	ldi	r25, 0x96	; 150
    39e4:	bb 27       	eor	r27, r27
    39e6:	93 95       	inc	r25
    39e8:	f6 95       	lsr	r31
    39ea:	87 95       	ror	r24
    39ec:	77 95       	ror	r23
    39ee:	67 95       	ror	r22
    39f0:	b7 95       	ror	r27
    39f2:	f1 11       	cpse	r31, r1
    39f4:	f8 cf       	rjmp	.-16     	; 0x39e6 <__floatsisf+0x1c>
    39f6:	fa f4       	brpl	.+62     	; 0x3a36 <__floatsisf+0x6c>
    39f8:	bb 0f       	add	r27, r27
    39fa:	11 f4       	brne	.+4      	; 0x3a00 <__floatsisf+0x36>
    39fc:	60 ff       	sbrs	r22, 0
    39fe:	1b c0       	rjmp	.+54     	; 0x3a36 <__floatsisf+0x6c>
    3a00:	6f 5f       	subi	r22, 0xFF	; 255
    3a02:	7f 4f       	sbci	r23, 0xFF	; 255
    3a04:	8f 4f       	sbci	r24, 0xFF	; 255
    3a06:	9f 4f       	sbci	r25, 0xFF	; 255
    3a08:	16 c0       	rjmp	.+44     	; 0x3a36 <__floatsisf+0x6c>
    3a0a:	88 23       	and	r24, r24
    3a0c:	11 f0       	breq	.+4      	; 0x3a12 <__floatsisf+0x48>
    3a0e:	96 e9       	ldi	r25, 0x96	; 150
    3a10:	11 c0       	rjmp	.+34     	; 0x3a34 <__floatsisf+0x6a>
    3a12:	77 23       	and	r23, r23
    3a14:	21 f0       	breq	.+8      	; 0x3a1e <__floatsisf+0x54>
    3a16:	9e e8       	ldi	r25, 0x8E	; 142
    3a18:	87 2f       	mov	r24, r23
    3a1a:	76 2f       	mov	r23, r22
    3a1c:	05 c0       	rjmp	.+10     	; 0x3a28 <__floatsisf+0x5e>
    3a1e:	66 23       	and	r22, r22
    3a20:	71 f0       	breq	.+28     	; 0x3a3e <__floatsisf+0x74>
    3a22:	96 e8       	ldi	r25, 0x86	; 134
    3a24:	86 2f       	mov	r24, r22
    3a26:	70 e0       	ldi	r23, 0x00	; 0
    3a28:	60 e0       	ldi	r22, 0x00	; 0
    3a2a:	2a f0       	brmi	.+10     	; 0x3a36 <__floatsisf+0x6c>
    3a2c:	9a 95       	dec	r25
    3a2e:	66 0f       	add	r22, r22
    3a30:	77 1f       	adc	r23, r23
    3a32:	88 1f       	adc	r24, r24
    3a34:	da f7       	brpl	.-10     	; 0x3a2c <__floatsisf+0x62>
    3a36:	88 0f       	add	r24, r24
    3a38:	96 95       	lsr	r25
    3a3a:	87 95       	ror	r24
    3a3c:	97 f9       	bld	r25, 7
    3a3e:	08 95       	ret

00003a40 <__fp_cmp>:
    3a40:	99 0f       	add	r25, r25
    3a42:	00 08       	sbc	r0, r0
    3a44:	55 0f       	add	r21, r21
    3a46:	aa 0b       	sbc	r26, r26
    3a48:	e0 e8       	ldi	r30, 0x80	; 128
    3a4a:	fe ef       	ldi	r31, 0xFE	; 254
    3a4c:	16 16       	cp	r1, r22
    3a4e:	17 06       	cpc	r1, r23
    3a50:	e8 07       	cpc	r30, r24
    3a52:	f9 07       	cpc	r31, r25
    3a54:	c0 f0       	brcs	.+48     	; 0x3a86 <__fp_cmp+0x46>
    3a56:	12 16       	cp	r1, r18
    3a58:	13 06       	cpc	r1, r19
    3a5a:	e4 07       	cpc	r30, r20
    3a5c:	f5 07       	cpc	r31, r21
    3a5e:	98 f0       	brcs	.+38     	; 0x3a86 <__fp_cmp+0x46>
    3a60:	62 1b       	sub	r22, r18
    3a62:	73 0b       	sbc	r23, r19
    3a64:	84 0b       	sbc	r24, r20
    3a66:	95 0b       	sbc	r25, r21
    3a68:	39 f4       	brne	.+14     	; 0x3a78 <__fp_cmp+0x38>
    3a6a:	0a 26       	eor	r0, r26
    3a6c:	61 f0       	breq	.+24     	; 0x3a86 <__fp_cmp+0x46>
    3a6e:	23 2b       	or	r18, r19
    3a70:	24 2b       	or	r18, r20
    3a72:	25 2b       	or	r18, r21
    3a74:	21 f4       	brne	.+8      	; 0x3a7e <__fp_cmp+0x3e>
    3a76:	08 95       	ret
    3a78:	0a 26       	eor	r0, r26
    3a7a:	09 f4       	brne	.+2      	; 0x3a7e <__fp_cmp+0x3e>
    3a7c:	a1 40       	sbci	r26, 0x01	; 1
    3a7e:	a6 95       	lsr	r26
    3a80:	8f ef       	ldi	r24, 0xFF	; 255
    3a82:	81 1d       	adc	r24, r1
    3a84:	81 1d       	adc	r24, r1
    3a86:	08 95       	ret

00003a88 <__fp_inf>:
    3a88:	97 f9       	bld	r25, 7
    3a8a:	9f 67       	ori	r25, 0x7F	; 127
    3a8c:	80 e8       	ldi	r24, 0x80	; 128
    3a8e:	70 e0       	ldi	r23, 0x00	; 0
    3a90:	60 e0       	ldi	r22, 0x00	; 0
    3a92:	08 95       	ret

00003a94 <__fp_nan>:
    3a94:	9f ef       	ldi	r25, 0xFF	; 255
    3a96:	80 ec       	ldi	r24, 0xC0	; 192
    3a98:	08 95       	ret

00003a9a <__fp_pscA>:
    3a9a:	00 24       	eor	r0, r0
    3a9c:	0a 94       	dec	r0
    3a9e:	16 16       	cp	r1, r22
    3aa0:	17 06       	cpc	r1, r23
    3aa2:	18 06       	cpc	r1, r24
    3aa4:	09 06       	cpc	r0, r25
    3aa6:	08 95       	ret

00003aa8 <__fp_pscB>:
    3aa8:	00 24       	eor	r0, r0
    3aaa:	0a 94       	dec	r0
    3aac:	12 16       	cp	r1, r18
    3aae:	13 06       	cpc	r1, r19
    3ab0:	14 06       	cpc	r1, r20
    3ab2:	05 06       	cpc	r0, r21
    3ab4:	08 95       	ret
    3ab6:	ee cf       	rjmp	.-36     	; 0x3a94 <__fp_nan>

00003ab8 <__fp_rempio2>:
    3ab8:	50 d0       	rcall	.+160    	; 0x3b5a <__fp_splitA>
    3aba:	e8 f3       	brcs	.-6      	; 0x3ab6 <__fp_pscB+0xe>
    3abc:	e8 94       	clt
    3abe:	e0 e0       	ldi	r30, 0x00	; 0
    3ac0:	bb 27       	eor	r27, r27
    3ac2:	9f 57       	subi	r25, 0x7F	; 127
    3ac4:	f0 f0       	brcs	.+60     	; 0x3b02 <__fp_rempio2+0x4a>
    3ac6:	2a ed       	ldi	r18, 0xDA	; 218
    3ac8:	3f e0       	ldi	r19, 0x0F	; 15
    3aca:	49 ec       	ldi	r20, 0xC9	; 201
    3acc:	06 c0       	rjmp	.+12     	; 0x3ada <__fp_rempio2+0x22>
    3ace:	ee 0f       	add	r30, r30
    3ad0:	bb 0f       	add	r27, r27
    3ad2:	66 1f       	adc	r22, r22
    3ad4:	77 1f       	adc	r23, r23
    3ad6:	88 1f       	adc	r24, r24
    3ad8:	28 f0       	brcs	.+10     	; 0x3ae4 <__fp_rempio2+0x2c>
    3ada:	b2 3a       	cpi	r27, 0xA2	; 162
    3adc:	62 07       	cpc	r22, r18
    3ade:	73 07       	cpc	r23, r19
    3ae0:	84 07       	cpc	r24, r20
    3ae2:	28 f0       	brcs	.+10     	; 0x3aee <__fp_rempio2+0x36>
    3ae4:	b2 5a       	subi	r27, 0xA2	; 162
    3ae6:	62 0b       	sbc	r22, r18
    3ae8:	73 0b       	sbc	r23, r19
    3aea:	84 0b       	sbc	r24, r20
    3aec:	e3 95       	inc	r30
    3aee:	9a 95       	dec	r25
    3af0:	72 f7       	brpl	.-36     	; 0x3ace <__fp_rempio2+0x16>
    3af2:	80 38       	cpi	r24, 0x80	; 128
    3af4:	30 f4       	brcc	.+12     	; 0x3b02 <__fp_rempio2+0x4a>
    3af6:	9a 95       	dec	r25
    3af8:	bb 0f       	add	r27, r27
    3afa:	66 1f       	adc	r22, r22
    3afc:	77 1f       	adc	r23, r23
    3afe:	88 1f       	adc	r24, r24
    3b00:	d2 f7       	brpl	.-12     	; 0x3af6 <__fp_rempio2+0x3e>
    3b02:	90 48       	sbci	r25, 0x80	; 128
    3b04:	ba c0       	rjmp	.+372    	; 0x3c7a <__fp_mpack_finite>

00003b06 <__fp_round>:
    3b06:	09 2e       	mov	r0, r25
    3b08:	03 94       	inc	r0
    3b0a:	00 0c       	add	r0, r0
    3b0c:	11 f4       	brne	.+4      	; 0x3b12 <__fp_round+0xc>
    3b0e:	88 23       	and	r24, r24
    3b10:	52 f0       	brmi	.+20     	; 0x3b26 <__fp_round+0x20>
    3b12:	bb 0f       	add	r27, r27
    3b14:	40 f4       	brcc	.+16     	; 0x3b26 <__fp_round+0x20>
    3b16:	bf 2b       	or	r27, r31
    3b18:	11 f4       	brne	.+4      	; 0x3b1e <__fp_round+0x18>
    3b1a:	60 ff       	sbrs	r22, 0
    3b1c:	04 c0       	rjmp	.+8      	; 0x3b26 <__fp_round+0x20>
    3b1e:	6f 5f       	subi	r22, 0xFF	; 255
    3b20:	7f 4f       	sbci	r23, 0xFF	; 255
    3b22:	8f 4f       	sbci	r24, 0xFF	; 255
    3b24:	9f 4f       	sbci	r25, 0xFF	; 255
    3b26:	08 95       	ret

00003b28 <__fp_sinus>:
    3b28:	ef 93       	push	r30
    3b2a:	e0 ff       	sbrs	r30, 0
    3b2c:	06 c0       	rjmp	.+12     	; 0x3b3a <__fp_sinus+0x12>
    3b2e:	a2 ea       	ldi	r26, 0xA2	; 162
    3b30:	2a ed       	ldi	r18, 0xDA	; 218
    3b32:	3f e0       	ldi	r19, 0x0F	; 15
    3b34:	49 ec       	ldi	r20, 0xC9	; 201
    3b36:	5f eb       	ldi	r21, 0xBF	; 191
    3b38:	53 de       	rcall	.-858    	; 0x37e0 <__addsf3x>
    3b3a:	e5 df       	rcall	.-54     	; 0x3b06 <__fp_round>
    3b3c:	0f 90       	pop	r0
    3b3e:	03 94       	inc	r0
    3b40:	01 fc       	sbrc	r0, 1
    3b42:	90 58       	subi	r25, 0x80	; 128
    3b44:	e4 ee       	ldi	r30, 0xE4	; 228
    3b46:	f0 e0       	ldi	r31, 0x00	; 0
    3b48:	a4 c0       	rjmp	.+328    	; 0x3c92 <__fp_powsodd>

00003b4a <__fp_split3>:
    3b4a:	57 fd       	sbrc	r21, 7
    3b4c:	90 58       	subi	r25, 0x80	; 128
    3b4e:	44 0f       	add	r20, r20
    3b50:	55 1f       	adc	r21, r21
    3b52:	59 f0       	breq	.+22     	; 0x3b6a <__fp_splitA+0x10>
    3b54:	5f 3f       	cpi	r21, 0xFF	; 255
    3b56:	71 f0       	breq	.+28     	; 0x3b74 <__fp_splitA+0x1a>
    3b58:	47 95       	ror	r20

00003b5a <__fp_splitA>:
    3b5a:	88 0f       	add	r24, r24
    3b5c:	97 fb       	bst	r25, 7
    3b5e:	99 1f       	adc	r25, r25
    3b60:	61 f0       	breq	.+24     	; 0x3b7a <__fp_splitA+0x20>
    3b62:	9f 3f       	cpi	r25, 0xFF	; 255
    3b64:	79 f0       	breq	.+30     	; 0x3b84 <__fp_splitA+0x2a>
    3b66:	87 95       	ror	r24
    3b68:	08 95       	ret
    3b6a:	12 16       	cp	r1, r18
    3b6c:	13 06       	cpc	r1, r19
    3b6e:	14 06       	cpc	r1, r20
    3b70:	55 1f       	adc	r21, r21
    3b72:	f2 cf       	rjmp	.-28     	; 0x3b58 <__fp_split3+0xe>
    3b74:	46 95       	lsr	r20
    3b76:	f1 df       	rcall	.-30     	; 0x3b5a <__fp_splitA>
    3b78:	08 c0       	rjmp	.+16     	; 0x3b8a <__fp_splitA+0x30>
    3b7a:	16 16       	cp	r1, r22
    3b7c:	17 06       	cpc	r1, r23
    3b7e:	18 06       	cpc	r1, r24
    3b80:	99 1f       	adc	r25, r25
    3b82:	f1 cf       	rjmp	.-30     	; 0x3b66 <__fp_splitA+0xc>
    3b84:	86 95       	lsr	r24
    3b86:	71 05       	cpc	r23, r1
    3b88:	61 05       	cpc	r22, r1
    3b8a:	08 94       	sec
    3b8c:	08 95       	ret

00003b8e <__fp_zero>:
    3b8e:	e8 94       	clt

00003b90 <__fp_szero>:
    3b90:	bb 27       	eor	r27, r27
    3b92:	66 27       	eor	r22, r22
    3b94:	77 27       	eor	r23, r23
    3b96:	cb 01       	movw	r24, r22
    3b98:	97 f9       	bld	r25, 7
    3b9a:	08 95       	ret

00003b9c <__gesf2>:
    3b9c:	51 df       	rcall	.-350    	; 0x3a40 <__fp_cmp>
    3b9e:	08 f4       	brcc	.+2      	; 0x3ba2 <__gesf2+0x6>
    3ba0:	8f ef       	ldi	r24, 0xFF	; 255
    3ba2:	08 95       	ret

00003ba4 <__mulsf3>:
    3ba4:	0b d0       	rcall	.+22     	; 0x3bbc <__mulsf3x>
    3ba6:	af cf       	rjmp	.-162    	; 0x3b06 <__fp_round>
    3ba8:	78 df       	rcall	.-272    	; 0x3a9a <__fp_pscA>
    3baa:	28 f0       	brcs	.+10     	; 0x3bb6 <__mulsf3+0x12>
    3bac:	7d df       	rcall	.-262    	; 0x3aa8 <__fp_pscB>
    3bae:	18 f0       	brcs	.+6      	; 0x3bb6 <__mulsf3+0x12>
    3bb0:	95 23       	and	r25, r21
    3bb2:	09 f0       	breq	.+2      	; 0x3bb6 <__mulsf3+0x12>
    3bb4:	69 cf       	rjmp	.-302    	; 0x3a88 <__fp_inf>
    3bb6:	6e cf       	rjmp	.-292    	; 0x3a94 <__fp_nan>
    3bb8:	11 24       	eor	r1, r1
    3bba:	ea cf       	rjmp	.-44     	; 0x3b90 <__fp_szero>

00003bbc <__mulsf3x>:
    3bbc:	c6 df       	rcall	.-116    	; 0x3b4a <__fp_split3>
    3bbe:	a0 f3       	brcs	.-24     	; 0x3ba8 <__mulsf3+0x4>

00003bc0 <__mulsf3_pse>:
    3bc0:	95 9f       	mul	r25, r21
    3bc2:	d1 f3       	breq	.-12     	; 0x3bb8 <__mulsf3+0x14>
    3bc4:	95 0f       	add	r25, r21
    3bc6:	50 e0       	ldi	r21, 0x00	; 0
    3bc8:	55 1f       	adc	r21, r21
    3bca:	62 9f       	mul	r22, r18
    3bcc:	f0 01       	movw	r30, r0
    3bce:	72 9f       	mul	r23, r18
    3bd0:	bb 27       	eor	r27, r27
    3bd2:	f0 0d       	add	r31, r0
    3bd4:	b1 1d       	adc	r27, r1
    3bd6:	63 9f       	mul	r22, r19
    3bd8:	aa 27       	eor	r26, r26
    3bda:	f0 0d       	add	r31, r0
    3bdc:	b1 1d       	adc	r27, r1
    3bde:	aa 1f       	adc	r26, r26
    3be0:	64 9f       	mul	r22, r20
    3be2:	66 27       	eor	r22, r22
    3be4:	b0 0d       	add	r27, r0
    3be6:	a1 1d       	adc	r26, r1
    3be8:	66 1f       	adc	r22, r22
    3bea:	82 9f       	mul	r24, r18
    3bec:	22 27       	eor	r18, r18
    3bee:	b0 0d       	add	r27, r0
    3bf0:	a1 1d       	adc	r26, r1
    3bf2:	62 1f       	adc	r22, r18
    3bf4:	73 9f       	mul	r23, r19
    3bf6:	b0 0d       	add	r27, r0
    3bf8:	a1 1d       	adc	r26, r1
    3bfa:	62 1f       	adc	r22, r18
    3bfc:	83 9f       	mul	r24, r19
    3bfe:	a0 0d       	add	r26, r0
    3c00:	61 1d       	adc	r22, r1
    3c02:	22 1f       	adc	r18, r18
    3c04:	74 9f       	mul	r23, r20
    3c06:	33 27       	eor	r19, r19
    3c08:	a0 0d       	add	r26, r0
    3c0a:	61 1d       	adc	r22, r1
    3c0c:	23 1f       	adc	r18, r19
    3c0e:	84 9f       	mul	r24, r20
    3c10:	60 0d       	add	r22, r0
    3c12:	21 1d       	adc	r18, r1
    3c14:	82 2f       	mov	r24, r18
    3c16:	76 2f       	mov	r23, r22
    3c18:	6a 2f       	mov	r22, r26
    3c1a:	11 24       	eor	r1, r1
    3c1c:	9f 57       	subi	r25, 0x7F	; 127
    3c1e:	50 40       	sbci	r21, 0x00	; 0
    3c20:	8a f0       	brmi	.+34     	; 0x3c44 <__mulsf3_pse+0x84>
    3c22:	e1 f0       	breq	.+56     	; 0x3c5c <__mulsf3_pse+0x9c>
    3c24:	88 23       	and	r24, r24
    3c26:	4a f0       	brmi	.+18     	; 0x3c3a <__mulsf3_pse+0x7a>
    3c28:	ee 0f       	add	r30, r30
    3c2a:	ff 1f       	adc	r31, r31
    3c2c:	bb 1f       	adc	r27, r27
    3c2e:	66 1f       	adc	r22, r22
    3c30:	77 1f       	adc	r23, r23
    3c32:	88 1f       	adc	r24, r24
    3c34:	91 50       	subi	r25, 0x01	; 1
    3c36:	50 40       	sbci	r21, 0x00	; 0
    3c38:	a9 f7       	brne	.-22     	; 0x3c24 <__mulsf3_pse+0x64>
    3c3a:	9e 3f       	cpi	r25, 0xFE	; 254
    3c3c:	51 05       	cpc	r21, r1
    3c3e:	70 f0       	brcs	.+28     	; 0x3c5c <__mulsf3_pse+0x9c>
    3c40:	23 cf       	rjmp	.-442    	; 0x3a88 <__fp_inf>
    3c42:	a6 cf       	rjmp	.-180    	; 0x3b90 <__fp_szero>
    3c44:	5f 3f       	cpi	r21, 0xFF	; 255
    3c46:	ec f3       	brlt	.-6      	; 0x3c42 <__mulsf3_pse+0x82>
    3c48:	98 3e       	cpi	r25, 0xE8	; 232
    3c4a:	dc f3       	brlt	.-10     	; 0x3c42 <__mulsf3_pse+0x82>
    3c4c:	86 95       	lsr	r24
    3c4e:	77 95       	ror	r23
    3c50:	67 95       	ror	r22
    3c52:	b7 95       	ror	r27
    3c54:	f7 95       	ror	r31
    3c56:	e7 95       	ror	r30
    3c58:	9f 5f       	subi	r25, 0xFF	; 255
    3c5a:	c1 f7       	brne	.-16     	; 0x3c4c <__mulsf3_pse+0x8c>
    3c5c:	fe 2b       	or	r31, r30
    3c5e:	88 0f       	add	r24, r24
    3c60:	91 1d       	adc	r25, r1
    3c62:	96 95       	lsr	r25
    3c64:	87 95       	ror	r24
    3c66:	97 f9       	bld	r25, 7
    3c68:	08 95       	ret

00003c6a <sin>:
    3c6a:	9f 93       	push	r25
    3c6c:	25 df       	rcall	.-438    	; 0x3ab8 <__fp_rempio2>
    3c6e:	0f 90       	pop	r0
    3c70:	07 fc       	sbrc	r0, 7
    3c72:	ee 5f       	subi	r30, 0xFE	; 254
    3c74:	59 cf       	rjmp	.-334    	; 0x3b28 <__fp_sinus>

00003c76 <__fp_mpack>:
    3c76:	9f 3f       	cpi	r25, 0xFF	; 255
    3c78:	31 f0       	breq	.+12     	; 0x3c86 <__fp_mpack_finite+0xc>

00003c7a <__fp_mpack_finite>:
    3c7a:	91 50       	subi	r25, 0x01	; 1
    3c7c:	20 f4       	brcc	.+8      	; 0x3c86 <__fp_mpack_finite+0xc>
    3c7e:	87 95       	ror	r24
    3c80:	77 95       	ror	r23
    3c82:	67 95       	ror	r22
    3c84:	b7 95       	ror	r27
    3c86:	88 0f       	add	r24, r24
    3c88:	91 1d       	adc	r25, r1
    3c8a:	96 95       	lsr	r25
    3c8c:	87 95       	ror	r24
    3c8e:	97 f9       	bld	r25, 7
    3c90:	08 95       	ret

00003c92 <__fp_powsodd>:
    3c92:	9f 93       	push	r25
    3c94:	8f 93       	push	r24
    3c96:	7f 93       	push	r23
    3c98:	6f 93       	push	r22
    3c9a:	ff 93       	push	r31
    3c9c:	ef 93       	push	r30
    3c9e:	9b 01       	movw	r18, r22
    3ca0:	ac 01       	movw	r20, r24
    3ca2:	80 df       	rcall	.-256    	; 0x3ba4 <__mulsf3>
    3ca4:	ef 91       	pop	r30
    3ca6:	ff 91       	pop	r31
    3ca8:	05 d0       	rcall	.+10     	; 0x3cb4 <__fp_powser>
    3caa:	2f 91       	pop	r18
    3cac:	3f 91       	pop	r19
    3cae:	4f 91       	pop	r20
    3cb0:	5f 91       	pop	r21
    3cb2:	78 cf       	rjmp	.-272    	; 0x3ba4 <__mulsf3>

00003cb4 <__fp_powser>:
    3cb4:	df 93       	push	r29
    3cb6:	cf 93       	push	r28
    3cb8:	1f 93       	push	r17
    3cba:	0f 93       	push	r16
    3cbc:	ff 92       	push	r15
    3cbe:	ef 92       	push	r14
    3cc0:	df 92       	push	r13
    3cc2:	7b 01       	movw	r14, r22
    3cc4:	8c 01       	movw	r16, r24
    3cc6:	68 94       	set
    3cc8:	05 c0       	rjmp	.+10     	; 0x3cd4 <__fp_powser+0x20>
    3cca:	da 2e       	mov	r13, r26
    3ccc:	ef 01       	movw	r28, r30
    3cce:	76 df       	rcall	.-276    	; 0x3bbc <__mulsf3x>
    3cd0:	fe 01       	movw	r30, r28
    3cd2:	e8 94       	clt
    3cd4:	a5 91       	lpm	r26, Z+
    3cd6:	25 91       	lpm	r18, Z+
    3cd8:	35 91       	lpm	r19, Z+
    3cda:	45 91       	lpm	r20, Z+
    3cdc:	55 91       	lpm	r21, Z+
    3cde:	ae f3       	brts	.-22     	; 0x3cca <__fp_powser+0x16>
    3ce0:	ef 01       	movw	r28, r30
    3ce2:	7e dd       	rcall	.-1284   	; 0x37e0 <__addsf3x>
    3ce4:	fe 01       	movw	r30, r28
    3ce6:	97 01       	movw	r18, r14
    3ce8:	a8 01       	movw	r20, r16
    3cea:	da 94       	dec	r13
    3cec:	79 f7       	brne	.-34     	; 0x3ccc <__fp_powser+0x18>
    3cee:	df 90       	pop	r13
    3cf0:	ef 90       	pop	r14
    3cf2:	ff 90       	pop	r15
    3cf4:	0f 91       	pop	r16
    3cf6:	1f 91       	pop	r17
    3cf8:	cf 91       	pop	r28
    3cfa:	df 91       	pop	r29
    3cfc:	08 95       	ret

00003cfe <__divmodhi4>:
    3cfe:	97 fb       	bst	r25, 7
    3d00:	09 2e       	mov	r0, r25
    3d02:	07 26       	eor	r0, r23
    3d04:	0a d0       	rcall	.+20     	; 0x3d1a <__divmodhi4_neg1>
    3d06:	77 fd       	sbrc	r23, 7
    3d08:	04 d0       	rcall	.+8      	; 0x3d12 <__divmodhi4_neg2>
    3d0a:	2e d0       	rcall	.+92     	; 0x3d68 <__udivmodhi4>
    3d0c:	06 d0       	rcall	.+12     	; 0x3d1a <__divmodhi4_neg1>
    3d0e:	00 20       	and	r0, r0
    3d10:	1a f4       	brpl	.+6      	; 0x3d18 <__divmodhi4_exit>

00003d12 <__divmodhi4_neg2>:
    3d12:	70 95       	com	r23
    3d14:	61 95       	neg	r22
    3d16:	7f 4f       	sbci	r23, 0xFF	; 255

00003d18 <__divmodhi4_exit>:
    3d18:	08 95       	ret

00003d1a <__divmodhi4_neg1>:
    3d1a:	f6 f7       	brtc	.-4      	; 0x3d18 <__divmodhi4_exit>
    3d1c:	90 95       	com	r25
    3d1e:	81 95       	neg	r24
    3d20:	9f 4f       	sbci	r25, 0xFF	; 255
    3d22:	08 95       	ret

00003d24 <__udivmodsi4>:
    3d24:	a1 e2       	ldi	r26, 0x21	; 33
    3d26:	1a 2e       	mov	r1, r26
    3d28:	aa 1b       	sub	r26, r26
    3d2a:	bb 1b       	sub	r27, r27
    3d2c:	fd 01       	movw	r30, r26
    3d2e:	0d c0       	rjmp	.+26     	; 0x3d4a <__udivmodsi4_ep>

00003d30 <__udivmodsi4_loop>:
    3d30:	aa 1f       	adc	r26, r26
    3d32:	bb 1f       	adc	r27, r27
    3d34:	ee 1f       	adc	r30, r30
    3d36:	ff 1f       	adc	r31, r31
    3d38:	a2 17       	cp	r26, r18
    3d3a:	b3 07       	cpc	r27, r19
    3d3c:	e4 07       	cpc	r30, r20
    3d3e:	f5 07       	cpc	r31, r21
    3d40:	20 f0       	brcs	.+8      	; 0x3d4a <__udivmodsi4_ep>
    3d42:	a2 1b       	sub	r26, r18
    3d44:	b3 0b       	sbc	r27, r19
    3d46:	e4 0b       	sbc	r30, r20
    3d48:	f5 0b       	sbc	r31, r21

00003d4a <__udivmodsi4_ep>:
    3d4a:	66 1f       	adc	r22, r22
    3d4c:	77 1f       	adc	r23, r23
    3d4e:	88 1f       	adc	r24, r24
    3d50:	99 1f       	adc	r25, r25
    3d52:	1a 94       	dec	r1
    3d54:	69 f7       	brne	.-38     	; 0x3d30 <__udivmodsi4_loop>
    3d56:	60 95       	com	r22
    3d58:	70 95       	com	r23
    3d5a:	80 95       	com	r24
    3d5c:	90 95       	com	r25
    3d5e:	9b 01       	movw	r18, r22
    3d60:	ac 01       	movw	r20, r24
    3d62:	bd 01       	movw	r22, r26
    3d64:	cf 01       	movw	r24, r30
    3d66:	08 95       	ret

00003d68 <__udivmodhi4>:
    3d68:	aa 1b       	sub	r26, r26
    3d6a:	bb 1b       	sub	r27, r27
    3d6c:	51 e1       	ldi	r21, 0x11	; 17
    3d6e:	07 c0       	rjmp	.+14     	; 0x3d7e <__udivmodhi4_ep>

00003d70 <__udivmodhi4_loop>:
    3d70:	aa 1f       	adc	r26, r26
    3d72:	bb 1f       	adc	r27, r27
    3d74:	a6 17       	cp	r26, r22
    3d76:	b7 07       	cpc	r27, r23
    3d78:	10 f0       	brcs	.+4      	; 0x3d7e <__udivmodhi4_ep>
    3d7a:	a6 1b       	sub	r26, r22
    3d7c:	b7 0b       	sbc	r27, r23

00003d7e <__udivmodhi4_ep>:
    3d7e:	88 1f       	adc	r24, r24
    3d80:	99 1f       	adc	r25, r25
    3d82:	5a 95       	dec	r21
    3d84:	a9 f7       	brne	.-22     	; 0x3d70 <__udivmodhi4_loop>
    3d86:	80 95       	com	r24
    3d88:	90 95       	com	r25
    3d8a:	bc 01       	movw	r22, r24
    3d8c:	cd 01       	movw	r24, r26
    3d8e:	08 95       	ret

00003d90 <do_rand>:
    3d90:	8f 92       	push	r8
    3d92:	9f 92       	push	r9
    3d94:	af 92       	push	r10
    3d96:	bf 92       	push	r11
    3d98:	cf 92       	push	r12
    3d9a:	df 92       	push	r13
    3d9c:	ef 92       	push	r14
    3d9e:	ff 92       	push	r15
    3da0:	cf 93       	push	r28
    3da2:	df 93       	push	r29
    3da4:	ec 01       	movw	r28, r24
    3da6:	88 81       	ld	r24, Y
    3da8:	99 81       	ldd	r25, Y+1	; 0x01
    3daa:	aa 81       	ldd	r26, Y+2	; 0x02
    3dac:	bb 81       	ldd	r27, Y+3	; 0x03
    3dae:	00 97       	sbiw	r24, 0x00	; 0
    3db0:	a1 05       	cpc	r26, r1
    3db2:	b1 05       	cpc	r27, r1
    3db4:	21 f4       	brne	.+8      	; 0x3dbe <do_rand+0x2e>
    3db6:	84 e2       	ldi	r24, 0x24	; 36
    3db8:	99 ed       	ldi	r25, 0xD9	; 217
    3dba:	ab e5       	ldi	r26, 0x5B	; 91
    3dbc:	b7 e0       	ldi	r27, 0x07	; 7
    3dbe:	bc 01       	movw	r22, r24
    3dc0:	cd 01       	movw	r24, r26
    3dc2:	2d e1       	ldi	r18, 0x1D	; 29
    3dc4:	33 ef       	ldi	r19, 0xF3	; 243
    3dc6:	41 e0       	ldi	r20, 0x01	; 1
    3dc8:	50 e0       	ldi	r21, 0x00	; 0
    3dca:	0e 94 6b 1f 	call	0x3ed6	; 0x3ed6 <__divmodsi4>
    3dce:	49 01       	movw	r8, r18
    3dd0:	5a 01       	movw	r10, r20
    3dd2:	27 ea       	ldi	r18, 0xA7	; 167
    3dd4:	31 e4       	ldi	r19, 0x41	; 65
    3dd6:	40 e0       	ldi	r20, 0x00	; 0
    3dd8:	50 e0       	ldi	r21, 0x00	; 0
    3dda:	0e 94 4c 1f 	call	0x3e98	; 0x3e98 <__mulsi3>
    3dde:	6b 01       	movw	r12, r22
    3de0:	7c 01       	movw	r14, r24
    3de2:	c5 01       	movw	r24, r10
    3de4:	b4 01       	movw	r22, r8
    3de6:	2c ee       	ldi	r18, 0xEC	; 236
    3de8:	34 ef       	ldi	r19, 0xF4	; 244
    3dea:	4f ef       	ldi	r20, 0xFF	; 255
    3dec:	5f ef       	ldi	r21, 0xFF	; 255
    3dee:	0e 94 4c 1f 	call	0x3e98	; 0x3e98 <__mulsi3>
    3df2:	dc 01       	movw	r26, r24
    3df4:	cb 01       	movw	r24, r22
    3df6:	c8 0e       	add	r12, r24
    3df8:	d9 1e       	adc	r13, r25
    3dfa:	ea 1e       	adc	r14, r26
    3dfc:	fb 1e       	adc	r15, r27
    3dfe:	f7 fe       	sbrs	r15, 7
    3e00:	08 c0       	rjmp	.+16     	; 0x3e12 <do_rand+0x82>
    3e02:	8f ef       	ldi	r24, 0xFF	; 255
    3e04:	9f ef       	ldi	r25, 0xFF	; 255
    3e06:	af ef       	ldi	r26, 0xFF	; 255
    3e08:	bf e7       	ldi	r27, 0x7F	; 127
    3e0a:	c8 0e       	add	r12, r24
    3e0c:	d9 1e       	adc	r13, r25
    3e0e:	ea 1e       	adc	r14, r26
    3e10:	fb 1e       	adc	r15, r27
    3e12:	c8 82       	st	Y, r12
    3e14:	d9 82       	std	Y+1, r13	; 0x01
    3e16:	ea 82       	std	Y+2, r14	; 0x02
    3e18:	fb 82       	std	Y+3, r15	; 0x03
    3e1a:	c6 01       	movw	r24, r12
    3e1c:	9f 77       	andi	r25, 0x7F	; 127
    3e1e:	df 91       	pop	r29
    3e20:	cf 91       	pop	r28
    3e22:	ff 90       	pop	r15
    3e24:	ef 90       	pop	r14
    3e26:	df 90       	pop	r13
    3e28:	cf 90       	pop	r12
    3e2a:	bf 90       	pop	r11
    3e2c:	af 90       	pop	r10
    3e2e:	9f 90       	pop	r9
    3e30:	8f 90       	pop	r8
    3e32:	08 95       	ret

00003e34 <rand_r>:
    3e34:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <do_rand>
    3e38:	08 95       	ret

00003e3a <rand>:
    3e3a:	83 e6       	ldi	r24, 0x63	; 99
    3e3c:	92 e0       	ldi	r25, 0x02	; 2
    3e3e:	0e 94 c8 1e 	call	0x3d90	; 0x3d90 <do_rand>
    3e42:	08 95       	ret

00003e44 <srand>:
    3e44:	a0 e0       	ldi	r26, 0x00	; 0
    3e46:	b0 e0       	ldi	r27, 0x00	; 0
    3e48:	80 93 63 02 	sts	0x0263, r24
    3e4c:	90 93 64 02 	sts	0x0264, r25
    3e50:	a0 93 65 02 	sts	0x0265, r26
    3e54:	b0 93 66 02 	sts	0x0266, r27
    3e58:	08 95       	ret

00003e5a <memcpy>:
    3e5a:	fb 01       	movw	r30, r22
    3e5c:	dc 01       	movw	r26, r24
    3e5e:	02 c0       	rjmp	.+4      	; 0x3e64 <memcpy+0xa>
    3e60:	01 90       	ld	r0, Z+
    3e62:	0d 92       	st	X+, r0
    3e64:	41 50       	subi	r20, 0x01	; 1
    3e66:	50 40       	sbci	r21, 0x00	; 0
    3e68:	d8 f7       	brcc	.-10     	; 0x3e60 <memcpy+0x6>
    3e6a:	08 95       	ret

00003e6c <memset>:
    3e6c:	dc 01       	movw	r26, r24
    3e6e:	01 c0       	rjmp	.+2      	; 0x3e72 <memset+0x6>
    3e70:	6d 93       	st	X+, r22
    3e72:	41 50       	subi	r20, 0x01	; 1
    3e74:	50 40       	sbci	r21, 0x00	; 0
    3e76:	e0 f7       	brcc	.-8      	; 0x3e70 <memset+0x4>
    3e78:	08 95       	ret

00003e7a <strncpy>:
    3e7a:	fb 01       	movw	r30, r22
    3e7c:	dc 01       	movw	r26, r24
    3e7e:	41 50       	subi	r20, 0x01	; 1
    3e80:	50 40       	sbci	r21, 0x00	; 0
    3e82:	48 f0       	brcs	.+18     	; 0x3e96 <strncpy+0x1c>
    3e84:	01 90       	ld	r0, Z+
    3e86:	0d 92       	st	X+, r0
    3e88:	00 20       	and	r0, r0
    3e8a:	c9 f7       	brne	.-14     	; 0x3e7e <strncpy+0x4>
    3e8c:	01 c0       	rjmp	.+2      	; 0x3e90 <strncpy+0x16>
    3e8e:	1d 92       	st	X+, r1
    3e90:	41 50       	subi	r20, 0x01	; 1
    3e92:	50 40       	sbci	r21, 0x00	; 0
    3e94:	e0 f7       	brcc	.-8      	; 0x3e8e <strncpy+0x14>
    3e96:	08 95       	ret

00003e98 <__mulsi3>:
    3e98:	62 9f       	mul	r22, r18
    3e9a:	d0 01       	movw	r26, r0
    3e9c:	73 9f       	mul	r23, r19
    3e9e:	f0 01       	movw	r30, r0
    3ea0:	82 9f       	mul	r24, r18
    3ea2:	e0 0d       	add	r30, r0
    3ea4:	f1 1d       	adc	r31, r1
    3ea6:	64 9f       	mul	r22, r20
    3ea8:	e0 0d       	add	r30, r0
    3eaa:	f1 1d       	adc	r31, r1
    3eac:	92 9f       	mul	r25, r18
    3eae:	f0 0d       	add	r31, r0
    3eb0:	83 9f       	mul	r24, r19
    3eb2:	f0 0d       	add	r31, r0
    3eb4:	74 9f       	mul	r23, r20
    3eb6:	f0 0d       	add	r31, r0
    3eb8:	65 9f       	mul	r22, r21
    3eba:	f0 0d       	add	r31, r0
    3ebc:	99 27       	eor	r25, r25
    3ebe:	72 9f       	mul	r23, r18
    3ec0:	b0 0d       	add	r27, r0
    3ec2:	e1 1d       	adc	r30, r1
    3ec4:	f9 1f       	adc	r31, r25
    3ec6:	63 9f       	mul	r22, r19
    3ec8:	b0 0d       	add	r27, r0
    3eca:	e1 1d       	adc	r30, r1
    3ecc:	f9 1f       	adc	r31, r25
    3ece:	bd 01       	movw	r22, r26
    3ed0:	cf 01       	movw	r24, r30
    3ed2:	11 24       	eor	r1, r1
    3ed4:	08 95       	ret

00003ed6 <__divmodsi4>:
    3ed6:	97 fb       	bst	r25, 7
    3ed8:	09 2e       	mov	r0, r25
    3eda:	05 26       	eor	r0, r21
    3edc:	0e d0       	rcall	.+28     	; 0x3efa <__divmodsi4_neg1>
    3ede:	57 fd       	sbrc	r21, 7
    3ee0:	04 d0       	rcall	.+8      	; 0x3eea <__divmodsi4_neg2>
    3ee2:	20 df       	rcall	.-448    	; 0x3d24 <__udivmodsi4>
    3ee4:	0a d0       	rcall	.+20     	; 0x3efa <__divmodsi4_neg1>
    3ee6:	00 1c       	adc	r0, r0
    3ee8:	38 f4       	brcc	.+14     	; 0x3ef8 <__divmodsi4_exit>

00003eea <__divmodsi4_neg2>:
    3eea:	50 95       	com	r21
    3eec:	40 95       	com	r20
    3eee:	30 95       	com	r19
    3ef0:	21 95       	neg	r18
    3ef2:	3f 4f       	sbci	r19, 0xFF	; 255
    3ef4:	4f 4f       	sbci	r20, 0xFF	; 255
    3ef6:	5f 4f       	sbci	r21, 0xFF	; 255

00003ef8 <__divmodsi4_exit>:
    3ef8:	08 95       	ret

00003efa <__divmodsi4_neg1>:
    3efa:	f6 f7       	brtc	.-4      	; 0x3ef8 <__divmodsi4_exit>
    3efc:	90 95       	com	r25
    3efe:	80 95       	com	r24
    3f00:	70 95       	com	r23
    3f02:	61 95       	neg	r22
    3f04:	7f 4f       	sbci	r23, 0xFF	; 255
    3f06:	8f 4f       	sbci	r24, 0xFF	; 255
    3f08:	9f 4f       	sbci	r25, 0xFF	; 255
    3f0a:	08 95       	ret

00003f0c <_exit>:
    3f0c:	f8 94       	cli

00003f0e <__stop_program>:
    3f0e:	ff cf       	rjmp	.-2      	; 0x3f0e <__stop_program>
